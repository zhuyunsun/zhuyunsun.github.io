<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Swift系列16-类型转换</title>
      <link href="/2021/04/27/Swift%E7%B3%BB%E5%88%97P16-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/04/27/Swift%E7%B3%BB%E5%88%97P16-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换可以判断实例的类型,或者在该实例层次中父类或子类的实例.<br>Swift中转换实现是 is 和 as 两个关键字.  </p> <a id="more"></a><h3 id="类型检查-is"><a href="#类型检查-is" class="headerlink" title="类型检查 is"></a>类型检查 is</h3><p>is检查一个实例的类型,返回true或false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let ar1 &#x3D; [&quot;1&quot;,&quot;2&quot;]</span><br><span class="line">if ar1 is Array&lt;Any&gt; &#123;</span><br><span class="line">    print(&quot;arr1是一个数组&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s1 &#x3D; &quot;s1&quot;</span><br><span class="line">if s1 is String &#123;</span><br><span class="line">    print(&quot;s1是一个字符串实例&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向下的类型转换-as"><a href="#向下的类型转换-as" class="headerlink" title="向下的类型转换  as"></a>向下的类型转换  as</h3><p>as是把某值转换成另外一种类型.<br>当你确定会转换成功时,使用 as 或 as! 来展开;<br>当不确定有值时,使用 as? 可选来进行转换,也就是转换失败时,可以返回nil.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let ar2 &#x3D; ar1 as Array&lt;Any&gt;</span><br><span class="line">print(&quot;ar1作为数组展开 并且赋值给ar2 \(ar2)&quot;)</span><br><span class="line"></span><br><span class="line">var g1:String?</span><br><span class="line">let s2 &#x3D; g1 as? Any</span><br><span class="line">let s3 &#x3D; s1 as! String</span><br></pre></td></tr></table></figure><h3 id="Any和AnyObject的类型转换"><a href="#Any和AnyObject的类型转换" class="headerlink" title="Any和AnyObject的类型转换"></a>Any和AnyObject的类型转换</h3><p>这两种是Swift提供的不确定的类型<br>AnyObject表示任何实例(对象)<br>Any表示任何类型,包括函数类型   </p><p>当你确切的需要使用他们的功能和行为时再使用Any和AnyObject.<br>在写代码时,明确类型表达总是要好些.  </p><p>样例:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当数组是Any类型时,可以添加任何类型</span><br><span class="line">var arr3 &#x3D; [Any]()</span><br><span class="line">arr3.append(&quot;212&quot;)</span><br><span class="line">arr3.append(123)</span><br><span class="line">arr3.append(32.22)</span><br><span class="line">arr3.append(UILabel())</span><br><span class="line">print(arr3)</span><br></pre></td></tr></table></figure><p>The End</p>]]></content>
      
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列15-扩展</title>
      <link href="/2021/04/27/Swift%E7%B3%BB%E5%88%97P15-%E6%89%A9%E5%B1%95/"/>
      <url>/2021/04/27/Swift%E7%B3%BB%E5%88%97P15-%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>扩展为现有的类,结构体,枚举和协议添加新功能.<br>扩展可以向一个类型添加新的方法,但是不能重写已有的方法.  </p><blockquote><p>扩展跟OC的分类有点相似,但是Swift的扩展是没有名字的.  </p></blockquote><p>extension 关键字<br>形如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension SomeType&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="扩展计算属性"><a href="#扩展计算属性" class="headerlink" title="扩展计算属性"></a>扩展计算属性</h3><p>扩展可以添加计算属性,但是不能添加存储属性,也不能为已有的属性添加属性观察者.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Tuesday: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">extension Tuesday&#123;</span><br><span class="line">    var weekName:String&#123;</span><br><span class="line">        return &quot;周二&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展新的初始化"><a href="#扩展新的初始化" class="headerlink" title="扩展新的初始化"></a>扩展新的初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原有的初始化</span><br><span class="line">class Tuesday: NSObject &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extension Tuesday&#123;   </span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    convenience init(_ new:String) &#123;</span><br><span class="line">        self.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">class Owner: NSObject &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        let t1 &#x3D; Tuesday.init(&quot;12321&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展新的实例方法和类方法"><a href="#扩展新的实例方法和类方法" class="headerlink" title="扩展新的实例方法和类方法"></a>扩展新的实例方法和类方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Tuesday: NSObject &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extension Tuesday&#123;</span><br><span class="line">&#x2F;&#x2F;类方法</span><br><span class="line">   class func fun1()&#123;</span><br><span class="line">        print(&quot;func1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;实例方法</span><br><span class="line">    func fun2()&#123;</span><br><span class="line">        print(&quot;fun2&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Owner: NSObject &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        let t1 &#x3D; Tuesday.init(&quot;周二&quot;)</span><br><span class="line">        &#x2F;&#x2F;调用</span><br><span class="line">        t1.fun2()</span><br><span class="line">        Tuesday.fun1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异变方法"><a href="#异变方法" class="headerlink" title="异变方法"></a>异变方法</h4><p>增加了扩展的实例方法仍可以修改(或异变)实例本身.结构体和枚举类型方法在修改 self 或本身的属性时必须标记实例方法为 mutating,和原本实现的异变方法一样.<br>下面的例子为 Swift 的 Int 类型添加了一个新的异变方法 square ，以表示原值的平方:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    mutating func square() &#123;</span><br><span class="line">        self &#x3D; self * self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var someInt &#x3D; 3</span><br><span class="line">someInt.square()</span><br><span class="line">&#x2F;&#x2F;someInt is now 9</span><br></pre></td></tr></table></figure><h3 id="扩展协议"><a href="#扩展协议" class="headerlink" title="扩展协议"></a>扩展协议</h3><p>协议扩展能添加已经实现的属性和方法,但是不能为协议添加新的必须要实现的属性和方法.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension UITextFieldDelegate&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展类遵循协议"><a href="#扩展类遵循协议" class="headerlink" title="扩展类遵循协议"></a>扩展类遵循协议</h3><p>扩展类遵循多个协议.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class People: NSObject &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">extension People:UITextViewDelegate,UITextFieldDelegate&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他扩展"><a href="#其他扩展" class="headerlink" title="其他扩展"></a>其他扩展</h3><p>定义下标<br>定义和使用新的内嵌类型  </p><p>THE END</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列14-初始化</title>
      <link href="/2021/04/26/Swift%E7%B3%BB%E5%88%97P14-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2021/04/26/Swift%E7%B3%BB%E5%88%97P14-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>初始化是为类,结构体,枚举准备实例的过程.<br>这个过程需要给实例里的每一个存储属性设置一个初始值,并且在新实例可以使用之前执行任何其他所必须的配置或者初始化.  </p><p>通过初始化器来实现这个初始化过程,它更像是一个用来创建特定新实例特殊的方法.<br>不同于OC的初始化,Swift初始化不需要返回值.这些初始化器主要的角色是保证第一次使用之前某类型的新实例能够正确的初始化.  </p><p>类实例的初始化有一个反初始化器,它会在这个类的实例被释放之前执行任意的自定义清理.  </p><a id="more"></a>  <h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="初始化属性赋值"><a href="#初始化属性赋值" class="headerlink" title="初始化属性赋值"></a>初始化属性赋值</h3><p>初始化给存储属性设置初始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化为name属性设置初始化值</span><br><span class="line">class People: NSObject &#123;</span><br><span class="line">    var name:String?</span><br><span class="line">    override init() &#123;</span><br><span class="line">        name &#x3D; &quot;gc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BaseMessage: NSObject &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        let p &#x3D; People.init()</span><br><span class="line">        print(p.name!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义初始化"><a href="#自定义初始化" class="headerlink" title="自定义初始化"></a>自定义初始化</h3><p>初始化参数:<br>形式参数名 _ a:String<br>实参参数名 b:String  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Monday: NSObject &#123;</span><br><span class="line">    init(_ a:String,b:String) &#123;</span><br><span class="line">        print(&quot;\(a) \(b)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BaseMessage: NSObject &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        let m &#x3D; Monday.init(&quot;1&quot;, b: &quot;2&quot;)</span><br><span class="line">        print(m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认初始化器"><a href="#默认初始化器" class="headerlink" title="默认初始化器"></a>默认初始化器</h3><p>创建一个实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let u &#x3D; UIView()</span><br></pre></td></tr></table></figure><h3 id="结构体类型的初始化"><a href="#结构体类型的初始化" class="headerlink" title="结构体类型的初始化"></a>结构体类型的初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Tree &#123;</span><br><span class="line">    var tail:CGFloat,width:CGFloat</span><br><span class="line">&#125;</span><br><span class="line">let t1 &#x3D; Tree.init(tail: 10.1, width: 2.1)</span><br><span class="line">print(t1.tail,t1.width)</span><br></pre></td></tr></table></figure><h2 id="类的继承和初始化"><a href="#类的继承和初始化" class="headerlink" title="类的继承和初始化"></a>类的继承和初始化</h2><h3 id="主要的init"><a href="#主要的init" class="headerlink" title="主要的init()"></a>主要的init()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let v2 &#x3D; UIView.init()</span><br></pre></td></tr></table></figure><h3 id="便利构造器"><a href="#便利构造器" class="headerlink" title="便利构造器"></a>便利构造器</h3><p>convenience,在必要的时候给类提供,次要的辅助型的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class CountDownView: UIView &#123;</span><br><span class="line"> convenience init(_ name:String) &#123;</span><br><span class="line">     self.init(frame: CGRect.zero)&#x2F;&#x2F;必须要实现父类的初始化</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可失败的构造器-init"><a href="#可失败的构造器-init" class="headerlink" title="可失败的构造器:init?"></a>可失败的构造器:init?</h3><p>没有传值或者传值不对的时候,会导致初始化失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Animal &#123;</span><br><span class="line">    let species: String</span><br><span class="line">    init?(species: String) &#123;</span><br><span class="line">        if species.isEmpty &#123; return nil &#125;</span><br><span class="line">        self.species &#x3D; species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let anonymousCreature &#x3D; Animal(species: &quot;&quot;)</span><br><span class="line">if anonymousCreature &#x3D;&#x3D; nil &#123;</span><br><span class="line">    print(&quot;初始化失败&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="required-必要初始化器"><a href="#required-必要初始化器" class="headerlink" title="required 必要初始化器"></a>required 必要初始化器</h3><p>当父类初始化用required关键字修饰时,子类必须要要实现它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BookBaseView: UIView &#123;</span><br><span class="line"> override init(frame: CGRect) &#123;</span><br><span class="line">        super.init(frame: frame)</span><br><span class="line">    &#125;</span><br><span class="line">required init?(coder: NSCoder) &#123;</span><br><span class="line">        fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The End</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列13-访问控制</title>
      <link href="/2021/04/25/Swift%E7%B3%BB%E5%88%97P13-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
      <url>/2021/04/25/Swift%E7%B3%BB%E5%88%97P13-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><h3 id="模块和源文件"><a href="#模块和源文件" class="headerlink" title="模块和源文件"></a>模块和源文件</h3><p>Swift的访问控制模型基于模块和源文件的概念.<br>模块:如UIKit就是一个模块,你也可以自己定义自己的模块(静态库)<br>源文件:就是一个后缀为.swift的文件.  </p><a id="more"></a><h3 id="五个分级别访问控制"><a href="#五个分级别访问控制" class="headerlink" title="五个分级别访问控制"></a>五个分级别访问控制</h3><h4 id="open-最高级别-修饰的类和成员允许被其他模块访问-继承和重写"><a href="#open-最高级别-修饰的类和成员允许被其他模块访问-继承和重写" class="headerlink" title="open 最高级别,修饰的类和成员允许被其他模块访问,继承和重写"></a>open 最高级别,修饰的类和成员允许被其他模块访问,继承和重写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">open class K1:NSObject&#123;</span><br><span class="line">    open var a1 &#x3D; &quot;public修饰的属性&quot;</span><br><span class="line">    open func abc()&#123;</span><br><span class="line">        print(&quot;public修饰的方法&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    public override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-修饰的类和成员可以被访问但不允许被其他模块继承和重写"><a href="#public-修饰的类和成员可以被访问但不允许被其他模块继承和重写" class="headerlink" title="public 修饰的类和成员可以被访问但不允许被其他模块继承和重写"></a>public 修饰的类和成员可以被访问但不允许被其他模块继承和重写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class K1:NSObject&#123;</span><br><span class="line">    public var a1 &#x3D; &quot;属性&quot;</span><br><span class="line">    public func abc()&#123;</span><br><span class="line">        print(&quot;方法&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    public override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="internal-默认级别-可以被模块内任意文件访问-但是不能被模块之外的文件访问"><a href="#internal-默认级别-可以被模块内任意文件访问-但是不能被模块之外的文件访问" class="headerlink" title="internal 默认级别,可以被模块内任意文件访问,但是不能被模块之外的文件访问"></a>internal 默认级别,可以被模块内任意文件访问,但是不能被模块之外的文件访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class K1:NSObject&#123;</span><br><span class="line">    internal var a1 &#x3D; &quot;属性&quot;</span><br><span class="line">    func abc()&#123; &#x2F;&#x2F;不书写时,默认是internal</span><br><span class="line">        print(&quot;方法&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fileprivate-只允许当前文件访问-当前文件定义多个类-结构体等都可以访问"><a href="#fileprivate-只允许当前文件访问-当前文件定义多个类-结构体等都可以访问" class="headerlink" title="fileprivate  只允许当前文件访问,当前文件定义多个类,结构体等都可以访问"></a>fileprivate  只允许当前文件访问,当前文件定义多个类,结构体等都可以访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fileprivate class K1:NSObject&#123;</span><br><span class="line">    fileprivate var a1 &#x3D; &quot;属性&quot;</span><br><span class="line">    fileprivate func abc()&#123;</span><br><span class="line">        print(&quot;方法&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fileprivate override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="private-只允许当前类使用"><a href="#private-只允许当前类使用" class="headerlink" title="private 只允许当前类使用"></a>private 只允许当前类使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private class K1:NSObject&#123;</span><br><span class="line">    private var a1 &#x3D; &quot;属性&quot;</span><br><span class="line">    private func abc()&#123;</span><br><span class="line">        print(&quot;方法&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    private override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元组的访问控制"><a href="#元组的访问控制" class="headerlink" title="元组的访问控制"></a>元组的访问控制</h3><p>元组类型的访问级别是所有类型里最严格的.例如,如果你将两个不同类型的元素组成一个元组,一个元素的访问级别是internal,另一个是private,那么这个元组类型是private 级别的.</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;所有成员都是public</span><br><span class="line">public enum CompassPoint &#123;</span><br><span class="line">      case north</span><br><span class="line">      case south</span><br><span class="line">      case east</span><br><span class="line">      case west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>继承子类的访问控制不能比父类的访问控制级别高.如父类是internal,那么子类就不能是public,协议的继承也是如此.<br>扩展的访问控制和被扩展的类,结构体,枚举保持一致.<br>泛指类型和泛指函数的访问级别取泛指类型或函数以及泛型类型参数的访问级别的最小值.</p><p>The End</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift访问控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列12-协议</title>
      <link href="/2021/04/22/Swift%E7%B3%BB%E5%88%97P12-%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/04/22/Swift%E7%B3%BB%E5%88%97P12-%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>使用protocol关键字<br>形如:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol 协议名 &#123;</span><br><span class="line">    func 方法1()&#x2F;&#x2F;没有方法主体</span><br><span class="line">    func 方法2()</span><br><span class="line">    var age:Int&#123;get set&#125;&#x2F;&#x2F;可读可写属性</span><br><span class="line">    var gander:Int&#123;get&#125;&#x2F;&#x2F;只读属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>一个类需要实现多个协议的用逗号,进行隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DelegateView: BaseViewController,MsgDelegate,DataDelegate &#123;</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">super.viewDidLoad()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协议中的属性"><a href="#协议中的属性" class="headerlink" title="协议中的属性"></a>协议中的属性</h3><p>协议中的属性:<br>1,必须使用var来修饰<br>2,不允许有默认值<br>3,只能使用{set get}可读可写,{get}只读来修饰.<br>4,属性必须要实现赋值<br>5,使用static进行修饰的属性,需要类实现  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protocol CarDelegate &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;属性可读可写</span><br><span class="line">    var name:String&#123;get set&#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;属性只读</span><br><span class="line">    var from:String&#123;get&#125;</span><br><span class="line">    static var time:String&#123;get set&#125; &#x2F;&#x2F;使用static进行修饰的属性,需要类实现</span><br><span class="line">&#125;</span><br><span class="line">class BaseCar: NSObject&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;BaseCar类的协议</span><br><span class="line">    var delegate:CarDelegate?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ShowMessage: NSObject,CarDelegate &#123;</span><br><span class="line">    var name: String &#x3D; &quot;特斯拉&quot;</span><br><span class="line">    var from: String &#x3D; &quot;USA&quot;&#x2F;&#x2F;由于是可读属性,可以使用let关键字修饰:let from: String &#x3D; &quot;USA&quot;</span><br><span class="line">    static var time: String &#x3D; &quot;time&quot;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(name)</span><br><span class="line">        name &#x3D; &quot;宝马&quot;</span><br><span class="line">        print(name)</span><br><span class="line">        print(ShowMessage.time) &#x2F;&#x2F;类实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协议中的方法"><a href="#协议中的方法" class="headerlink" title="协议中的方法"></a>协议中的方法</h3><p>协议中的方法:<br>1,不能有方法体,只是声明方法<br>2,方法形参不可以有默认值<br>3,方法默认都是必须实现的<br>4,可选方法:需要@objc修饰protocol,对应的方法还要@objc optional修饰<br>5,异变方法:mutating</p><h4 id="默认实现的方法"><a href="#默认实现的方法" class="headerlink" title="默认实现的方法"></a>默认实现的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol DataDelegate: AnyObject &#123;</span><br><span class="line">    func todayFor()</span><br><span class="line">    func getMessage(_ height:CGFloat)</span><br><span class="line">&#125;</span><br><span class="line">class CommonMessage: NSObject &#123;</span><br><span class="line">    &#x2F;&#x2F;使用weak来修饰,防止出现实例之间的循环引用</span><br><span class="line">    weak var dataDelegate:DataDelegate?</span><br><span class="line">    func beginSomething() &#123;        </span><br><span class="line">        self.dataDelegate?.getMessage(100)</span><br><span class="line">        self.dataDelegate?.todayFor()  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DelegateView: BaseViewController,DataDelegate &#123;   </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        com &#x3D; CommonMessage.init()</span><br><span class="line">        com.dataDelegate &#x3D; self &#x2F;&#x2F;协议</span><br><span class="line">        com.beginSomething()</span><br><span class="line">    &#125;</span><br><span class="line">   func todayFor() &#123;</span><br><span class="line">        print(&quot;必须实现的协议&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">   func getMessage(_ height: CGFloat) &#123;</span><br><span class="line">        print(&quot;传递参数&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选实现方法"><a href="#可选实现方法" class="headerlink" title="可选实现方法"></a>可选实现方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> @objc protocol MsgDelegate:AnyObject &#123;</span><br><span class="line">    func from() &#x2F;&#x2F;这个方法没有@objc optional修饰,也是必须实现的</span><br><span class="line">    @objc optional func address()</span><br><span class="line">&#125;</span><br><span class="line">class CommonMessage: NSObject &#123;</span><br><span class="line">    &#x2F;&#x2F;使用weak来修饰,防止出现实例之间的循环引用</span><br><span class="line">    weak var delegate:MsgDelegate?</span><br><span class="line">    func beginSomething() &#123;</span><br><span class="line">        self.delegate?.from()</span><br><span class="line">        if self.delegate?.address?() !&#x3D; nil &#123;</span><br><span class="line">            print(&quot;实现了address&quot;)</span><br><span class="line">            self.delegate?.address?()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            print(&quot;没有实现address对应协议&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         OC中有判断协议是否已经实现了的方法;</span><br><span class="line">         swift中则没有,如果要判断使用如上(self.delegate?.address?() !&#x3D; nil),</span><br><span class="line">         必须是可选协议方法才能进行判断,必须实现的方法就必须实现;</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异变方法"><a href="#异变方法" class="headerlink" title="异变方法"></a>异变方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;有时一个方法需要改变（或异变）其所属的实例.</span><br><span class="line">protocol Togglable &#123;</span><br><span class="line">    mutating func toggle()</span><br><span class="line">&#125;</span><br><span class="line">enum OnOffSwitch: Togglable &#123;</span><br><span class="line">    case off, on</span><br><span class="line">    mutating func toggle() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .off:</span><br><span class="line">            self &#x3D; .on</span><br><span class="line">        case .on:</span><br><span class="line">            self &#x3D; .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var lightSwitch &#x3D; OnOffSwitch.off &#x2F;&#x2F;先设置了off</span><br><span class="line">lightSwitch.toggle() &#x2F;&#x2F;调用异变方法 现在是on</span><br></pre></td></tr></table></figure><h3 id="协议是否继承AnyObject"><a href="#协议是否继承AnyObject" class="headerlink" title="协议是否继承AnyObject"></a>协议是否继承AnyObject</h3><p>协议可用于结构体,枚举,类<br> 在类中使用,书写的协议时,协议需要继承AnyObject;这样协议可以用weak进行修饰,防止出现实例的循环引用;<br> 不使用NSObjectProtocol,是因为NSObjectProtocol是OC语言的,swift不推荐使用;  </p><h4 id="用于类之间的协议-AnyObject-需要添加weak来修饰防止循环引用"><a href="#用于类之间的协议-AnyObject-需要添加weak来修饰防止循环引用" class="headerlink" title="用于类之间的协议:AnyObject,需要添加weak来修饰防止循环引用"></a>用于类之间的协议:AnyObject,需要添加weak来修饰防止循环引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol 协议名 : AnyObject&#123;</span><br><span class="line">    func 方法1()&#x2F;&#x2F;没有方法主体</span><br><span class="line">    func 方法2()</span><br><span class="line">    var age:Int&#123;get set&#125;&#x2F;&#x2F;可读可写属性</span><br><span class="line">    var gander:Int&#123;get&#125;&#x2F;&#x2F;只读属性</span><br><span class="line">&#125;</span><br><span class="line">class PC: NSObject &#123;</span><br><span class="line">    weak var dele:协议名?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用于结构体或枚举-不需要使用weak来修饰协议"><a href="#用于结构体或枚举-不需要使用weak来修饰协议" class="headerlink" title="用于结构体或枚举,不需要使用weak来修饰协议"></a>用于结构体或枚举,不需要使用weak来修饰协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;用于结构体或枚举,不需要使用weak来修饰协议</span><br><span class="line">protocol Another &#123;</span><br><span class="line">    func 方法()</span><br><span class="line">&#125;</span><br><span class="line">class PC: NSObject &#123;</span><br><span class="line">    var le:Another?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The End</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列11-继承</title>
      <link href="/2021/04/22/Swift%E7%B3%BB%E5%88%97P11-%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/04/22/Swift%E7%B3%BB%E5%88%97P11-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>一个类可以从另外一个类继承属性,方法和其他特征;<br>当一个类继承另一个类时,继承的类就是子类,被继承的类就叫父类.  </p><p>子类可以调用和访问属于他父类的方法,属性和下标脚本,并且可以提供他们重写的方法,属性和下标来定义或者修改他的行为.  </p><a id="more"></a><h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><p>任何一个不从其他类继承的类都叫基类;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建基类</span><br><span class="line">class Earth &#123;</span><br><span class="line">    var sea &#x3D; &quot;海洋&quot;</span><br><span class="line">    var sky &#x3D; &quot;天空&quot;</span><br><span class="line">    var land &#x3D; &quot;陆地&quot;</span><br><span class="line">    var biology &#x3D; &quot;生物&quot;</span><br><span class="line">    var flow:String&#123;</span><br><span class="line">        return &quot;flow&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    func seaColor()&#123;</span><br><span class="line">        print(&quot;蓝色&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><p>子类是基于现有的类创建新类的行为.<br>子类从父类继承属性和方法,你可以重新定义它们,也可以添加新的属性和方法.<br>为了表明子类有父类,把子类写在父类前面,用冒号隔开<br>子类本身也可以被继承  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建子类</span><br><span class="line">class Sky: Earth &#123;   </span><br><span class="line">    var skyColor &#x3D; &quot;白色,蓝色,黑色&quot;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(sky)&#x2F;&#x2F;父类的值</span><br><span class="line">        sky &#x3D; &quot;子类的天空&quot;&#x2F;&#x2F;子类重新赋值</span><br><span class="line">        print(sky)&#x2F;&#x2F;子类的值</span><br><span class="line">        print(skyColor)&#x2F;&#x2F;子类的新属性</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>子类可以重写父类的属性,方法,set和get<br>重写需要在前面加上override关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重写方法</span><br><span class="line">override func seaColor() &#123;</span><br><span class="line">    print(&quot;子类重写父类方法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;重写属性 get</span><br><span class="line">override var flow: String&#123;</span><br><span class="line">    return super.land + &quot;new land&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防止重写"><a href="#防止重写" class="headerlink" title="防止重写"></a>防止重写</h3><p>final关键字修饰方法,属性,子类无法对其进行修改;<br>在类面前final修饰,表示该类不能有子类;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法</span><br><span class="line">final func getSky()&#123;</span><br><span class="line">    print(&quot;get Sky&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类</span><br><span class="line">final class land:Earth&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The End</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列10-属性</title>
      <link href="/2021/04/21/Swift%E7%B3%BB%E5%88%97P10-%E5%B1%9E%E6%80%A7/"/>
      <url>/2021/04/21/Swift%E7%B3%BB%E5%88%97P10-%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性可以将特定的值和类,结构体,枚举联系起来.<br>存储属性会存储常量或变量作为实例的一部分,反之计算属性会计算值(而不是存储值).<br>计算属性可以由类,结构体,枚举进行定义.<br>存储属性只能由结构体和类进行定义.  </p><p>属性可以和类型本身相关联,这种属性就是所谓的类型属性.  </p><p>你可以定义属性观察器来检查属性中值的变化,这样你就可以自定义行为来响应.<br>属性观测器可以添加到你自定义的存储属性中,也可以添加到子类从他父类继承而来的属性中.  </p><a id="more"></a><h3 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h3><p>存储属性是一个特定类和结构体实例的一部分常量或变量;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;结构体属性</span><br><span class="line">struct NewDay &#123;</span><br><span class="line">    var day:Int</span><br><span class="line">    let time:Int</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">var d1 &#x3D; NewDay.init(day: 10, time: 11)</span><br><span class="line">d1.day &#x3D; 20 &#x2F;&#x2F;变量,定义了之后还可以进行修改</span><br><span class="line">&#x2F;&#x2F; d1.time &#x3D; 30   他是一个常量,一经定义不可对其再次进行修改;</span><br></pre></td></tr></table></figure><p>延迟属性(懒加载),使用lazy关键字,在属性使用的时候再进行创建实例,否则不会创建.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lazy var l1:UILabel &#x3D; &#123;</span><br><span class="line">    let l1 &#x3D; UILabel.init()</span><br><span class="line">    l1.frame &#x3D; CGRect(x: 0, y: 0, width: 100, height: 100)</span><br><span class="line">    l1.backgroundColor &#x3D; .black</span><br><span class="line">    self.view.addSubview(l1)</span><br><span class="line">    return l1</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>除了存储属性,类,结构体和枚举也能够定义计算属性,而它实际并不存储值.相反,他们提供一个读取器和一个可选的设置器来间接得到和设置其他的属性和值(set和get方法).  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;计算属性,set和get</span><br><span class="line">var number:Int &#x3D; 0</span><br><span class="line">var allPoint: Int&#123;</span><br><span class="line">    get&#123;</span><br><span class="line">        return number</span><br><span class="line">    &#125;</span><br><span class="line">    set(newOne)&#123;</span><br><span class="line">        number &#x3D; newOne</span><br><span class="line">        print(&quot;赋值 \(number)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;案例1,省略get</span><br><span class="line">var space:Int&#123;</span><br><span class="line">    return 100</span><br><span class="line">&#125;</span><br><span class="line">print(space)</span><br><span class="line">&#x2F;&#x2F;space &#x3D; 200  重新赋值时,会报错</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;案例2</span><br><span class="line">struct Numbers &#123;</span><br><span class="line">    var n1 &#x3D; 10,n2 &#x3D; 20</span><br><span class="line">    var n3:Int&#123;</span><br><span class="line">        return n1 * n2&#x2F;&#x2F;添加常量或者变量去接收</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">var num &#x3D; Numbers.init()</span><br><span class="line">num.n1 &#x3D; 20</span><br><span class="line">num.n2 &#x3D; 20</span><br><span class="line">print(num.n3)</span><br></pre></td></tr></table></figure><h3 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h3><p>全局函数是定义在任何函数,方法,闭包或者类型环境之外的变量.<br>局部变量是定义在函数,方法,或者闭包环境之中的变量.  </p><p>The End</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列9-结构体和类</title>
      <link href="/2021/04/20/Swift%E7%B3%BB%E5%88%97P9-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/"/>
      <url>/2021/04/20/Swift%E7%B3%BB%E5%88%97P9-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>类和结构体是一种多功能且灵活的构造体,是代码构建的基础.  </p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体:使用struct关键字<br>值类型:<br>值类型是一种当他被指定到(常量或变量,或被传递给函数)时会被拷贝的类型;<br>结构体是值类型.<br>枚举,整型,浮点型,字符串,字符,布尔值,字典,数组都是值类型,他们都是以结构体的形式在后台实现的;</p><a id="more"></a><h3 id="结构体一些功能"><a href="#结构体一些功能" class="headerlink" title="结构体一些功能"></a>结构体一些功能</h3><p> 定义属性存储值<br> 定义方法提供功能<br> 允许使用下标语法来访问值<br> 定义初始化器用于初始化状态<br> 可以使用扩展来添加默认没有的功能<br> 遵循协议来针对特定类型提供标准的功能  </p><h3 id="结构体实例"><a href="#结构体实例" class="headerlink" title="结构体实例"></a>结构体实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一般的结构体</span><br><span class="line">struct myStruct &#123;</span><br><span class="line">    var height:CGFloat</span><br><span class="line">    var width:CGFloat</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;默认值结构体</span><br><span class="line">struct man &#123;</span><br><span class="line">    let gender &#x3D; &quot;man&quot;</span><br><span class="line">    let other:Int &#x3D; 100</span><br><span class="line">    </span><br><span class="line">    func name() &#123;</span><br><span class="line">        print(&quot;name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">let s1:myStruct &#x3D; myStruct.init(height: 100.0, width: 100.0)</span><br><span class="line">print(s1.width,s1.height)</span><br><span class="line"> </span><br><span class="line">let m &#x3D; man() &#x2F;&#x2F;实例1</span><br><span class="line">let m1:man &#x3D; man.init() &#x2F;&#x2F;实例2</span><br><span class="line">print(m1.gender,m1.other) &#x2F;&#x2F;通过点语法来访问结构体的属性</span><br><span class="line">m1.name()</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>使用class关键字<br>引用类型:<br>当他被指定到常量或变量,或被传递给函数时不会被拷贝,而是引用他的现存实例;<br>类是引用类型  </p><h3 id="类的一般功能"><a href="#类的一般功能" class="headerlink" title="类的一般功能"></a>类的一般功能</h3><p>定义属性存储值<br>定义方法提供功能<br>允许使用下标语法来访问值<br>定义初始化器用于初始化状态<br>可以使用扩展来添加默认没有的功能<br>遵循协议来针对特定类型提供标准的功能  </p><p>可以继承另外一个类的特征<br>类型转换允许你在运行检查和解释一个类实例的类型<br>反初始化器允许一个类实例释放任何被其所分配的资源<br>引用计数允许不止一个对类实例的引用  </p><h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类</span><br><span class="line">class BaseViewController:UIViewController&#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;实例化类</span><br><span class="line">let ba &#x3D; BaseViewController()</span><br><span class="line">print(ba.arrSource.count)</span><br><span class="line">    </span><br><span class="line">let ba1 &#x3D; BaseViewController()</span><br><span class="line">print(ba1.arrSource.count)</span><br></pre></td></tr></table></figure><h2 id="特征运算符"><a href="#特征运算符" class="headerlink" title="特征运算符"></a>特征运算符</h2><p>因为类是引用类型，在后台有可能有很多常量和变量都是引用到了同一个类的实例.(相同这词对结构体和枚举来说并不是真的相同，因为它们在赋予给常量，变量或者被传递给一个函数时总是被拷贝过去的.)<br>有时候找出两个常量或者变量是否引用自同一个类实例非常有用<br>相同于 ( ===)<br>不相同于( !==)<br>利用这两个恒等运算符来检查两个常量或者变量是否引用相同的实例  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let ba &#x3D; BaseViewController()</span><br><span class="line">print(ba.arrSource.count)</span><br><span class="line">    </span><br><span class="line">let ba1 &#x3D; BaseViewController()</span><br><span class="line">print(ba1.arrSource.count)</span><br><span class="line"></span><br><span class="line">if ba &#x3D;&#x3D;&#x3D; ba1 &#123;</span><br><span class="line">    print(&quot;他们是相同对象的实例&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h2><p>当是单纯的需要保存数据,并且属性不超过五个时,应该选择结构体而非类.<br>其他时候,如有属性和方法时,需要使用到继承,选择类.  </p><p>The End  </p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift结构体和类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列8-枚举</title>
      <link href="/2021/04/20/Swift%E7%B3%BB%E5%88%97P8-%E6%9E%9A%E4%B8%BE/"/>
      <url>/2021/04/20/Swift%E7%B3%BB%E5%88%97P8-%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举可以是任何类型,如整型,浮点型等<br>枚举没有标明类型时,它就是一个新的类型;也就说,定义一个枚举,就是一个新的类型.<br>使用enum关键字进行定义枚举  </p><a id="more"></a><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><h3 id="样式1"><a href="#样式1" class="headerlink" title="样式1"></a>样式1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum SeasonState &#123;</span><br><span class="line">    case spring</span><br><span class="line">    case summer</span><br><span class="line">    case autumn</span><br><span class="line">    case winter</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用switch来匹配枚举</span><br><span class="line">var arr &#x3D; [SeasonState]()</span><br><span class="line">arr &#x3D; [.spring,.summer,.autumn,.winter]</span><br><span class="line">let season:SeasonState &#x3D; arr[Int(arc4random()) % arr.count]</span><br><span class="line">switch season &#123;</span><br><span class="line">case .winter:</span><br><span class="line">    print(&quot;It is winter&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;no case &quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="样式2"><a href="#样式2" class="headerlink" title="样式2"></a>样式2</h3><p>多个值可以在同一行表示,用逗号隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum WeatherState &#123;</span><br><span class="line">    case cold,hot,wind</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="样式3"><a href="#样式3" class="headerlink" title="样式3"></a>样式3</h3><p>遍历枚举:使用CaseIterable关键字修饰可以对枚举进行遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Day:CaseIterable &#123;</span><br><span class="line">    case day1,day2,day3,day4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;遍历</span><br><span class="line">let days &#x3D; Day.allCases</span><br><span class="line">for day in days &#123;</span><br><span class="line">    print(&quot;day: \(day)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="样式4"><a href="#样式4" class="headerlink" title="样式4"></a>样式4</h3><p>原始值,首个枚举赋值1,后面的值会依次递增赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum week :Int&#123;</span><br><span class="line">    case w1 &#x3D; 1,w2,w3,w4,w5,w6,w7</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;w2 &#x3D; 2,以此类推</span><br></pre></td></tr></table></figure><h3 id="样式5"><a href="#样式5" class="headerlink" title="样式5"></a>样式5</h3><p>定义关联值的枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Barcode &#123;</span><br><span class="line">    case upc(Int,Int,Int)</span><br><span class="line">    case qrCode(String)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用关联值枚举,可以在每次生成不同的值</span><br><span class="line">let b1:Barcode &#x3D; Barcode.upc(100, 200, 300);print(b1)</span><br></pre></td></tr></table></figure><p>The End</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列7-闭包</title>
      <link href="/2021/04/19/Swift%E7%B3%BB%E5%88%97P7-%E9%97%AD%E5%8C%85/"/>
      <url>/2021/04/19/Swift%E7%B3%BB%E5%88%97P7-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是可以在你的代码中被传递和引用的功能性独立代码块.<br>闭包又被称为待执行的代码块.<br>有返回值,有形参,使用in关键字,还有@escaping关键字.<br>样式:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;(形参1,形参2,形参3) -&gt;返回值 in  </span><br><span class="line"> 待执行代码  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let b1 &#x3D; &#123;(s1:String) -&gt;Void in</span><br><span class="line">    print(s1)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">b1(&quot;s1&quot;)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h2><h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>作为函数参数,在当前函数进行返回,这时闭包的形参会被作为返回值,书写形参时只要书写对应的类型即可;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;书写类</span><br><span class="line">class Message: NSObject &#123;</span><br><span class="line">func interfaceLogin(_ s1:String,_ pa:Dictionary&lt;String,String&gt;,_ cl:(Dictionary&lt;String,Any&gt;,Int) -&gt;Void) &#123;</span><br><span class="line">    &#x2F;&#x2F;cl表示闭包形参,类型是字典和整型</span><br><span class="line">     cl([&quot;c1&quot;:100],200)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用类</span><br><span class="line">class ClosureView: BaseViewController &#123;</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()</span><br><span class="line">  let msg &#x3D; Message.init()</span><br><span class="line"> &#x2F;&#x2F;作为函数的形参</span><br><span class="line">  msg.interfaceLogin(&quot;s1&quot;, [&quot;1&quot;:&quot;2&quot;]) &#123; (result, code) in</span><br><span class="line">  &#x2F;&#x2F;赋值形参去接收对应的数据</span><br><span class="line">  print(result,code) &#x2F;&#x2F;结果 [&quot;c1&quot;:100],200</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果闭包cl是在函数返回之后调用的,我们就说这个闭包逃逸了,比如异步函数,那么需要补充@escaping关键字修饰,表示这闭包是允许逃逸的;<br>函数在启动任务之后返回,但是闭包要直到任务完成 – 闭包需要逃逸,以便稍后调用.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Message: NSObject &#123;</span><br><span class="line">    func interfaceLogin(_ s1:String,_ pa:Dictionary&lt;String,String&gt;,_ cl: @escaping (Dictionary&lt;String,Any&gt;,Int) -&gt;Void) &#123;</span><br><span class="line">            DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + 2.0) &#123;</span><br><span class="line">                print(&quot;2秒之后执行&quot;)</span><br><span class="line">                cl([&quot;c1&quot;:100],200)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结合typealias使用"><a href="#结合typealias使用" class="headerlink" title="结合typealias使用"></a>结合typealias使用</h3><p>结合typealias来使用的好处是,你不必在函数后面就返回该闭包,而是可以在类的任何地方返回.  </p><h4 id="第一步-定义闭包别名"><a href="#第一步-定义闭包别名" class="headerlink" title="第一步:定义闭包别名"></a>第一步:定义闭包别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typealias mineClosure &#x3D; (URL,Dictionary&lt;String, Any&gt;) -&gt;Void</span><br><span class="line">&#x2F;&#x2F;写形参和返回值时:只需要写对应的类型即可</span><br></pre></td></tr></table></figure><h4 id="第二步-定义闭包变量属性"><a href="#第二步-定义闭包变量属性" class="headerlink" title="第二步:定义闭包变量属性"></a>第二步:定义闭包变量属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var c1:mineClosure?</span><br></pre></td></tr></table></figure><h4 id="第三步-定义触发闭包回调方法"><a href="#第三步-定义触发闭包回调方法" class="headerlink" title="第三步:定义触发闭包回调方法"></a>第三步:定义触发闭包回调方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func getTheMessage(temp:@escaping mineClosure) &#123;</span><br><span class="line">&#x2F;&#x2F;单独作为形参时,需要用@escaping来修饰,表示这个是逃逸闭包:因为他是在函数返回之后调用的;</span><br><span class="line">    self.c1 &#x3D; temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第四步-返回闭包"><a href="#第四步-返回闭包" class="headerlink" title="第四步:返回闭包"></a>第四步:返回闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func begin()&#123;</span><br><span class="line">    if self.c1 !&#x3D; nil &#123;&#x2F;&#x2F;判断是否实现了闭包</span><br><span class="line">        self.c1!(URL.init(string: &quot;gameURL&quot;)!,[&quot;message&quot;:&quot;NO&quot;])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最后-调用"><a href="#最后-调用" class="headerlink" title="最后,调用"></a>最后,调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ClosureView: BaseViewController &#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">       super.viewDidLoad()</span><br><span class="line">let msg &#x3D; Message.init()</span><br><span class="line">msg.getTheMessage &#123; (url, dic) in</span><br><span class="line">    print(url,dic)&#x2F;&#x2F;赋值形参去接收对应的数据</span><br><span class="line">&#125;</span><br><span class="line">msg.begin()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防止闭包循环引用"><a href="#防止闭包循环引用" class="headerlink" title="防止闭包循环引用"></a>防止闭包循环引用</h2><p>在闭包里面的对象会被闭包强引用,所以使用的时候要注意是否会引起循环引用.<br>下面是防止循环引用的解决方案;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方案1,使用weak</span><br><span class="line">weak var weakSelf &#x3D; self</span><br><span class="line">msg.interfaceLogin(&quot;d&quot;, [&quot;d&quot;:&quot;c&quot;]) &#123; (r1, c1) in</span><br><span class="line">    weakSelf?.result &#x3D; r1</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;方案2 [weak self]</span><br><span class="line">msg.interfaceLogin(&quot;come&quot;, [&quot;i&quot;:&quot;j&quot;]) &#123; [weak self](r2, c2) in</span><br><span class="line">    self?.result &#x3D; r2</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;方案3 [unowned self]</span><br><span class="line">msg.interfaceLogin(&quot;come&quot;, [&quot;i&quot;:&quot;j&quot;]) &#123; [unowned self](r2, c2) in</span><br><span class="line">    self.result &#x3D; r2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The end</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列6-函数</title>
      <link href="/2021/04/19/Swift%E7%B3%BB%E5%88%97P6-%E5%87%BD%E6%95%B0/"/>
      <url>/2021/04/19/Swift%E7%B3%BB%E5%88%97P6-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> 函数的定义:<br> 使用关键字func,可以指定一个或者多个参数和一个返回值类型<br> 每个函数都有一个函数名来描述他的功能,通过函数名和对应的参数来调用这个函数,函数传递的参数顺序必须和参数列表相同.<br> 函数传递的实参和形参类型必须一致,-&gt;后定义函数的返回值<br> 如果要重写父类某个方法需要在func关键字前面加override关键字<br> 主要类型有:<br> 1,无参数,无返回值<br> 2,有参数,无返回值<br> 3,有参数,有返回值(元组也可作为返回值,多参数返回值)<br> 4,可变参数(使用… 可以传入多个相同类型的参数),有返回值(无返回值)<br> 5,实例方法和类方法<br> 6,函数既可作为形参也可以作为返回值</p> <a id="more"></a><h3 id="函数一般形式-无参数-无返回值"><a href="#函数一般形式-无参数-无返回值" class="headerlink" title="函数一般形式:无参数,无返回值"></a>函数一般形式:无参数,无返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func addView()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">self.addView()</span><br></pre></td></tr></table></figure><h3 id="函数一般形式-有形参-有返回值"><a href="#函数一般形式-有形参-有返回值" class="headerlink" title="函数一般形式:有形参,有返回值"></a>函数一般形式:有形参,有返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myNumber(number:Int) -&gt; Int &#123;</span><br><span class="line">        return number</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">self.myNumber(number: 10)</span><br></pre></td></tr></table></figure><h3 id="在调用时省略形参-函数写法"><a href="#在调用时省略形参-函数写法" class="headerlink" title="在调用时省略形参 函数写法"></a>在调用时省略形参 函数写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func getName(_ name:String) -&gt; String &#123;</span><br><span class="line">    return name</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">self.getName(&quot;from name&quot;)</span><br></pre></td></tr></table></figure><h3 id="可变形式参数"><a href="#可变形式参数" class="headerlink" title="可变形式参数"></a>可变形式参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func moreNumber(_ numbers: Double...) -&gt; Double &#123;</span><br><span class="line">var total:Double &#x3D; 0</span><br><span class="line">for num in numbers &#123;</span><br><span class="line">    total +&#x3D; num</span><br><span class="line">&#125;</span><br><span class="line">return total</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">self.moreNumber(1.1,2.3,2.3)</span><br></pre></td></tr></table></figure><h3 id="输出输入的形式参数-inout"><a href="#输出输入的形式参数-inout" class="headerlink" title="输出输入的形式参数:inout"></a>输出输入的形式参数:inout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func changeSomething(_ a: inout Int,_ b: inout Int) &#123;</span><br><span class="line">    let tmp &#x3D; a</span><br><span class="line">    a &#x3D; b</span><br><span class="line">    b &#x3D; tmp</span><br><span class="line">    &#x2F;&#x2F;函数内部形参交换值,实参也会被修改</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">var x &#x3D; 10,y &#x3D; 5</span><br><span class="line">changeSomething(&amp;x, &amp;y)&#x2F;&#x2F;修改后的值:x &#x3D; 5,y &#x3D; 10</span><br></pre></td></tr></table></figure><h3 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h3><p>如果函数只有一个单一的语句,函数会隐式返回这个表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func timeNow(_ time:String) -&gt; String &#123;</span><br><span class="line">    &quot;\(time) from now&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">print(timeNow(&quot;2021-3-12-4-25&quot;))</span><br></pre></td></tr></table></figure><h3 id="默认形参的函数"><a href="#默认形参的函数" class="headerlink" title="默认形参的函数"></a>默认形参的函数</h3><p>调用函数时,不需要传递形参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func defaultNumber(number: Int &#x3D; 100) -&gt; Int &#123;</span><br><span class="line">    return number</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">self.defaultNumber() &#x2F;&#x2F;返回值是100</span><br></pre></td></tr></table></figure><h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>使用override修饰func 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;</span><br><span class="line">    tableView.deselectRow(at: indexPath, animated: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多参数返回-元组"><a href="#多参数返回-元组" class="headerlink" title="多参数返回:元组"></a>多参数返回:元组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func minMax(_ number1: Int,_ number2 : Int) -&gt; (min : Int, max:Int) &#123;</span><br><span class="line">if number1 &gt; number2 &#123;</span><br><span class="line">return (number2,number1)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return (number1,number2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let answer &#x3D; self.minMax(10, 20)</span><br><span class="line">print(&quot;min &#x3D; \(answer.min) and max &#x3D; \(answer.max)&quot;)</span><br></pre></td></tr></table></figure><h3 id="可选元组返回"><a href="#可选元组返回" class="headerlink" title="可选元组返回"></a>可选元组返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func other() -&gt; (name:String,age:Int)? &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">self.other() as Any</span><br></pre></td></tr></table></figure><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>在函数前面添加class关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class func getTheTrue()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The end</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列5-控制流</title>
      <link href="/2021/04/19/Swift%E7%B3%BB%E5%88%97P5-%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
      <url>/2021/04/19/Swift%E7%B3%BB%E5%88%97P5-%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="For-in循环"><a href="#For-in循环" class="headerlink" title="For-in循环"></a>For-in循环</h2><p>使用for-in来遍历数据,数组,字典,范围数字,字符串等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;遍历数组</span><br><span class="line">let myArr:Array &#x3D; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;0&quot;]</span><br><span class="line">for (index,item) in myArr.enumerated() &#123;</span><br><span class="line">    print(&quot;\(index)下标的值是\(item)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;遍历区间</span><br><span class="line">for i in 1...5 &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="while循环-Repeat-While"><a href="#while循环-Repeat-While" class="headerlink" title="while循环,Repeat-While"></a>while循环,Repeat-While</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;while循环:循环通过某个单一的条件,当条件为false时,跳出循环</span><br><span class="line">var i &#x3D; 5</span><br><span class="line">while i &lt; 10 &#123;</span><br><span class="line">    i &#x3D; i + 1</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;repeat-while:判断之前,先执行一次代码,然后判断条件,直到条件为false,跳出循环</span><br><span class="line">repeat &#123;</span><br><span class="line">    print(i)</span><br><span class="line">    i &#x3D; i + 1;</span><br><span class="line">&#125;while i &lt; 20</span><br></pre></td></tr></table></figure><h2 id="条件语句-if-switch"><a href="#条件语句-if-switch" class="headerlink" title="条件语句(if,switch)"></a>条件语句(if,switch)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;if:执行单一的if条件,为true才执行里面的语句;false则执行另外一个语句</span><br><span class="line">let a &#x3D; 10</span><br><span class="line">let b &#x3D; arc4random() % 20</span><br><span class="line">if a &gt;&#x3D; b &#123;</span><br><span class="line">    print(&quot;a大于或者等于b&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print(&quot;b大于a&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;多个条件判断时,使用else if</span><br><span class="line">if a &#x3D;&#x3D; b &#123;</span><br><span class="line">    print(&quot;a &#x3D; b&quot;)</span><br><span class="line">&#125;else if(a &gt; b)&#123;</span><br><span class="line">    print(&quot;a &gt; b&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print(&quot;a &lt; b&quot;)</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F;switch:多个条件判断语句,case之后必须至少有一条可执行的语句,否则会编译不过;</span><br><span class="line">let c &#x3D; arc4random() % 50</span><br><span class="line">switch c &#123;</span><br><span class="line">case 12:</span><br><span class="line">    print(&quot;12&quot;)</span><br><span class="line">case 22:</span><br><span class="line">    print(&quot;22&quot;)</span><br><span class="line">case 33:</span><br><span class="line">    print(&quot;33&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;所有条件都没有匹配到&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-break-return-fallthrough"><a href="#continue-break-return-fallthrough" class="headerlink" title="continue,break,return,fallthrough"></a>continue,break,return,fallthrough</h2><p>continue:循环语句中跳出这一次循环(continue后面的语句不会被执行),执行下一次循环  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for g in [1,2,3,4,5,6] &#123;</span><br><span class="line">    print(&quot;before \(g)&quot;) &#x2F;&#x2F;结果:1 2 3 4 5 6 </span><br><span class="line">    if g &#x3D;&#x3D; 2 &#123;</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;当g &#x3D;&#x3D; 2时,不会执行这之后的语句\(g),而是直接执行g &#x3D;&#x3D; 3,4,5,6&quot;)</span><br><span class="line">    print(&quot;after \(g)&quot;) &#x2F;&#x2F;结果:1 3 4 5 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break:循环语句中,跳出整个循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for j in 1...3 &#123;</span><br><span class="line">    print(&quot;before \(j)&quot;) &#x2F;&#x2F; 1,2</span><br><span class="line">    if j &#x3D;&#x3D; 2 &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;before \(j)&quot;) &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;end 不会执行到j &#x3D;&#x3D; 3&quot;)</span><br></pre></td></tr></table></figure><p>return:函数返回,不会再执行后面的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func getOne()&#123;</span><br><span class="line">    print(&quot;before&quot;)</span><br><span class="line">    let i &#x3D; arc4random() % 10</span><br><span class="line">    if i &#x3D;&#x3D; 3 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;after&quot;)&#x2F;&#x2F;当i &#x3D;&#x3D; 3函数已经返回,这句及后面的语句都不会再执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fallthrough:在switch语句中 执行了符合条件的case之后,如果要执行后面一个语句需要用fallthrough来贯穿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let r1 &#x3D; arc4random() % 10</span><br><span class="line">switch r1 &#123;</span><br><span class="line">case 4:</span><br><span class="line">    print(&quot;4&quot;)</span><br><span class="line">    fallthrough</span><br><span class="line">default:</span><br><span class="line">    print(&quot;done&quot;)&#x2F;&#x2F;添加了fallthrough 该语句也会被执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查API的可用性"><a href="#检查API的可用性" class="headerlink" title="检查API的可用性"></a>检查API的可用性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 11, *) &#123;</span><br><span class="line">    &#x2F;&#x2F;API在iOS11之后才可用</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;修饰方法</span><br><span class="line">@available(iOS 13.0, *)</span><br><span class="line">func getName()&#123;</span><br><span class="line">&#x2F;&#x2F;表示该方法iOS13之后才可用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The end</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift控制流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列4-集合</title>
      <link href="/2021/04/19/Swift%E7%B3%BB%E5%88%97P4-%E9%9B%86%E5%90%88/"/>
      <url>/2021/04/19/Swift%E7%B3%BB%E5%88%97P4-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h2><p>如果你创建了一个数组,字典或者合集,并且赋值给一个变量,那么它就是可变的集合,可以添加,移除,修改它的元素来改变集合;<br>如果赋值给一个常量,那么它就是不可变的;</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组:关键字Array 有序的方式来存储相同类型的值,多个相同的值可以在数组不同的地方出现;<br>通过下标来访问数组里面的元素,下标从0开始.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1:Array &#x3D; Array.init(arrayLiteral: &quot;1&quot;,&quot;2&quot;,&quot;3&quot;);print(arr1)&#x2F;&#x2F;初始化一个不可变数组</span><br><span class="line">var arr2:Array &#x3D; [String]()&#x2F;&#x2F;可变数组</span><br><span class="line">arr2.append(&quot;st1&quot;)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var intArr &#x3D; [Int]()&#x2F;&#x2F;创建一个类型为Int的数组</span><br><span class="line">intArr.append(00)&#x2F;&#x2F;给数组添加值</span><br><span class="line">intArr.insert(11, at: 0) &#x2F;&#x2F;插入数据到对应的下标</span><br><span class="line">print(intArr[0]) &#x2F;&#x2F;读取数组对应下标的值</span><br><span class="line">intArr.removeAll();intArr &#x3D; [];&#x2F;&#x2F;这两种方式是等效的,都是移除数组内所有的元素</span><br></pre></td></tr></table></figure><h3 id="使用默认值来创建数组"><a href="#使用默认值来创建数组" class="headerlink" title="使用默认值来创建数组"></a>使用默认值来创建数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr3 &#x3D; Array.init(repeating: 99.0, count: 10);print(arr3)&#x2F;&#x2F;创建Doubule类型数组,同一个数据10个</span><br></pre></td></tr></table></figure><h3 id="数组的合并组成一个新的数组-使用-号"><a href="#数组的合并组成一个新的数组-使用-号" class="headerlink" title="数组的合并组成一个新的数组:使用 + 号"></a>数组的合并组成一个新的数组:使用 + 号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let newArr &#x3D; arr1 + arr2;print(newArr)</span><br></pre></td></tr></table></figure><h3 id="通过数组字面量来创建数组"><a href="#通过数组字面量来创建数组" class="headerlink" title="通过数组字面量来创建数组"></a>通过数组字面量来创建数组</h3><p>数组的简写模式:中括号括起来,元素用(,)隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myArr &#x3D; [1,2,3,4,5,1];print(myArr)&#x2F;&#x2F;整型数组</span><br></pre></td></tr></table></figure><h3 id="访问和修改数组"><a href="#访问和修改数组" class="headerlink" title="访问和修改数组"></a>访问和修改数组</h3><p>通过下标的形式,下标从0开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var allArr &#x3D; [&quot;game&quot;,&quot;day&quot;,&quot;month&quot;,&quot;year&quot;,&quot;computer&quot;,&quot;ture&quot;,&quot;lie&quot;]</span><br><span class="line">let count &#x3D; allArr.count;print(count)&#x2F;&#x2F;数组个数</span><br><span class="line">    </span><br><span class="line">if allArr.isEmpty &#123;</span><br><span class="line">    &#x2F;&#x2F;判断数组元素个数是否为0</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">allArr.append(&quot;tea&quot;)&#x2F;&#x2F;在数组末尾增加一个元素</span><br><span class="line">allArr +&#x3D; [&quot;book&quot;]&#x2F;&#x2F; +&#x3D; 在数组末尾增加一个元素,或者多个</span><br><span class="line">let tea &#x3D; allArr[7];print(tea)&#x2F;&#x2F;获取某个下标的值</span><br><span class="line">allArr[0] &#x3D; &quot;not game&quot;&#x2F;&#x2F;通过下标来修改某个值</span><br><span class="line">allArr[1...3] &#x3D; [&quot;phone&quot;,&quot;milk&quot;]&#x2F;&#x2F;可以替换范围内的值,就算待替换的和替换的值个数不一致</span><br><span class="line">allArr.insert(&quot;desk&quot;, at: 0)&#x2F;&#x2F;通过下标来插入一个元素</span><br><span class="line">allArr.remove(at: 0)&#x2F;&#x2F;通过下标来移除一个元素</span><br><span class="line">allArr.removeLast() &#x2F;&#x2F; 移除最后一个元素</span><br><span class="line">allArr.removeFirst() &#x2F;&#x2F; 移除第一个元素</span><br><span class="line">allArr.removeAll() &#x2F;&#x2F;移除所有元素</span><br></pre></td></tr></table></figure><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只遍历数组的元素</span><br><span class="line">let traverseArr &#x3D; [1,2,3,4,5,6,7,8,9,0]</span><br><span class="line">for i in traverseArr &#123;</span><br><span class="line">    print(&quot;i &#x3D; \(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;遍历元素和对应的下标:enumerated()</span><br><span class="line">for (index,item) in traverseArr.enumerated() &#123;</span><br><span class="line">    print(&quot;第 \(index) 个元素是 \(item)&quot;)&#x2F;&#x2F;第一个是下标,第二个是对应的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>关键字Dictionary,字典存储无序的相互关联的同一类型的键和同一类型的值的集合,你需要通过键来获取对应的值,键不能相同,值可以相同;</p><h3 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var newDic:Dictionary &#x3D; [Int:Int]()</span><br><span class="line">newDic[11] &#x3D; 22 &#x2F;&#x2F;添加值,key &#x3D; 11,value &#x3D; 22</span><br></pre></td></tr></table></figure><h3 id="声明一个字典-并标明类型"><a href="#声明一个字典-并标明类型" class="headerlink" title="声明一个字典,并标明类型"></a>声明一个字典,并标明类型</h3><p>标明该字典键和值的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myDic:Dictionary&lt;String,String&gt;?</span><br></pre></td></tr></table></figure><h3 id="字典简写-Key-Value"><a href="#字典简写-Key-Value" class="headerlink" title="字典简写[Key:Value]"></a>字典简写[Key:Value]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dic &#x3D; [&quot;user&quot;:54212,&quot;pwd&quot;:123456];print(dic)</span><br></pre></td></tr></table></figure><h3 id="访问和修改可变字典"><a href="#访问和修改可变字典" class="headerlink" title="访问和修改可变字典"></a>访问和修改可变字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var timeDic &#x3D; [&quot;year&quot;:&quot;2021年&quot;,&quot;month&quot;:&quot;3月&quot;,&quot;day&quot;:&quot;11号&quot;]</span><br><span class="line">let dicCount &#x3D; timeDic.count;print(dicCount)&#x2F;&#x2F;读取字典有多少对元素</span><br><span class="line">if timeDic.isEmpty &#123;</span><br><span class="line">    &#x2F;&#x2F;检查字典是否为空</span><br><span class="line">&#125;</span><br><span class="line">timeDic[&quot;min&quot;] &#x3D; &quot;06&quot;&#x2F;&#x2F;使用正确新键类型,来添加新的元素</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新某个值:key存在时,返回旧值(检验是否更新成功);key不存在时,新添加一组数据,返回nil;所以这个方法返回的值是一个可选项</span><br><span class="line">timeDic.updateValue(&quot;18&quot;, forKey: &quot;min&quot;)</span><br><span class="line">if let oldValue &#x3D;  timeDic.updateValue(&quot;21&quot;, forKey: &quot;min&quot;)&#123;</span><br><span class="line">    print(oldValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除键值对"><a href="#移除键值对" class="headerlink" title="移除键值对"></a>移除键值对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;移除某个键值对</span><br><span class="line">timeDic[&quot;min&quot;] &#x3D; nil&#x2F;&#x2F;通过赋值nil来移除某个值</span><br><span class="line">&#x2F;&#x2F;移除某个键值对,存在时返回旧值,不存在时返回nil</span><br><span class="line">timeDic.removeValue(forKey: &quot;day&quot;)</span><br></pre></td></tr></table></figure><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (key,value) in timeDic &#123;</span><br><span class="line">    print(&quot;\(key) : \(value)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合集"><a href="#合集" class="headerlink" title="合集"></a>合集</h2><p>合集:关键字Set,是一个无序的不会有重复元素的集合;  </p><h3 id="创建一个空的合集"><a href="#创建一个空的合集" class="headerlink" title="创建一个空的合集"></a>创建一个空的合集</h3><p>创建一个空的合集时,需要标明Set关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var newSet:Set &#x3D; Set&lt;String&gt;()</span><br><span class="line">newSet.insert(&quot;90&quot;)</span><br></pre></td></tr></table></figure><h3 id="使用字面量创建合集"><a href="#使用字面量创建合集" class="headerlink" title="使用字面量创建合集"></a>使用字面量创建合集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mySet:Set &#x3D; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;];print(mySet)</span><br></pre></td></tr></table></figure><h3 id="访问和修改合集"><a href="#访问和修改合集" class="headerlink" title="访问和修改合集"></a>访问和修改合集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newSet.insert(&quot;91&quot;)&#x2F;&#x2F;插入一个元素</span><br><span class="line">print(&quot;合集元素个数:\(newSet.count)&quot;)&#x2F;&#x2F;合集元素个数</span><br><span class="line">if newSet.isEmpty &#123;</span><br><span class="line">    &#x2F;&#x2F;判断合集是否为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除一个值"><a href="#移除一个值" class="headerlink" title="移除一个值"></a>移除一个值</h3><p>移除一个值,如果存在则返回移除的值;不存在则返回nil</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let removeValue &#x3D; newSet.remove(&quot;1&quot;);print(removeValue as Any)</span><br></pre></td></tr></table></figure><h3 id="判断是否包含某个值"><a href="#判断是否包含某个值" class="headerlink" title="判断是否包含某个值"></a>判断是否包含某个值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if newSet.contains(&quot;2&quot;) &#123;</span><br><span class="line">    print(&quot;合集包含字符串 2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历合集"><a href="#遍历合集" class="headerlink" title="遍历合集"></a>遍历合集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in mySet &#123;</span><br><span class="line">    print(&quot;every item : \(item)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行合集操作"><a href="#执行合集操作" class="headerlink" title="执行合集操作"></a>执行合集操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set1:Set &#x3D; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]</span><br><span class="line">let set2:Set &#x3D; [&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;4&quot;,&quot;5&quot;]</span><br><span class="line">    </span><br><span class="line">print(set1.intersection(set2))&#x2F;&#x2F;创建一个新的合集包含2个合集的共有值;[&quot;4&quot;,&quot;5&quot;]</span><br><span class="line">print(set1.symmetricDifference(set2))&#x2F;&#x2F;创建新合集,set1和set2都包含但是不是共有的值;[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;]</span><br><span class="line">print(set1.union(set2))&#x2F;&#x2F;新合集,包含set1和set2;[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;]</span><br><span class="line">print(set1.subtracting(set2))&#x2F;&#x2F;新合集,set1不包含set2中共有的部分;[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span><br></pre></td></tr></table></figure><h3 id="合集成员关系和相等性"><a href="#合集成员关系和相等性" class="headerlink" title="合集成员关系和相等性"></a>合集成员关系和相等性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;判断它们是否相等</span><br><span class="line">if set1 &#x3D;&#x3D; set2 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断set1所有值是否被set2包含</span><br><span class="line">if set1.isSubset(of: set2) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断set1是否包含set2所有值</span><br><span class="line">if set1.isSuperset(of: set2) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断set1和set2是否拥有完全不同的值</span><br><span class="line">if set1.isDisjoint(with: set2) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断set1是否是set2的子集或者超集,但并不相等</span><br><span class="line">if set1.isStrictSubset(of: set2) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">if set1.isStrictSuperset(of: set2) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The end</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列3-字符和字符串</title>
      <link href="/2021/04/14/Swift%E7%B3%BB%E5%88%97P3-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/04/14/Swift%E7%B3%BB%E5%88%97P3-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><p>字符:单一的字符字符串字面量,用””表示;<br>Character关键字,只能放置一个字符,放置多个字符时,编译器会报错;<br>书写字符时,标明当前类型,不然会默认是字符串;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let c1:Character &#x3D; &quot;a&quot;;print(c1) &#x2F;&#x2F;a</span><br><span class="line">var c2:Character &#x3D; &quot;b&quot;;c2 &#x3D; &quot;d&quot;;print(c2) &#x2F;&#x2F;d</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串:一系列的字符拼接而成;<br>关键字:String<br>使用””来表示字符串;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;字符串</span><br><span class="line">let str1 &#x3D; &quot;abcde&quot;;print(str1)</span><br><span class="line">&#x2F;&#x2F;for循环,输出每一个独立的Character值</span><br><span class="line">for c in str1 &#123;</span><br><span class="line">    print(&quot;str1每一个字节是:\(c)&quot;) &#x2F;&#x2F;a b c d e</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;通过都是字节的数组来组成字符串</span><br><span class="line">let arr:[Character] &#x3D; [&quot;z&quot;,&quot;s&quot;,&quot;j&quot;,&quot;几&quot;]</span><br><span class="line">let ss &#x3D; String(arr);print(ss) &#x2F;&#x2F;zsj几</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="初始化字符串"><a href="#初始化字符串" class="headerlink" title="初始化字符串"></a>初始化字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化空字符串</span><br><span class="line">var new1 &#x3D; &quot;&quot;</span><br><span class="line">var new2:Sting?</span><br><span class="line">&#x2F;&#x2F;字符串常量</span><br><span class="line">let new3 &#x3D; &quot;这是一个字符串&quot;</span><br><span class="line">&#x2F;&#x2F;字符串变量</span><br><span class="line">var new4 &#x3D; &quot;新的字符串&quot;</span><br></pre></td></tr></table></figure><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let strCount &#x3D; &quot;string&quot;;print(&quot;字符串的个数是\(strCount.count)&quot;)</span><br></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>字符串的比较:相等 == ,不相等 != </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if a1 &#x3D;&#x3D; a2 &#123;</span><br><span class="line">    print(&quot;字符串相等&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if a1 !&#x3D; a2 &#123;</span><br><span class="line">    print(&quot;字符串不相等&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>字符串插值\():字符串插值是一种混合常量,变量,字面量,和表达式的字符串字面量构造的新字符串;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var v1 &#x3D; &quot;hello&quot;</span><br><span class="line">v1.append(&quot;world&quot;)&#x2F;&#x2F;append方法 helloworld</span><br><span class="line">v1 &#x3D; v1 + &quot;!!&quot; &#x2F;&#x2F;使用符号: +  helloworld!!</span><br><span class="line">v1 &#x3D; &quot;hi \(v1)&quot; &#x2F;&#x2F;字符串插值的方式 hi helloworld!!</span><br></pre></td></tr></table></figure><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let int1:Int &#x3D; 10</span><br><span class="line">let flo1:Float &#x3D; 10.11</span><br><span class="line">let _ &#x3D; String(int1)  &#x2F;&#x2F; 整型转字符串</span><br><span class="line">let _ &#x3D; String(flo1) &#x2F;&#x2F;浮点型转字符串</span><br><span class="line">let l1 &#x3D; String(format: &quot;小数截取%.2f&quot;, 9.9999);print(l1) &#x2F;&#x2F;浮点型获取精度</span><br><span class="line">let l2 &#x3D; String(format: &quot;game %@&quot;, &quot;over&quot;);print(l2) &#x2F;&#x2F;字符串拼接格式化</span><br><span class="line">let l3 &#x3D; String(format: &quot;课程%d&quot;, 1);print(l3) &#x2F;&#x2F;整型拼接</span><br><span class="line">let l4 &#x3D; String(format: &quot;价格%f&quot;, 9.099);print(l4) &#x2F;&#x2F;浮点型拼接</span><br></pre></td></tr></table></figure><h2 id="判断字符串是否为空"><a href="#判断字符串是否为空" class="headerlink" title="判断字符串是否为空"></a>判断字符串是否为空</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let em1 &#x3D; &quot;not empty&quot;</span><br><span class="line">let em2 &#x3D; &quot;&quot;</span><br><span class="line">print(em1.isEmpty)&#x2F;&#x2F;false</span><br><span class="line">print(em2.isEmpty)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let q1 &#x3D; &quot;what is people?&quot;</span><br><span class="line">for c in q1 &#123;</span><br><span class="line">    print(c)&#x2F;&#x2F;w h a t  i s  p e o p l e ?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取首个字符"><a href="#获取首个字符" class="headerlink" title="获取首个字符"></a>获取首个字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var newString &#x3D; &quot;newString&quot;</span><br><span class="line">print(newString[newString.startIndex])&#x2F;&#x2F;获取首个字符:n</span><br></pre></td></tr></table></figure><h2 id="删除首个字符"><a href="#删除首个字符" class="headerlink" title="删除首个字符"></a>删除首个字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(newString.removeFirst())&#x2F;&#x2F;ewString</span><br></pre></td></tr></table></figure><h2 id="删除最后一个字符"><a href="#删除最后一个字符" class="headerlink" title="删除最后一个字符"></a>删除最后一个字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(newString.removeLast())&#x2F;&#x2F;ewStrin</span><br></pre></td></tr></table></figure><h2 id="删除指定位置"><a href="#删除指定位置" class="headerlink" title="删除指定位置"></a>删除指定位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var AB &#x3D; &quot;ABCDEFG&quot;</span><br><span class="line">AB.remove(at: AB.index(AB.startIndex, offsetBy: 2))&#x2F;&#x2F;结果:ABDEFG</span><br></pre></td></tr></table></figure><h2 id="删除所有内容"><a href="#删除所有内容" class="headerlink" title="删除所有内容"></a>删除所有内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB.removeAll() &#x2F;&#x2F;字符串会变成空nil</span><br></pre></td></tr></table></figure><h2 id="删除头尾指定位数内容"><a href="#删除头尾指定位数内容" class="headerlink" title="删除头尾指定位数内容"></a>删除头尾指定位数内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var g1 &#x3D; &quot;ABCDEF&quot;</span><br><span class="line">g1.removeFirst(2)&#x2F;&#x2F;CDEF</span><br><span class="line">g1.removeLast(2)&#x2F;&#x2F;CD</span><br></pre></td></tr></table></figure><h2 id="判断字符串是否包含另外一个字符串"><a href="#判断字符串是否包含另外一个字符串" class="headerlink" title="判断字符串是否包含另外一个字符串"></a>判断字符串是否包含另外一个字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let con1 &#x3D; &quot;hello&quot;</span><br><span class="line">let con2 &#x3D; &quot;hello world&quot;</span><br><span class="line">print(con2.contains(con1))&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h2 id="字符串分割为数组"><a href="#字符串分割为数组" class="headerlink" title="字符串分割为数组"></a>字符串分割为数组</h2><p>需要使用特定的字符或者字符串进行分割</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let myStr &#x3D; &quot;game,over!&quot;</span><br><span class="line">let arr1 &#x3D; myStr.split(separator: &quot;,&quot;) &#x2F;&#x2F;使用字符,进行分割,分割结果是一个数组</span><br><span class="line">print(arr1) &#x2F;&#x2F;[&quot;game&quot;,&quot;over!&quot;]</span><br></pre></td></tr></table></figure><h2 id="数组拼接为字符串"><a href="#数组拼接为字符串" class="headerlink" title="数组拼接为字符串"></a>数组拼接为字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(arr1.joined()) &#x2F;&#x2F; &quot;gameover!&quot;</span><br><span class="line">print(arr1.joined(separator: &quot;---&quot;)) &#x2F;&#x2F; &quot;game---over!&quot;   ,元素之间插入字符串</span><br></pre></td></tr></table></figure><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><h3 id="头部截取"><a href="#头部截取" class="headerlink" title="头部截取"></a>头部截取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let subStr &#x3D; &quot;abcdefghijk&quot;</span><br><span class="line">print(subStr.prefix(2)) &#x2F;&#x2F;ab</span><br></pre></td></tr></table></figure><h3 id="尾部截取"><a href="#尾部截取" class="headerlink" title="尾部截取"></a>尾部截取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(subStr.suffix(2)) &#x2F;&#x2F;jk</span><br></pre></td></tr></table></figure><h3 id="range截取"><a href="#range截取" class="headerlink" title="range截取"></a>range截取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let index1 &#x3D; subStr.index(subStr.startIndex, offsetBy: 3)</span><br><span class="line">let index2 &#x3D; subStr.index(subStr.startIndex, offsetBy: 5)</span><br><span class="line">let sob &#x3D; subStr[index1...index2]</span><br><span class="line">print(sob) &#x2F;&#x2F;def  包含下标3和下标5</span><br></pre></td></tr></table></figure><h3 id="指定位置截取"><a href="#指定位置截取" class="headerlink" title="指定位置截取"></a>指定位置截取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let r1 &#x3D; subStr.range(of: &quot;fg&quot;)!</span><br><span class="line">print(subStr[subStr.startIndex..&lt;r1.lowerBound]) &#x2F;&#x2F;截取到fg之前,不包含fg:abcde</span><br><span class="line">print(subStr[subStr.startIndex..&lt;r1.upperBound]) &#x2F;&#x2F;截取到fg,包含fg:abcdefg</span><br></pre></td></tr></table></figure><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var re1 &#x3D; &quot;comgaga.com&quot;</span><br><span class="line">re1 &#x3D; re1.replacingOccurrences(of: &quot;ga&quot;, with: &quot;&quot;) &#x2F;&#x2F;com.com</span><br></pre></td></tr></table></figure><h2 id="字符串插入"><a href="#字符串插入" class="headerlink" title="字符串插入"></a>字符串插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var insert1 &#x3D; &quot;ABCD&quot;</span><br><span class="line">&#x2F;&#x2F;单个字符</span><br><span class="line">insert1.insert(&quot;E&quot;, at:insert1.index(insert1.startIndex, offsetBy: 3))</span><br><span class="line">print(insert1) &#x2F;&#x2F;ABCED</span><br><span class="line">&#x2F;&#x2F;多个字符</span><br><span class="line">insert1.insert(contentsOf: &quot;9990&quot;, at: insert1.index(before: insert1.endIndex))</span><br><span class="line">print(insert1) &#x2F;&#x2F;ABCE9990D</span><br></pre></td></tr></table></figure><h2 id="字符串删除某段内容"><a href="#字符串删除某段内容" class="headerlink" title="字符串删除某段内容"></a>字符串删除某段内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var lessStr &#x3D; &quot;ABCDEFG&quot;</span><br><span class="line">let star &#x3D; lessStr.index(lessStr.startIndex, offsetBy: 3)</span><br><span class="line">let end &#x3D; lessStr.index(lessStr.endIndex, offsetBy: -2)</span><br><span class="line">lessStr.removeSubrange(star...end)</span><br><span class="line">print(lessStr) &#x2F;&#x2F;ABCG</span><br></pre></td></tr></table></figure><h2 id="字符串全部小写或大写"><a href="#字符串全部小写或大写" class="headerlink" title="字符串全部小写或大写"></a>字符串全部小写或大写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let up1 &#x3D; &quot;QeRrDaDASdasdAa&quot;</span><br><span class="line">print(up1.lowercased()) &#x2F;&#x2F;qerrdadasdasdaa</span><br><span class="line">print(up1.uppercased()) &#x2F;&#x2F;QERRDADASDASDAA</span><br></pre></td></tr></table></figure><p>The end</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列2-运算符</title>
      <link href="/2021/04/14/Swift%E7%B3%BB%E5%88%97P2-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2021/04/14/Swift%E7%B3%BB%E5%88%97P2-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符专门用语"><a href="#运算符专门用语" class="headerlink" title="运算符专门用语"></a>运算符专门用语</h2><blockquote><p>一元运算符,二元运算符,三元运算符  </p></blockquote><p>一元运算符:只对一个目标进行操作,如a,-a,!a等<br>二元运算符:对两个目标进行操作,如 2 + 3<br>三元运算符:对三个目标进行操作,Swift仅有一个三元运算符(a ? b : c),a是一个判断真假的语句,如果是真,返回a,假则返回b.(是if else 语句的缩写,后面会讲到)  </p><a id="more"></a><h2 id="赋值运算符-算数运算符-取余"><a href="#赋值运算符-算数运算符-取余" class="headerlink" title="赋值运算符,算数运算符,取余"></a>赋值运算符,算数运算符,取余</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符: ="></a>赋值运算符: =</h3><p>把右边的值赋值给左边的变量或者常量,当然左边的常量或者变量的数据类型要和右边的一致.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let gender &#x3D; 1;print(gender)&#x2F;&#x2F;把右边1赋值给左边的常量gender</span><br><span class="line">let lable &#x3D; UILabel.init();lable.backgroundColor &#x3D; .white</span><br><span class="line">let newLabel &#x3D; lable;newLabel.text &#x3D; &quot;把一个UILabel赋值给一个新的UILabel常量&quot;</span><br></pre></td></tr></table></figure><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符: + - * /"></a>算术运算符: + - * /</h3><p>对基本数据类型进行算数运算:加,减,乘以,除以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1 + 2;print(a)&#x2F;&#x2F;加 字符串,集合类,都可以使用 + 号进行操作</span><br><span class="line">let b &#x3D; 20 - 1;print(b)&#x2F;&#x2F;减</span><br><span class="line">let c &#x3D; 5 * 23;print(c)&#x2F;&#x2F;乘</span><br><span class="line">let d &#x3D; 5 &#x2F; 2;print(d)&#x2F;&#x2F;等于2,除以会获取到一个整数;</span><br></pre></td></tr></table></figure><h3 id="取余"><a href="#取余" class="headerlink" title="取余: %"></a>取余: %</h3><p>对整型Int类型进行运算,结果取整型.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let e &#x3D; 7 &#x2F; 2;print(e)&#x2F;&#x2F;等于1,取整数</span><br></pre></td></tr></table></figure><h2 id="一元减号运算符-一元加号运算符-组合赋值符号"><a href="#一元减号运算符-一元加号运算符-组合赋值符号" class="headerlink" title="一元减号运算符,一元加号运算符,组合赋值符号"></a>一元减号运算符,一元加号运算符,组合赋值符号</h2><h3 id="一元减号运算符"><a href="#一元减号运算符" class="headerlink" title="一元减号运算符"></a>一元减号运算符</h3><p>正数变为负数,负数变为正数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var e1 &#x3D; 10;e1 &#x3D; -e1;print(e1)</span><br></pre></td></tr></table></figure><h3 id="一元加号运算符"><a href="#一元加号运算符" class="headerlink" title="一元加号运算符"></a>一元加号运算符</h3><p>不会对值产生影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var e2 &#x3D; 2;e2 &#x3D; +e2;print(e2)</span><br></pre></td></tr></table></figure><h3 id="组合赋值符号"><a href="#组合赋值符号" class="headerlink" title="组合赋值符号"></a>组合赋值符号</h3><p>包含: += 和 -= ,本身加上或者减去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var g1 &#x3D; 3;g1 +&#x3D; 10;print(g1)&#x2F;&#x2F;g1 &#x3D; g1 + 10</span><br><span class="line">g1 -&#x3D; 1;print(g1)&#x2F;&#x2F;g1 &#x3D; g1 - 1</span><br></pre></td></tr></table></figure><h2 id="比较运算符-三元条件运算符"><a href="#比较运算符-三元条件运算符" class="headerlink" title="比较运算符,三元条件运算符"></a>比较运算符,三元条件运算符</h2><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较结果返回true或者false 如a &gt; b,a &lt; b,a == b,a &gt;= b,a &lt;= b,a != b<br>元组也可以进行比较,每一个元素逐一比较(对应的元素必须是用一类型)<br>常用于控制流if  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let f1 &#x3D; 21</span><br><span class="line">let f2 &#x3D; arc4random() % 33 + 10;</span><br><span class="line">if f1 &gt; f2 &#123;</span><br><span class="line">    print(&quot;f1 大于 f2&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print(&quot;f1 不大于 f2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符"></a>三元条件运算符</h3><p>question?answer1:answer2,question为真,返回answer1,否则返回answer2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let maxNumber:Int &#x3D; Int(f1 &gt; f2 ? UInt32(f1) : f2)</span><br><span class="line">print(maxNumber)</span><br><span class="line">&#x2F;&#x2F;其实就是如下写法</span><br><span class="line">if f1 &gt; f2 &#123;</span><br><span class="line">    print(&quot;show f1 &#x3D; \(f1)&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print(&quot;show f2 &#x3D; \(f2)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并空值运算符-区间运算符"><a href="#合并空值运算符-区间运算符" class="headerlink" title="合并空值运算符(??),区间运算符"></a>合并空值运算符(??),区间运算符</h2><h3 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符(??)"></a>合并空值运算符(??)</h3><p>a ?? b,a有值就返回a,a如果为nil,则返回b,a必须是可选类型,并且b和a一定是同一个类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let count &#x3D; 10111</span><br><span class="line">var newCount:Int?&#x2F;&#x2F;默认是nil</span><br><span class="line">let get &#x3D; newCount ?? count;print(get)</span><br><span class="line">newCount &#x3D; get</span><br></pre></td></tr></table></figure><h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><h4 id="闭区间运算符"><a href="#闭区间运算符" class="headerlink" title="闭区间运算符"></a>闭区间运算符</h4><p>包含头尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 1...6 &#123;</span><br><span class="line">    print(&quot;i &#x3D; \(i)&quot;)&#x2F;&#x2F;包含1和6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h4><p>只有右边半开区间,没有左边半开区间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..&lt;6 &#123;&#x2F;&#x2F;注意是2个(.)加上&lt;</span><br><span class="line">    print(&quot;i &#x3D; \(i)&quot;)&#x2F;&#x2F;不包含6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组相关的区间运算符"><a href="#数组相关的区间运算符" class="headerlink" title="数组相关的区间运算符"></a>数组相关的区间运算符</h3><h4 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;]</span><br><span class="line">for item in arr[2...] &#123;</span><br><span class="line">    print(&quot;下标2之后的值,含有2:\(item)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="半开单侧区间"><a href="#半开单侧区间" class="headerlink" title="半开单侧区间"></a>半开单侧区间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for item in arr[..&lt;5] &#123;</span><br><span class="line">    print(&quot;下标5之前的值,不含有5:\(item)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;检测区间是否含有特定的值</span><br><span class="line">let range &#x3D; ...6</span><br><span class="line">let r1 &#x3D; range.contains(3)&#x2F;&#x2F;true</span><br><span class="line">let r2 &#x3D; range.contains(-1)&#x2F;&#x2F;true</span><br><span class="line">let r3 &#x3D; range.contains(7)&#x2F;&#x2F;false</span><br><span class="line">print(r1,r2,r3)</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>非(!a),与(a &amp;&amp; b),或(a || b)<br>用来判断是真还是假</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let add &#x3D; true,less &#x3D; false</span><br><span class="line">&#x2F;&#x2F; 非!,把真变成假,把假变为真</span><br><span class="line">if !add &#x3D;&#x3D; false&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 与&amp;&amp;,都是真才为真,有一个是假,就是假</span><br><span class="line">if add &amp;&amp; less &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 或||,有一个为真就是真,2个都是假才是假</span><br><span class="line">if add || less &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有多个逻辑运算符,需要区分优先级时,可以使用()来确定优先执行的顺序;</span><br><span class="line">if (add || less) || less &amp;&amp; add &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift系列1-基础内容</title>
      <link href="/2021/04/13/Swift%E7%B3%BB%E5%88%97P1-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
      <url>/2021/04/13/Swift%E7%B3%BB%E5%88%97P1-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><p> 常量,let关键字;变量,var关键字<br> 常量和变量:把名字和特定类型的值关联起来;<br> 常量:定义的时候赋值,一经设置不可被修改;<br> 变量:可以先定义后赋值,或者定义的时候赋值,设置了之后可以再次修改,赋予新值;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例子示范</span><br><span class="line">let a:Int &#x3D; 100;print(a)&#x2F;&#x2F;定义了一个类型为整型的常量a,如果你尝试去修改a,Xcode会报错;</span><br><span class="line">var b:CGFloat &#x3D; 1.1;print(b)&#x2F;&#x2F;定义了一个类型为浮点型的变量b;</span><br><span class="line">b &#x3D; 2.2;print(b)&#x2F;&#x2F;可以对变量重新进行赋值</span><br></pre></td></tr></table></figure><p>定义多个相同类型的常量或者变量,使用(,)隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a1:Int &#x3D; 2,a2 &#x3D; 3,a3 &#x3D; 33;print(a1,a2,a3)</span><br><span class="line">var b1:CGFloat &#x3D; 2.1,b2 &#x3D; 3.1,b3 &#x3D; 3.22;print(b1,b2,b3); b1 &#x3D; 2.2;b2 &#x3D; 3.2;b3 &#x3D; 3.32</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="类型标注-类型安全和类型推断"><a href="#类型标注-类型安全和类型推断" class="headerlink" title="类型标注,类型安全和类型推断"></a>类型标注,类型安全和类型推断</h2><h3 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h3><p>类型标注:初始化的时候定义该常量或变量是什么类型的就赋值什么类型;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let name:String &#x3D; &quot;mark&quot;;print(name) &#x2F;&#x2F;定义了一个常量name,类型为String</span><br><span class="line">var time:Int;time &#x3D; 1;print(time) &#x2F;&#x2F;先定义类型,后赋值</span><br><span class="line">var arr &#x3D; [Any]();arr &#x3D; [&quot;1&quot;,&quot;2&quot;];print(arr)&#x2F;&#x2F;定义一个类型为Any的数组,里面可以放着任意类型,包括对象类型</span><br></pre></td></tr></table></figure><h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><p> Swift是一门类型安全的语言,类型安全的语言让你知道代码可以处理值的类型,如一段代码你期望获得String类型,就不能赋值Int类型.<br> 类型安全在编译期就会报错,指出哪里的类型不符合对应的要求,可以帮助你在开发阶段更早的发现并修复错误;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var age:Int &#x3D; 12;</span><br><span class="line">&#x2F;&#x2F;age &#x3D; 11.2;如果这样赋值Double类型就会报错</span><br><span class="line">age &#x3D; 16;print(age)&#x2F;&#x2F;正确的赋值</span><br></pre></td></tr></table></figure><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>当你在初始化变量或者常量时,如果没有标注当前值的类型,Swift会帮你推断出当前变量或者常量的类型;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let gender &#x3D; 1;print(gender)&#x2F;&#x2F;整型Int</span><br><span class="line">let p1 &#x3D; 1.1;print(p1)&#x2F;&#x2F;会推断Double而非Float或CGFloat</span><br><span class="line">let p2 &#x3D; 2 + 2.22;print(p2)&#x2F;&#x2F;整型和浮点型相加,会推断出Double类型</span><br><span class="line">let firstName &#x3D; &quot;zu&quot;;print(firstName)&#x2F;&#x2F;字符串String</span><br><span class="line">var lable &#x3D; UILabel();lable &#x3D; UILabel.init();print(lable.text as Any)&#x2F;&#x2F;UILabel类</span><br></pre></td></tr></table></figure><h2 id="注释-分号"><a href="#注释-分号" class="headerlink" title="注释,分号"></a>注释,分号</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>编译器会忽略注释里面的语句<br>两条斜杠表示(//)单行注释<br>多行注释(/* */)  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;单行注释</span><br><span class="line">&#x2F;*</span><br><span class="line"> 多行注释</span><br><span class="line"> 11111</span><br><span class="line"> &#x2F;*</span><br><span class="line"> 套嵌注释</span><br><span class="line"> *&#x2F;</span><br><span class="line"> 22222</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="分号"><a href="#分号" class="headerlink" title="分号(;)"></a>分号(;)</h3><p>Swift语句不要求每一段代码结束后都要分号,当然你写也不会有问题;但同一行多个语句一定要用分号隔开;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let f1 &#x3D; 19;print(f1)&#x2F;&#x2F;这是两个语句,需要(;)隔开</span><br></pre></td></tr></table></figure><h2 id="整型-浮点型-布尔值-元组"><a href="#整型-浮点型-布尔值-元组" class="headerlink" title="整型,浮点型,布尔值,元组"></a>整型,浮点型,布尔值,元组</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>Int关键字,整型就是没有小数的数字,如12,-23;整型可以是有符号(正,零或者负),也可以是无符号的(正数,零);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let i1:Int &#x3D; 123,i2 &#x3D; 0,i3 &#x3D; -33;print(i1,i2,i3)&#x2F;&#x2F;有符号的</span><br><span class="line">let ui1:UInt &#x3D; 123;print(ui1)&#x2F;&#x2F;无符号的</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型:Double,CGFloat,Float,有小数的数字;Double 64位机器,Float 32位机器,CGFloat 兼容64位和32位机器;<br>推荐使用CGFloat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let c1:CGFloat &#x3D; 2.22;print(c1)&#x2F;&#x2F;浮点型</span><br></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值:Bool关键字,true表示真,false表示假;不能使用1或者0来表示真假</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let t1:Bool &#x3D; true;print(&quot;布尔值 &#x3D; \(t1)&quot;)</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组:多个值合并成单一的复合型的值,元组内的值可以是任何类型的值,不需要是同一个类型;<br>使用括号()来表示元组.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let y1 &#x3D; (&quot;age&quot;,30);print(y1.0,y1.1)&#x2F;&#x2F;一个类型为(String,Int)的元组,通过下标来访问它的值,下标从0开始</span><br><span class="line">let y2:(f:CGFloat,i:Int) &#x3D; (1.11,2);print(y2.f,y2.i)&#x2F;&#x2F;声明的时候给每一个元素命名,可以通过命名来查找</span><br><span class="line">let y3:(_:String,j:String) &#x3D; (&quot;2&quot;,&quot;3&quot;);print(y3.j)&#x2F;&#x2F;当你不需要使用元组中某个数据时,可以使用_来处理</span><br></pre></td></tr></table></figure><h2 id="数值类型转换-类型别名-可选项"><a href="#数值类型转换-类型别名-可选项" class="headerlink" title="数值类型转换,类型别名,可选项"></a>数值类型转换,类型别名,可选项</h2><h3 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h3><p>整型浮点型相互转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let o1 &#x3D; 2;let o2 &#x3D; CGFloat(o1);print(o1,o2)&#x2F;&#x2F;整型转浮点型</span><br><span class="line">let o3 &#x3D; 2.33;let o4 &#x3D; Int(o3);print(o3,o4)&#x2F;&#x2F;浮点型转整型,会截取小数点前面的值</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名:typealias关键字,就是数据类型起另外一个自定义的名字,使用的时候,实际还是那个数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias FFINT &#x3D; Int;let new:FFINT &#x3D; 10;print(new)&#x2F;&#x2F;FFINT还是Int类型,只是对Int赋予了一个FFINT的别名</span><br></pre></td></tr></table></figure><h3 id="可选项"><a href="#可选项" class="headerlink" title="可选项(?)"></a>可选项(?)</h3><p>可选项(?):可以利用可选项来处理值缺失的情况.<br>必须是变量并且不赋值时等于nil.<br>可选意味着:这里有一个值,它等于x或者这里根本没有值它为nil;<br>nil:你可以将可选变量赋值为nil,表示为没有值;<br>注意:nil不能用于非可选常量或变量,如果你代码中的常量或变量表示某个条件下的值缺失,你应该给他声明为对应的可选项;<br>跟OC差别:<br>OC中的nil是一个指向不存在对象的指针,而Swift中nil不是指针,而是值缺失的一种特殊类型,任何类型的可选项都可以设置为nil,而不仅仅是对象类型;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str:String? &#x3D; &quot;game&quot;;str &#x3D; nil;print(str as Any)</span><br><span class="line">let str1 &#x3D; &quot;12321&quot;;let str2 &#x3D; Int(str1);print(str2 ?? 0)&#x2F;&#x2F;字符串转整型,需要确保字符串可以转成为整型</span><br><span class="line">  </span><br><span class="line">var networkCode:Int? &#x3D; 404;print(networkCode as Any)</span><br><span class="line">networkCode &#x3D; nil;print(networkCode as Any)</span><br><span class="line">    </span><br><span class="line">var otherName:String?;print(otherName as Any);&#x2F;&#x2F;提供的可选变量没有值,默认是nil</span><br><span class="line">otherName &#x3D; nil;</span><br></pre></td></tr></table></figure><h3 id="强制展开"><a href="#强制展开" class="headerlink" title="!:强制展开"></a>!:强制展开</h3><p>!:强制展开,”我知道可选项里面是有值的,展开把”;<br>注意:使用!来获取一个不存在的可选值会导致运行报错,使用!强展开时一定要确保可选项包含一个非nil的值;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myDay:String?</span><br><span class="line">myDay &#x3D; &quot;一月二十六&quot;;print(myDay!)&#x2F;&#x2F;我知道这个可选变量有一个非nil的值,所以强制展开</span><br><span class="line">if myDay !&#x3D; nil &#123;</span><br><span class="line">    print(myDay!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选项绑定"><a href="#可选项绑定" class="headerlink" title="可选项绑定"></a>可选项绑定</h3><p>可选项绑定:如果Int(myDay!)返回一个可选的Int类型,那么把这个值赋予给一个新的常量newDay  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if let newDay &#x3D; Int(myDay!) &#123;&#x2F;&#x2F;可以判断字符串是否可以转为整型</span><br><span class="line">    print(&quot;myDay! 可以转换为Int类型 \(newDay)&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print(&quot;myDay! 不能转换为Int类型 \(myDay!)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式展开可选项"><a href="#隐式展开可选项" class="headerlink" title="隐式展开可选项"></a>隐式展开可选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var canChoice:String!&#x2F;&#x2F;隐式可选项</span><br><span class="line">canChoice &#x3D; &quot;canChoice&quot;;print(canChoice as Any)</span><br><span class="line">    </span><br><span class="line">let key:String! &#x3D; &quot;new key&quot;</span><br><span class="line">let newKey:String &#x3D; key;print(newKey)&#x2F;&#x2F;key 不需要key!这样进行展开</span><br><span class="line">    </span><br><span class="line">let ey:String? &#x3D; &quot;new key&quot;</span><br><span class="line">let newEy:String &#x3D; ey!;print(newEy)&#x2F;&#x2F;ey 需要ey!这样进行展开</span><br></pre></td></tr></table></figure><p>end</p>]]></content>
      
      
      <categories>
          
          <category> Swift语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Swift基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中bundle文件</title>
      <link href="/2020/12/03/iOS%E4%B8%ADbundle%E6%96%87%E4%BB%B6/"/>
      <url>/2020/12/03/iOS%E4%B8%ADbundle%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="创建bundle工程"><a href="#创建bundle工程" class="headerlink" title="创建bundle工程"></a>创建bundle工程</h3><p>bundle文件在macOS下</p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E5%88%9B%E5%BB%BAbundle%E6%96%87%E4%BB%B6/macOS%E4%B8%8Bbundle.png" alt="image">  </p><p>命名<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E5%88%9B%E5%BB%BAbundle%E6%96%87%E4%BB%B6/%E5%91%BD%E5%90%8D.png" alt=""></p><a id="more"></a><h3 id="删除工程多余的文件"><a href="#删除工程多余的文件" class="headerlink" title="删除工程多余的文件"></a>删除工程多余的文件</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E5%88%9B%E5%BB%BAbundle%E6%96%87%E4%BB%B6/%E5%88%A0%E9%99%A4Info%E6%96%87%E4%BB%B6.png" alt="">  </p><p>记得Info.plist路径也要删除<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E5%88%9B%E5%BB%BAbundle%E6%96%87%E4%BB%B6/%E5%88%A0%E9%99%A4Info%E8%B7%AF%E5%BE%84.png" alt="">  </p><h3 id="设置为iOS而不是默认的macOS"><a href="#设置为iOS而不是默认的macOS" class="headerlink" title="设置为iOS而不是默认的macOS"></a>设置为iOS而不是默认的macOS</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E5%88%9B%E5%BB%BAbundle%E6%96%87%E4%BB%B6/%E6%94%B9%E4%B8%BAiOS.png" alt=""></p><h3 id="版本和iOS"><a href="#版本和iOS" class="headerlink" title="版本和iOS"></a>版本和iOS</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E5%88%9B%E5%BB%BAbundle%E6%96%87%E4%BB%B6/%E7%89%88%E6%9C%AC%E5%92%8CiOS.png" alt=""></p><h3 id="显示原文件"><a href="#显示原文件" class="headerlink" title="显示原文件"></a>显示原文件</h3><p>就是放进去了什么资源 显示的时候就是什么资源,@2x,@3x会合并为tiff文件如果为YES</p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E5%88%9B%E5%BB%BAbundle%E6%96%87%E4%BB%B6/%E8%AE%BE%E7%BD%AE%E4%B8%BANO.png" alt=""></p><h3 id="在工程进行Build之后"><a href="#在工程进行Build之后" class="headerlink" title="在工程进行Build之后"></a>在工程进行Build之后</h3><p>显示包内内容</p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E5%88%9B%E5%BB%BAbundle%E6%96%87%E4%BB%B6/%E6%98%BE%E7%A4%BA%E5%8C%85%E5%86%85%E5%AE%B9.png" alt=""></p><p>end</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> bundle </tag>
            
            <tag> SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS13暗黑模式的适配</title>
      <link href="/2020/05/27/iOS13%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%82%E9%85%8D/"/>
      <url>/2020/05/27/iOS13%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p><strong>苹果在iOS13推出了一种暗黑模式:可以在系统设置中,把iPhone手机展示模式变成暗黑风格;<br>暗黑模式是相对正常模式来说的,iOS13之前的iPhone手机模式都是正常模式.</strong>  </p><blockquote><p>暗黑模式的适配主要是在2个方面:<br>颜色和图片;<br>在暗黑模式和正常模式下,可以动态展示不同颜色和风格的照片;  </p></blockquote><a id="more"></a><h4 id="颜色的适配-Colors"><a href="#颜色的适配-Colors" class="headerlink" title="颜色的适配(Colors)"></a>颜色的适配(Colors)</h4><blockquote><p>iOS13新加了一种形如:UIColor *systemRedColor的系统颜色;<br>但不是设置了systemColor所有颜色在正常模式和暗黑模式都有2种颜色;  如红色,在两种模式下依然会是红色.  </p></blockquote><h5 id="代码自定义动态颜色"><a href="#代码自定义动态颜色" class="headerlink" title="代码自定义动态颜色"></a>代码自定义动态颜色</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法1:类方法</span><br><span class="line">UIColor *newColor1 &#x3D; [UIColor colorWithDynamicProvider:^UIColor * _Nonnull(UITraitCollection * _Nonnull traitCollection) &#123;</span><br><span class="line">    if (traitCollection.userInterfaceStyle &#x3D;&#x3D; UIUserInterfaceStyleLight) &#123;&#x2F;&#x2F;判断当前模式</span><br><span class="line">        return [UIColor whiteColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return [UIColor blackColor];</span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F;方法2:实例方法</span><br><span class="line">UIColor *color2 &#x3D; [[UIColor alloc]initWithDynamicProvider:^UIColor * _Nonnull(UITraitCollection * _Nonnull traitCollection) &#123;</span><br><span class="line">    if (traitCollection.userInterfaceStyle &#x3D;&#x3D; UIUserInterfaceStyleLight) &#123;&#x2F;&#x2F;判断当前模式</span><br><span class="line">        return [UIColor whiteColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return [UIColor blackColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h5 id="Assets-xcassets添加自定义动态颜色"><a href="#Assets-xcassets添加自定义动态颜色" class="headerlink" title="Assets.xcassets添加自定义动态颜色"></a>Assets.xcassets添加自定义动态颜色</h5><p>添加颜色<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/newColor.png" alt="image"><br>支持暗黑模式和正常模式:最右边选择Any,Dark.<br>颜色命名为color1,<br>正常模式下会读取左边的颜色,暗黑模式下会读取右边的颜色.<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/%E5%8A%A8%E6%80%81%E9%A2%9C%E8%89%B2.png" alt="image">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在Assets.xcassets中和图片一样添加color,可以根据以下方法读取自定义的颜色</span><br><span class="line">[UIColor colorNamed:@&quot;color1&quot;];</span><br></pre></td></tr></table></figure><h4 id="图片的适配"><a href="#图片的适配" class="headerlink" title="图片的适配"></a>图片的适配</h4><h5 id="Assets-xcassets添加图片"><a href="#Assets-xcassets添加图片" class="headerlink" title="Assets.xcassets添加图片"></a>Assets.xcassets添加图片</h5><p>在最右边选择Any,Dark<br>会出现如下图,把对应的图片拉进去即可:<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/%E5%9B%BE%E7%89%87.png" alt="image"></p><h5 id="把图片放进xcode工程适配"><a href="#把图片放进xcode工程适配" class="headerlink" title="把图片放进xcode工程适配"></a>把图片放进xcode工程适配</h5><p>正常模式和暗黑模式的图片命名分开,然后判断当前app的是否是暗黑模式,来读取不同的图片资源.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UITraitCollection *traitCollection &#x3D; [[UITraitCollection alloc]init];</span><br><span class="line">if (traitCollection.userInterfaceStyle &#x3D;&#x3D; UIUserInterfaceStyleLight) &#123;</span><br><span class="line">&#x2F;&#x2F;判断当前模式</span><br><span class="line">     UIImage *im &#x3D; [UIImage imageNamed:@&quot;xxx.png&quot;]; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="苹果API自定义的动态颜色"><a href="#苹果API自定义的动态颜色" class="headerlink" title="苹果API自定义的动态颜色"></a>苹果API自定义的动态颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置这种动态颜色,不会造成有正常模式转成暗黑模式时,会出现看不见的情况</span><br><span class="line">UIColor *labelColor;&#x2F;&#x2F;字体颜色(正常模式如果是黑色,那么暗黑模式下会自动转换成白色)</span><br><span class="line">UIColor *placeholderTextColor;</span><br><span class="line">UIColor *separatorColor;</span><br><span class="line">UIColor *systemBackgroundColor;&#x2F;&#x2F;背景在正常模式下默认是白色,暗黑则变成黑色.</span><br><span class="line">、、、、</span><br><span class="line">、、、、</span><br></pre></td></tr></table></figure><!--[WWDC暗黑模式讲解](https://developer.apple.com/videos/play/wwdc2019/214/)-->]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暗黑模式 </tag>
            
            <tag> iOS13 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果设备系列各种参数</title>
      <link href="/2020/05/07/%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E7%B3%BB%E5%88%97%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0/"/>
      <url>/2020/05/07/%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E7%B3%BB%E5%88%97%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="全面屏"><a href="#全面屏" class="headerlink" title="全面屏"></a>全面屏</h4><!--|  手机型号  |  尺寸(对角线)  |物理尺寸pt|  像素点px  |  图片倍数 |  状态栏高度  | 出厂系统 || :-: | :-: |  :-: |  :-: | :-: | :-: | :-: || iPhone 11 Pro Max| 6.5英寸 | 414 x 986 | 1242 x 2688 | @3x | 44 | iOS13|| iPhone 11 Pro | 5.8英寸 | 375 x 812 | 1125 x 2436 | @3x | 44 | iOS13|| iPhone 11 | 6.1英寸 | 414 x 986 | 828 x 1792 | @2x | 44 | iOS13|| iPhone XR | 6.1英寸 | 414 x 986 | 828 x 1792 | @2x | 44 | iOS12|| iPhone XS Max| 6.5英寸 | 414 x 986 | 1242 x 2688 | @3x | 44 | iOS12|| iPhone XS | 5.8英寸 | 375 x 812 | 1125 x 2436 | @3x | 44 | iOS12|| iPhone X | 5.8英寸 | 375 x 812 | 1125 x 2436 | @3x | 44 | iOS11|  --><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87/%E5%85%A8%E9%9D%A2%E5%B1%8F.png" alt="image"></p><a id="more"></a><p><strong>导航栏高度:44<br>tabbar高度:83<br>底部安全区域:34</strong>  </p><blockquote><p>1,tabbar实际应用的导航栏还是83 - 34 = 49;<br>2,底部安全区域无法进行布局  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 是否是iPhoneX全面屏系列</span><br><span class="line">FOUNDATION_STATIC_INLINE BOOL MYPhoneX()&#123;</span><br><span class="line">    BOOL IS_iPhone &#x3D; ([[UIDevice currentDevice] userInterfaceIdiom] &#x3D;&#x3D; UIUserInterfaceIdiomPhone);&#x2F;&#x2F;是iPhone不是iPad</span><br><span class="line">    BOOL IS_iOS11 &#x3D; ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;&#x3D; 11.f);&#x2F;&#x2F;全面屏iOS11以上才有</span><br><span class="line">    BOOL iPhoneX &#x3D; (IS_iOS11 &amp;&amp; IS_iPhone &amp;&amp; (MIN([UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) &gt;&#x3D; 375 &amp;&amp; MAX([UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) &gt;&#x3D; 812));  </span><br><span class="line">    &#x2F;&#x2F;后面min和max是判断横竖屏宽和高</span><br><span class="line">    return iPhoneX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非全面屏"><a href="#非全面屏" class="headerlink" title="非全面屏"></a>非全面屏</h4><!--|  手机型号  |  尺寸(对角线)  |物理尺寸pt|  像素点px  |  图片倍数 |  状态栏高度 | 出厂系统 | | :-: | :-: |  :-: |  :-: | :-: | :-: | :-: | | iPhone SE | **4.7英寸** | 375 x 667 | 750 x 1334 | @2x | 20 | iOS13 | | iPhone 8 Plus |  5.5英寸 | 414 x 736 | 1242 x 2208 | @3x | 20 | iOS11 || iPhone 8 | 4.7英寸 | 375 x 667 | 750 x 1334 | @2x | 20 | iOS11 | | iPhone 7 Plus |  5.5英寸 | 414 x 736 | 1242 x 2208 | @3x | 20 | iOS10 | | iPhone 7 | 4.7英寸 | 375 x 667 | 750 x 1334 | @2x | 20 | iOS10 | | iPhone 6S Plus |  5.5英寸 | 414 x 736 | 1242 x 2208 | @3x | 20 | iOS9 | | iPhone 6S | 4.7英寸 | 375 x 667 | 750 x 1334 | @2x | 20 | iOS9 | | iPhone 6 Plus |  5.5英寸 | 414 x 736 | 1242 x 2208 | @3x | 20 | iOS8 | | iPhone 6 | 4.7英寸 | 375 x 667 | 750 x 1334 | @2x | 20 | iOS8 | | iPhone SE | 4.0英寸 | 320 x 568 | 640 x 1136 | @2x | 20 | iOS9 | | iPhone 5/5S/5C | 4.0英寸 | 320 x 568 | 640 x 1136 | @2x | 20 | iOS6/7/7 | | iPhone 4/4S | 3.5英寸 | 320 x 568 | 640 x 960 | @2x | 20 | iOS4/5 | --><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87/%E9%9D%9E%E5%85%A8%E9%9D%A2%E5%B1%8F.png" alt="image"><br>导航栏高度:44<br>tabbar高度:49</p>]]></content>
      
      
      <categories>
          
          <category> 苹果设备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 苹果设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS沙盒机制</title>
      <link href="/2020/04/21/iOS%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/04/21/iOS%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h4><p><strong>1,每个app下都有一个独立的沙盒目录,就是该app的文件目录,跟其他的app沙盒是相互隔离的,他们之间不能进行数据间的访问.<br>2,app所有非代码文件都保存在沙盒中,比如plist,文本,文件夹,图片,图标,音视频等等.</strong>  </p><a id="more"></a><h4 id="获取沙盒不同文件夹的路径"><a href="#获取沙盒不同文件夹的路径" class="headerlink" title="获取沙盒不同文件夹的路径"></a>获取沙盒不同文件夹的路径</h4><h5 id="沙盒基本目录结构"><a href="#沙盒基本目录结构" class="headerlink" title="沙盒基本目录结构"></a>沙盒基本目录结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            &#x2F;Doucuments</span><br><span class="line">            &#x2F;Library</span><br><span class="line">sandbox:    &#x2F;Library&#x2F;Preferences</span><br><span class="line">            &#x2F;Library&#x2F;Caches</span><br><span class="line">            &#x2F;Tmp</span><br></pre></td></tr></table></figure><h5 id="沙盒路径读取"><a href="#沙盒路径读取" class="headerlink" title="沙盒路径读取"></a>沙盒路径读取</h5><p>主路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;沙盒在模拟器或者真机中的主路径</span><br><span class="line">NSString *home &#x3D; NSHomeDirectory();</span><br><span class="line">NSLog(@&quot;沙盒主路径:\n%@&quot;,home);</span><br></pre></td></tr></table></figure><p>Documents<br>保存app重要数据(如FMDB,下载的图片和音视频),该文件夹下文件会在程序更新时自动备份,连接itunes会进行备份.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *docPath &#x3D; [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES) lastObject]; </span><br><span class="line">NSLog(@&quot;document路径:\n%@&quot;,docPath);</span><br></pre></td></tr></table></figure><p>Library<br>下有2个子文件夹(Preferences和Caches),保存不希望给用户看到的数据,可以自主创建文件,除了caches外,都会被itunes备份.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *libPath &#x3D; [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject];</span><br></pre></td></tr></table></figure><p>Library下Preferences路径<br>保存程序的偏好设置,如NSUserDefaults,plist(允许权限说明)等,会被itunes备份.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *prePath &#x3D; [NSString stringWithFormat:@&quot;%@%@&quot;,libPath,@&quot;&#x2F;Preferences&quot;];</span><br></pre></td></tr></table></figure><p>Library下Caches路径<br>保存程序运行的时候产生支持文件和缓存文件,iTunes不会备份该目录而且会被其他工具清除.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *cachPath &#x3D; [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br></pre></td></tr></table></figure><p>Tmp路径<br>程序运行时的临时数据,不会被iTunes备份,手机重启时,会被清空.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *tmpPath &#x3D; NSTemporaryDirectory();</span><br></pre></td></tr></table></figure><p>获取路径函数:C函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1,返回值是一个字符串数组: NSArray&lt;NSString *&gt;</span><br><span class="line">2,NSSearchPathDirectory 枚举,想要查找的目录,有iOS,MacOS,watchOS的,iOS用到:NSDocumentDirectory,NSLibraryDirectory,NSCachesDirectory</span><br><span class="line">3,NSSearchPathDomainMask 枚举,查找范围:NSUserDomainMask iOS的:当前用户</span><br><span class="line">4,expandTilde BOOL值,YES的时候,全部路径都会展示;NO的时候,前面的会省略(如caches路径会变成:~Caches)  </span><br><span class="line">NSArray&lt;NSString *&gt; *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde);</span><br></pre></td></tr></table></figure><h4 id="获取某个文件夹路径下一级目录和所有目录"><a href="#获取某个文件夹路径下一级目录和所有目录" class="headerlink" title="获取某个文件夹路径下一级目录和所有目录"></a>获取某个文件夹路径下一级目录和所有目录</h4><h5 id="主路径下的所有目录"><a href="#主路径下的所有目录" class="headerlink" title="主路径下的所有目录"></a>主路径下的所有目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSArray * subArr &#x3D; [[NSFileManager defaultManager] subpathsAtPath:home];</span><br><span class="line">NSLog(@&quot;subArr &#x3D; %@&quot;,subArr);</span><br><span class="line">subArr &#x3D; (</span><br><span class="line">    &quot;.DS_Store&quot;,</span><br><span class="line">    &quot;.com.apple.mobile_container_manager.metadata.plist&quot;,</span><br><span class="line">    Library,</span><br><span class="line">    &quot;Library&#x2F;Saved Application State&quot;,</span><br><span class="line">    &quot;Library&#x2F;Saved Application State&#x2F;work.Sandbox----.savedState&quot;,</span><br><span class="line">    &quot;Library&#x2F;Saved Application State&#x2F;work.Sandbox----.savedState&#x2F;KnownSceneSessions&quot;,</span><br><span class="line">    &quot;Library&#x2F;Saved Application State&#x2F;work.Sandbox----.savedState&#x2F;KnownSceneSessions&#x2F;data.data&quot;,</span><br><span class="line">    &quot;Library&#x2F;Preferences&quot;,</span><br><span class="line">    &quot;Library&#x2F;SplashBoard&quot;,</span><br><span class="line">    &quot;Library&#x2F;SplashBoard&#x2F;Snapshots&quot;,</span><br><span class="line">    &quot;Library&#x2F;SplashBoard&#x2F;Snapshots&#x2F;work.Sandbox---- - &#123;DEFAULT GROUP&#125;&quot;,</span><br><span class="line">    &quot;Library&#x2F;SplashBoard&#x2F;Snapshots&#x2F;work.Sandbox---- - &#123;DEFAULT GROUP&#125;&#x2F;DE69DCF5-A4F3-4F0B-B5A0-74368B24E796@2x.ktx&quot;,</span><br><span class="line">    &quot;Library&#x2F;SplashBoard&#x2F;Snapshots&#x2F;work.Sandbox---- - &#123;DEFAULT GROUP&#125;&#x2F;6D660E24-4C00-47D1-BC75-42D929F9969B@2x.ktx&quot;,</span><br><span class="line">    &quot;Library&#x2F;SplashBoard&#x2F;Snapshots&#x2F;work.Sandbox---- - &#123;DEFAULT GROUP&#125;&#x2F;301F834A-80C7-4AF2-8AA6-C16369B5A90D@2x.ktx&quot;,</span><br><span class="line">    &quot;Library&#x2F;SplashBoard&#x2F;Snapshots&#x2F;work.Sandbox---- - &#123;DEFAULT GROUP&#125;&#x2F;2F1A81AA-A919-4542-967B-225EB2DED409@2x.ktx&quot;,</span><br><span class="line">    &quot;Library&#x2F;Caches&quot;,</span><br><span class="line">    Documents,</span><br><span class="line">    &quot;Documents&#x2F;file1&quot;,</span><br><span class="line">    tmp,</span><br><span class="line">    Documentsfile1,</span><br><span class="line">    SystemData</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="Docments路径下的一级文件"><a href="#Docments路径下的一级文件" class="headerlink" title="Docments路径下的一级文件"></a>Docments路径下的一级文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *docPath &#x3D; [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES) lastObject];</span><br><span class="line">NSArray *arr2 &#x3D; [[NSFileManager defaultManager] subpathsOfDirectoryAtPath:docPath error:nil];</span><br><span class="line">NSLog(@&quot;某个文件下的所有一级文件 &#x3D; %@&quot;,arr2);</span><br><span class="line"> (</span><br><span class="line">    file1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 沙盒 </tag>
            
            <tag> 数据保存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS本地推送</title>
      <link href="/2020/04/17/iOS%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5/"/>
      <url>/2020/04/17/iOS%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>本地推送:  </p><blockquote><p>1, 使用本地推送来引起用户的注意,可以是一个alter弹窗、声音、图片、视频等.例如后台应用程序可以要求系统完成特定任务时显示提醒信息.始终使用本地推送来传达用户需要的重要信息.<br>2,本地推送弹窗根据你设定的时间和位置进行弹窗推送,第一,如果你的App在后台或者未运行时发送推送,系统会发送弹窗在手机上方,第二,如果你的App在前台运行,系统会发送推送让你在程序中进行需要的处理(代码层). </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UserNotifications&#x2F;UserNotifications.h&gt;&#x2F;&#x2F;导入的库,iOS10之后才有</span><br><span class="line">&#x2F;&#x2F;类</span><br><span class="line">UNUserNotificationCenter</span><br><span class="line">&#x2F;&#x2F;协议</span><br><span class="line">UNUserNotificationCenterDelegate</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="推送权限"><a href="#推送权限" class="headerlink" title="推送权限"></a>推送权限</h4><p>确定App是否开启了推送允许权限: UNUserNotificationCenter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1,判断用户是否开启了推送功能</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionAlert | UNAuthorizationOptionSound | UNAuthorizationOptionBadge completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</span><br><span class="line">    if (granted &#x3D;&#x3D; YES) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取到本地推送的权限</span><br><span class="line">        NSLog(@&quot;已经获得权限&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;权限失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="推送内容"><a href="#推送内容" class="headerlink" title="推送内容"></a>推送内容</h4><p>配置推送内容: UNMutableNotificationContent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;2,推送内容</span><br><span class="line">UNMutableNotificationContent *content &#x3D; [[UNMutableNotificationContent alloc]init];</span><br><span class="line">content.title &#x3D; @&quot;推送标题&quot;;</span><br><span class="line">content.subtitle &#x3D; @&quot;推送副标题&quot;;</span><br><span class="line">content.body &#x3D; @&quot;推送文字内容&quot;;</span><br><span class="line">content.badge &#x3D; @222;&#x2F;&#x2F;app角标显示的数量</span><br><span class="line">content.sound &#x3D; [UNNotificationSound defaultSound];&#x2F;&#x2F;默认声音</span><br><span class="line">content.userInfo &#x3D; @&#123;@&quot;A1&quot;:@&quot;自己定义的特定内容&quot;&#125;;</span><br><span class="line">&#x2F;&#x2F;    NSURL *url &#x3D; [[NSBundle mainBundle] URLForResource:@&quot;1.png&quot; withExtension:nil];</span><br><span class="line">&#x2F;&#x2F;    UNNotificationAttachment *attachment &#x3D; [UNNotificationAttachment attachmentWithIdentifier:@&quot;i1&quot; URL:url options:nil error:nil];</span><br><span class="line">&#x2F;&#x2F;    content.attachments &#x3D; @[attachment];&#x2F;&#x2F;推送附件,可以是图片,视频,音频,这里是一张图片,附件需要存在本地</span><br><span class="line">content.categoryIdentifier &#x3D; @&quot;currentNoti&quot;;&#x2F;&#x2F;标识符</span><br></pre></td></tr></table></figure><h4 id="推送的时刻"><a href="#推送的时刻" class="headerlink" title="推送的时刻"></a>推送的时刻</h4><p>配置推送的触发条件:  </p><blockquote><p>1,UNTimeIntervalNotificationTrigger //延迟多少秒,当repeats = YES 配置的时间需要大于60s.<br>2,UNCalendarNotificationTrigger //推送日期, 年,月,日,小时,分钟,秒.<br>3,UNLocationNotificationTrigger //地点,到达设定好的地点之后推送</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNTimeIntervalNotificationTrigger *timerTrigger &#x3D; [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:65 repeats:NO];</span><br></pre></td></tr></table></figure><h4 id="创建推送的请求"><a href="#创建推送的请求" class="headerlink" title="创建推送的请求"></a>创建推送的请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;4,创建推送的请求, @&quot;currentNoti&quot;是标识符.可以在移除的时候根据标识符找到该推送请求.</span><br><span class="line">UNNotificationRequest *notiRequest &#x3D; [UNNotificationRequest requestWithIdentifier:@&quot;currentNoti&quot; content:content trigger:timerTrigger];</span><br></pre></td></tr></table></figure><h4 id="开启推送"><a href="#开启推送" class="headerlink" title="开启推送"></a>开启推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;5,加入推送中心,开启推送</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:notiRequest withCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        NSLog(@&quot;成功推送了一条本地推送&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;报错&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="移除本地推送"><a href="#移除本地推送" class="headerlink" title="移除本地推送"></a>移除本地推送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;6,移除local本地推送</span><br><span class="line">&#x2F;&#x2F;移除所有推送</span><br><span class="line"> [[UNUserNotificationCenter currentNotificationCenter] removeAllPendingNotificationRequests]; </span><br><span class="line">&#x2F;&#x2F;移除一个推送,或者多个,根据标识符来移除</span><br><span class="line"> [[UNUserNotificationCenter currentNotificationCenter] removePendingNotificationRequestsWithIdentifiers:@[@&quot;currentNoti&quot;]];</span><br></pre></td></tr></table></figure><h4 id="获取当前存在的推送标识"><a href="#获取当前存在的推送标识" class="headerlink" title="获取当前存在的推送标识"></a>获取当前存在的推送标识</h4><p>UNNotificationRequest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前存在的推送UNNotificationRequest</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter]getPendingNotificationRequestsWithCompletionHandler:^(NSArray&lt;UNNotificationRequest *&gt; * _Nonnull requests) &#123;</span><br><span class="line">    for (UNNotificationRequest *req in requests) &#123;</span><br><span class="line">        NSLog(@&quot;存在的本地推送标识:%@&quot;,req.identifier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="推送的协议-UNUserNotificationCenterDelegate"><a href="#推送的协议-UNUserNotificationCenterDelegate" class="headerlink" title="推送的协议:UNUserNotificationCenterDelegate"></a>推送的协议:UNUserNotificationCenterDelegate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实现协议</span><br><span class="line">[UNUserNotificationCenter currentNotificationCenter].delegate &#x3D; self;</span><br><span class="line">&#x2F;&#x2F;协议中的方法</span><br><span class="line">-(void)userNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(UNNotification *)notification&#123;</span><br><span class="line">    &#x2F;&#x2F;是在app内展示推送的设置情况，需要在请求权限的options中添加 providesAppNotificationSettings，iOS12才支持</span><br><span class="line">&#125;</span><br><span class="line">-(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler&#123;</span><br><span class="line">    &#x2F;&#x2F;应用在前台时,接收到消息触发的方法,无论是否点击都会触发</span><br><span class="line">&#125;</span><br><span class="line">-(void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler&#123;</span><br><span class="line">    &#x2F;&#x2F;点击了推送的消息,进入app时会触发此方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地推送 </tag>
            
            <tag> UNUserNotificationCenter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSException</title>
      <link href="/2020/04/15/%E7%A8%8B%E5%BA%8Fcrash%E7%9A%84NSException/"/>
      <url>/2020/04/15/%E7%A8%8B%E5%BA%8Fcrash%E7%9A%84NSException/</url>
      
        <content type="html"><![CDATA[<h4 id="NSException"><a href="#NSException" class="headerlink" title="NSException"></a>NSException</h4><p>异常类:NSException</p><blockquote><p>使用NSException实现异常处理。 异常是一种特殊情况，会中断程序的正常执行流程。 每个应用程序都有不同的原因可以中断程序。 例如，一个应用程序可能会将文件保存在受写保护的目录中作为例外。 从这个意义上讲，异常等同于错误。 另一个应用程序可能会将用户的按键解释（例如Control-C）解释为例外情况：表明长时间运行的进程应中止。</p></blockquote><a id="more"></a><p>NSException有三个属性来解释当前异常的原因:<br>第一个:@property (readonly, copy) NSExceptionName name;//异常名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NSExceptionName</span><br><span class="line">NSGenericException;&#x2F;&#x2F;一般异常.</span><br><span class="line">NSRangeException;&#x2F;&#x2F;尝试访问某些数据范围之外（例如,字符串末尾,访问数组越界值）时发生的异常的名称.</span><br><span class="line">NSInvalidArgumentException;&#x2F;&#x2F;将无效的参数传递给方法时发生的异常的名称，例如需要非nil对象的nil指针.</span><br><span class="line">NSInternalInconsistencyException;&#x2F;&#x2F;当内部声明失败并在被调用代码中隐含意外情况时发生的异常的名称,不一致造成的错误,如NSMutableDictionary有很多方法NSDictionary不能调用,但是却进行了调用.</span><br><span class="line"></span><br><span class="line">NSMallocException;&#x2F;&#x2F;内存不足异常,过时,目前没有使用</span><br><span class="line"></span><br><span class="line">NSObjectInaccessibleException;&#x2F;&#x2F;对象不可访问造成的异常</span><br><span class="line">NSObjectNotAvailableException;&#x2F;&#x2F;对象不可用,如使用UIAlterView废弃API,SceneDelegate删除同时需要删除info.plist等.</span><br><span class="line">NSDestinationInvalidException;&#x2F;&#x2F;目标无效异常,如子线程执行任务,但是执行任务之前子线程已经被释放. </span><br><span class="line"></span><br><span class="line">NSPortTimeoutException;&#x2F;&#x2F;端口接收或者发送超时异常</span><br><span class="line">NSInvalidSendPortException;&#x2F;&#x2F;无效发送端口造异常</span><br><span class="line">NSInvalidReceivePortException;&#x2F;&#x2F;无效接收端口异常</span><br><span class="line">NSPortSendException;&#x2F;&#x2F;端口发送异常</span><br><span class="line">NSPortReceiveException;&#x2F;&#x2F;端口接收异常</span><br><span class="line"></span><br><span class="line">NSOldStyleException;&#x2F;&#x2F;老样式异常</span><br><span class="line"></span><br><span class="line">NSInconsistentArchiveException;&#x2F;&#x2F;初始化或者编码有异常;</span><br></pre></td></tr></table></figure><p>第二个:@property (nullable, readonly, copy) NSString * reason;//异常的原因<br>第三个:@property (nullable, readonly, copy) NSDictionary * userInfo;//异常的信息</p><h4 id="判断可能会出现崩溃的代码-try…-catch…-finally"><a href="#判断可能会出现崩溃的代码-try…-catch…-finally" class="headerlink" title="判断可能会出现崩溃的代码@try…@catch… @finally"></a>判断可能会出现崩溃的代码@try…@catch… @finally</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自主判断可能会出现崩溃的代码.</span><br><span class="line">@try &#123;</span><br><span class="line">    NSArray *arr &#x3D; @[@&quot;2&quot;,@&quot;1&quot;];</span><br><span class="line">    for (NSUInteger i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSString *str &#x3D; arr[i];</span><br><span class="line">        NSLog(@&quot;str &#x3D; %@&quot;,str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line">    NSLog(@&quot;\n%@,\n%@,\n%@,&quot;,exception.reason,exception.name,exception.userInfo);</span><br><span class="line">    &#x2F;&#x2F;@try如果崩溃则会来到这里</span><br><span class="line">    &#x2F;&#x2F;本地保存上传服务器或者直接上传服务器   </span><br><span class="line">&#125; @finally &#123;</span><br><span class="line">    NSLog(@&quot;finally无论崩溃都会执行&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;直接抛出一个异常,程序会直接崩溃</span><br><span class="line">@throw [NSException exceptionWithName:NSRangeException reason:@&quot;数组越界&quot; userInfo:@&#123;@&quot;1&quot;:@&quot;2&quot;&#125;];</span><br></pre></td></tr></table></figure><h4 id="收集NSException崩溃信息"><a href="#收集NSException崩溃信息" class="headerlink" title="收集NSException崩溃信息"></a>收集NSException崩溃信息</h4><blockquote><p>崩溃时,先本地保存下次打开时候再把崩溃信息上传到服务器;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;崩溃监听方法,需要写在self.window.root... 之前</span><br><span class="line">NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#x2F;&#x2F;UncaughtExceptionHandler C方法</span><br><span class="line">void UncaughtExceptionHandler(NSException *exception)&#123;</span><br><span class="line">    NSLog(@&quot;异常的监听:exception &#x3D; %@&quot;,exception.name);</span><br><span class="line">    NSString *name &#x3D; exception.name;</span><br><span class="line">    NSString *reason &#x3D; exception.reason;</span><br><span class="line">    NSDictionary *info &#x3D; exception.userInfo;</span><br><span class="line">    NSArray *arr1 &#x3D; exception.callStackSymbols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crash </tag>
            
            <tag> 程序崩溃 </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发证书的制作</title>
      <link href="/2020/04/14/iOS%E5%BC%80%E5%8F%91%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
      <url>/2020/04/14/iOS%E5%BC%80%E5%8F%91%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p> <strong>个人开发者账号申请:</strong>  </p><blockquote><p>1,通过iPhone手机下载:开发者App,名字就叫开发者;<br>2,直接在账户中申请注册,按照要求一步步填写对应的信息,信息填完之后会扣钱,如果扣钱成功,说明你的苹果账号已经成为了开发者账号;  </p></blockquote><a id="more"></a><p>要想xcode中的某个工程运行在真机iPhone上和提交App Store审核,需要在<a href="https://developer.apple.com/" target="_blank" rel="noopener">苹果开发者中心</a>制作对应的证书;<br>他们会包含:  </p><blockquote><p>1,每一个app对应的唯一标识:bundle identifier 也叫包名,注意不是App的名字<br>2,测试证书和上架证书<br>3,测试描述文件和上架描述文件<br>4,如果有推送功能,还需要测试和上架推送证书;<br>5,添加测试设备的UDID;  </p></blockquote><h3 id="申请制作证书需要的csr文件"><a href="#申请制作证书需要的csr文件" class="headerlink" title="申请制作证书需要的csr文件"></a>申请制作证书需要的csr文件</h3><p> first,打开你的Mac,在应用中找到钥匙串这个应用然后打开,点击如下图所示:<br> 从证书颁发机构请求证书<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p1-1.png" alt="image"></p><p>second,用户的电子邮件地址需要填写,把申请的csr存储到磁盘</p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p1-2.png" alt="image"></p><p>last,保存在合适的位置,到时候需要使用<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p1-3.png" alt="image"></p><h3 id="Certificates-制作测试证书和上架证书"><a href="#Certificates-制作测试证书和上架证书" class="headerlink" title="Certificates:制作测试证书和上架证书"></a>Certificates:制作测试证书和上架证书</h3><p><a href="https://developer.apple.com/" target="_blank" rel="noopener">去苹果开发者中心</a>点击右边的account进入如下图所示界面,左边的就是证书:<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p2-1.png" alt="">  </p><p>点进去,看到如下图<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/List.png" width = "200" height = "300" alt="..." align=center /><br>点击选择证书类型<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/%E8%AF%81%E4%B9%A6.png" alt=""><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/%E8%AF%81%E4%B9%A6%E7%B1%BB%E5%9E%8B.png" alt="">  </p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/%E9%80%89%E6%8B%A9csr.png" alt=""></p><p>制作完成之后直接下载即可.  </p><h3 id="Identifiers添加App的bundle-identifier"><a href="#Identifiers添加App的bundle-identifier" class="headerlink" title="Identifiers添加App的bundle identifier"></a>Identifiers添加App的bundle identifier</h3><p>选择Identifiers<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/%E5%8C%85%E5%90%8D.png" alt=""><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/APPIDS.png" alt=""><br>填写细节<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/APP%2BID.png" alt=""><br>创建完即可  </p><h3 id="Devices添加要参加测试的苹果设备UDID"><a href="#Devices添加要参加测试的苹果设备UDID" class="headerlink" title="Devices添加要参加测试的苹果设备UDID"></a>Devices添加要参加测试的苹果设备UDID</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/Devices-1.png" alt=""><br>填写细节<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/Device-2.png" alt=""><br>创建完即可</p><h3 id="Profiles描述文件"><a href="#Profiles描述文件" class="headerlink" title="Profiles描述文件"></a>Profiles描述文件</h3><p>描述文件区分测试和上架<br>如下图:Development就是测试,App Store就是上架<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6.png" alt=""><br>第一步 选择要制作的描述文件类型<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p1.png" alt=""><br>第二步 选择bundle identifier<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p2.png" alt=""><br>第三步 选择之前制作好的对应的证书<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p3.png" alt=""><br>第四步 选择这个描述文件可以参加测试的设备<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p4.png" alt=""><br>第五步 给这个描述文件命名<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/p5.png" alt=""><br>最后一步,创建完下载即可.  </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最后,我们获得<br>一个证书 + 一个描述文件<br>测试证书和测试描述文件对应,上架证书和上架描述文件对应;<br>把下载的证书和描述文件直接双击安装即可进行真机测试或者出上架的ipa包.</p><h3 id="其他证书相关-推送证书"><a href="#其他证书相关-推送证书" class="headerlink" title="其他证书相关:推送证书"></a>其他证书相关:推送证书</h3><p>使用之前保存的csr文件来进行制作<br>也分为推送测试证书和推送上架证书<br>下图<br>第一个是测试用的<br>第二个上架用的<br>创建完直接下载双击即可.<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/iOS%E8%AF%81%E4%B9%A6%E5%88%B6%E4%BD%9C%E7%AD%89/%E6%8E%A8%E9%80%81%E8%AF%81%E4%B9%A6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS单例</title>
      <link href="/2020/04/13/iOS%E5%8D%95%E4%BE%8B/"/>
      <url>/2020/04/13/iOS%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p> 整个程序中某个类只存在一份实例;<br> 一旦创建,程序结束后才会销毁回收内存;<br> 单例对象指针保存在静态区,单例对象存在堆中分配的内存空间;<br> <a id="more"></a><br> 苹果本身API存在的单例:  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIApplication</span><br><span class="line">NSNotificationCenter</span><br><span class="line">NSUserDefaults</span><br><span class="line">NSFileManager</span><br></pre></td></tr></table></figure><blockquote><p>优点:<br> 整个程序中只会实例化一次,程序出现问题比较容易定位;<br> 只会实例化一次,节省内存;<br>缺点:<br>不能被继承,没有子类,不能扩展和重写;<br>程序运行过程中一直占着内存,单例创建过多时和闲置时会占用内存资源;</p></blockquote><h3 id="单例的创建方式"><a href="#单例的创建方式" class="headerlink" title="单例的创建方式"></a>单例的创建方式</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.h  </span><br><span class="line">+(Common *)sharedInstance;</span><br><span class="line"></span><br><span class="line">.m  </span><br><span class="line">+(Common *)sharedInstance&#123;</span><br><span class="line">    static Common *common &#x3D; nil;&#x2F;&#x2F;static修饰,只初始化一次,修改实例生命周期,程序结束后才会回收;</span><br><span class="line">    @synchronized (common) &#123;&#x2F;&#x2F;线程安全</span><br><span class="line">        if (common &#x3D;&#x3D; nil) &#123;</span><br><span class="line">            common &#x3D; [[Common alloc]init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return common;</span><br><span class="line">&#125;</span><br><span class="line">打印的内存地址:</span><br><span class="line">NSLog(@&quot;\n1:%p\n2:%p\n3:%p\n&quot;,[Common sharedInstance],[Common sharedInstance],[Common sharedInstance]);  </span><br><span class="line">2020-04-13 10:24:20.471536+0800 Dispatch(线程安全)[32199:1460720] </span><br><span class="line">1:0x600000d5b640</span><br><span class="line">2:0x600000d5b640</span><br><span class="line">3:0x600000d5b640</span><br></pre></td></tr></table></figure><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p>为了数据和线程安全,苹果官方推荐使用这种方式进行创建单例;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line">+(Common *)sharedInstanceOnce;</span><br><span class="line"></span><br><span class="line">.m</span><br><span class="line">#import &quot;Common.h&quot;</span><br><span class="line">static Common *common1 &#x3D; nil;</span><br><span class="line">@implementation Common</span><br><span class="line">+(Common *)sharedInstanceOnce&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;&#x2F;&#x2F;只会被执行一次并且线程安全</span><br><span class="line">        common1 &#x3D; [[Common alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return common1;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;\n1:%p\n2:%p\n3:%p\n&quot;,[Common sharedInstanceOnce],[Common sharedInstanceOnce],[Common sharedInstanceOnce]);</span><br><span class="line">1:0x600001c63870</span><br><span class="line">2:0x600001c63870</span><br><span class="line">3:0x600001c63870</span><br></pre></td></tr></table></figure><p>end</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改xcode中targets名称</title>
      <link href="/2020/04/10/%E4%BF%AE%E6%94%B9xcode%E4%B8%ADtargets%E5%90%8D%E5%AD%97/"/>
      <url>/2020/04/10/%E4%BF%AE%E6%94%B9xcode%E4%B8%ADtargets%E5%90%8D%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><blockquote><p>当xcode工程中某个targets起的名字不符合预期,而要进行修改的时候,可以试试下面的教程进行操作;  </p></blockquote><h4 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h4><p>Dispatch修改成Dispatch(线程安全)</p><h5 id="左上角选择manager-schemes"><a href="#左上角选择manager-schemes" class="headerlink" title="左上角选择manager schemes"></a>左上角选择manager schemes</h5><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E4%BF%AE%E6%94%B9xcode%E4%B8%ADtargets%E5%90%8D%E7%A7%B0/scheme%E4%BF%AE%E6%94%B9.png" alt="image"></p><h5 id="在如图所示的地方修改"><a href="#在如图所示的地方修改" class="headerlink" title="在如图所示的地方修改"></a>在如图所示的地方修改</h5><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E4%BF%AE%E6%94%B9xcode%E4%B8%ADtargets%E5%90%8D%E7%A7%B0/targets%E4%BF%AE%E6%94%B9.png" alt="image"> </p><h5 id="修改工程左边文件夹的名称"><a href="#修改工程左边文件夹的名称" class="headerlink" title="修改工程左边文件夹的名称"></a>修改工程左边文件夹的名称</h5><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E4%BF%AE%E6%94%B9xcode%E4%B8%ADtargets%E5%90%8D%E7%A7%B0/%E5%B7%A6%E8%BE%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E4%BF%AE%E6%94%B9.png" alt="image"></p><h5 id="修改info-plist的路径"><a href="#修改info-plist的路径" class="headerlink" title="修改info.plist的路径"></a>修改info.plist的路径</h5><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2020%E5%B9%B4/%E4%BF%AE%E6%94%B9xcode%E4%B8%ADtargets%E5%90%8D%E7%A7%B0/info%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.png" alt="image"> </p><p>build工程之后,发现已经成功了.</p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xcode </tag>
            
            <tag> targets修改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全</title>
      <link href="/2020/04/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2020/04/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>1,单线程情况下,任务依次执行不会出现线程安全的问题;<br>2,单线程情况下,多线程都是访问共享资源,而不是修改资源也可以保证线程安全,如:只读的全局属性;<br>3,<strong>线程不安全是由于多线程访问造成的,多线程访问和修改共享资源引起了不可预测的结果;</strong><a id="more"></a>  </p><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p><strong>线程锁</strong>可以有效的解决多线程引起的安全问题.<br>iOS多线程开发为保证线程安全而使用了好几种锁:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSLock、dispatch_semaphore、NSCondition  </span><br><span class="line">NSRecursiveLock、NSConditionLock、@synchronized</span><br></pre></td></tr></table></figure><h5 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_lock &#x3D; [[NSLock alloc]init];&#x2F;&#x2F;创建</span><br><span class="line">[_lock lock];&#x2F;&#x2F;锁住</span><br><span class="line">&#x2F;&#x2F;执行代码区域  </span><br><span class="line"></span><br><span class="line">[_lock unlock];&#x2F;&#x2F;解锁</span><br></pre></td></tr></table></figure><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h5><blockquote><p>一个对象层面的锁,锁住整个对象,底层使用了互斥递归锁来实现;<br>常用在单例的创建  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+(Common *)sharedInstance&#123;</span><br><span class="line">static Common *common &#x3D; nil;</span><br><span class="line">@synchronized (common) &#123;</span><br><span class="line">    if (common &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        common &#x3D; [[Common alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景:"></a>模拟场景:</h4><blockquote><p>火车站某趟列车的票数销售.<br>说明:总票数固定,会出现同时在销售的情况,但是销售的余额票数不能构成混乱;    </p></blockquote><p>NSLock为例<br>不使用线程锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t q1 &#x3D; dispatch_queue_create(&quot;q1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    _lock &#x3D; [[NSLock alloc]init];</span><br><span class="line">    _allCount &#x3D; 20;&#x2F;&#x2F;火车站总票数</span><br><span class="line">    for (NSUInteger i &#x3D; 0; i &lt; 5; i++) &#123;&#x2F;&#x2F;开启5个线程</span><br><span class="line">        dispatch_async(q1, ^&#123;</span><br><span class="line">            &#x2F;&#x2F;模拟不同销售途径来销售火车票,火车票总数是固定,不能造成票数混乱;</span><br><span class="line">            while (1) &#123;</span><br><span class="line">&#x2F;&#x2F;                [_lock lock];</span><br><span class="line">                if (_allCount &gt; 0) &#123;</span><br><span class="line">                    _allCount --;</span><br><span class="line">                    NSLog(@&quot;当前线程(销售途径):%@,当前票数:%lu&quot;,[NSThread currentThread],(unsigned long)_allCount);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    [_lock unlock];</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">&#x2F;&#x2F;                [_lock unlock];</span><br><span class="line">                [NSThread sleepForTimeInterval:0.5];&#x2F;&#x2F;当前线程休眠0.5秒</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">打印日志:数据造成各种混乱</span><br><span class="line">2020-04-10 11:34:19.218613+0800 Dispatch(线程安全)[27226:1143704] 当前线程(销售途径):&lt;NSThread: 0x600003d19880&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:18</span><br><span class="line">2020-04-10 11:34:19.218694+0800 Dispatch(线程安全)[27226:1143702] 当前线程(销售途径):&lt;NSThread: 0x600003d149c0&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;,当前票数:19</span><br><span class="line">2020-04-10 11:34:19.218746+0800 Dispatch(线程安全)[27226:1143711] 当前线程(销售途径):&lt;NSThread: 0x600003d0a440&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:16</span><br><span class="line">2020-04-10 11:34:19.218746+0800 Dispatch(线程安全)[27226:1143703] 当前线程(销售途径):&lt;NSThread: 0x600003d1e400&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;,当前票数:17</span><br><span class="line">2020-04-10 11:34:19.220135+0800 Dispatch(线程安全)[27226:1143705] 当前线程(销售途径):&lt;NSThread: 0x600003d158c0&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;,当前票数:15</span><br><span class="line">2020-04-10 11:34:19.720263+0800 Dispatch(线程安全)[27226:1143702] 当前线程(销售途径):&lt;NSThread: 0x600003d149c0&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;,当前票数:14</span><br><span class="line">2020-04-10 11:34:19.720263+0800 Dispatch(线程安全)[27226:1143704] 当前线程(销售途径):&lt;NSThread: 0x600003d19880&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:14</span><br><span class="line">2020-04-10 11:34:19.720262+0800 Dispatch(线程安全)[27226:1143711] 当前线程(销售途径):&lt;NSThread: 0x600003d0a440&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:13</span><br><span class="line">2020-04-10 11:34:19.722770+0800 Dispatch(线程安全)[27226:1143703] 当前线程(销售途径):&lt;NSThread: 0x600003d1e400&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;,当前票数:12</span><br><span class="line">2020-04-10 11:34:19.722770+0800 Dispatch(线程安全)[27226:1143705] 当前线程(销售途径):&lt;NSThread: 0x600003d158c0&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;,当前票数:12</span><br><span class="line">2020-04-10 11:34:20.224261+0800 Dispatch(线程安全)[27226:1143711] 当前线程(销售途径):&lt;NSThread: 0x600003d0a440&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:11</span><br><span class="line">2020-04-10 11:34:20.224261+0800 Dispatch(线程安全)[27226:1143702] 当前线程(销售途径):&lt;NSThread: 0x600003d149c0&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;,当前票数:10</span><br><span class="line">2020-04-10 11:34:20.224261+0800 Dispatch(线程安全)[27226:1143704] 当前线程(销售途径):&lt;NSThread: 0x600003d19880&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:9</span><br><span class="line">2020-04-10 11:34:20.225632+0800 Dispatch(线程安全)[27226:1143703] 当前线程(销售途径):&lt;NSThread: 0x600003d1e400&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;,当前票数:8</span><br><span class="line">2020-04-10 11:34:20.225670+0800 Dispatch(线程安全)[27226:1143705] 当前线程(销售途径):&lt;NSThread: 0x600003d158c0&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;,当前票数:7</span><br><span class="line">2020-04-10 11:34:20.729091+0800 Dispatch(线程安全)[27226:1143702] 当前线程(销售途径):&lt;NSThread: 0x600003d149c0&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;,当前票数:5</span><br><span class="line">2020-04-10 11:34:20.729038+0800 Dispatch(线程安全)[27226:1143704] 当前线程(销售途径):&lt;NSThread: 0x600003d19880&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:6</span><br><span class="line">2020-04-10 11:34:20.729094+0800 Dispatch(线程安全)[27226:1143711] 当前线程(销售途径):&lt;NSThread: 0x600003d0a440&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:4</span><br><span class="line">2020-04-10 11:34:20.729128+0800 Dispatch(线程安全)[27226:1143705] 当前线程(销售途径):&lt;NSThread: 0x600003d158c0&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;,当前票数:3</span><br><span class="line">2020-04-10 11:34:20.729128+0800 Dispatch(线程安全)[27226:1143703] 当前线程(销售途径):&lt;NSThread: 0x600003d1e400&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;,当前票数:2</span><br><span class="line">2020-04-10 11:34:21.230992+0800 Dispatch(线程安全)[27226:1143711] 当前线程(销售途径):&lt;NSThread: 0x600003d0a440&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:0</span><br><span class="line">2020-04-10 11:34:21.230992+0800 Dispatch(线程安全)[27226:1143704] 当前线程(销售途径):&lt;NSThread: 0x600003d19880&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:0</span><br></pre></td></tr></table></figure><p>使用线程锁:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t q1 &#x3D; dispatch_queue_create(&quot;q1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    _lock &#x3D; [[NSLock alloc]init];</span><br><span class="line">    _allCount &#x3D; 20;&#x2F;&#x2F;火车站总票数</span><br><span class="line">    for (NSUInteger i &#x3D; 0; i &lt; 5; i++) &#123;&#x2F;&#x2F;开启5个线程</span><br><span class="line">        dispatch_async(q1, ^&#123;</span><br><span class="line">            &#x2F;&#x2F;模拟不同销售途径来销售火车票,火车票总数是固定,不能造成票数混乱;</span><br><span class="line">            while (1) &#123;</span><br><span class="line">                [_lock lock];</span><br><span class="line">                if (_allCount &gt; 0) &#123;</span><br><span class="line">                    _allCount --;</span><br><span class="line">                    NSLog(@&quot;当前线程(销售途径):%@,当前票数:%lu&quot;,[NSThread currentThread],(unsigned long)_allCount);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    [_lock unlock];</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                [_lock unlock];</span><br><span class="line">                [NSThread sleepForTimeInterval:0.5];&#x2F;&#x2F;当前线程休眠0.5秒</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">日志:数据正常  </span><br><span class="line">2020-04-10 11:37:38.510142+0800 Dispatch(线程安全)[27257:1146071] 当前线程(销售途径):&lt;NSThread: 0x6000010e0900&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;,当前票数:19</span><br><span class="line">2020-04-10 11:37:38.510377+0800 Dispatch(线程安全)[27257:1146069] 当前线程(销售途径):&lt;NSThread: 0x600001093640&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:18</span><br><span class="line">2020-04-10 11:37:38.510551+0800 Dispatch(线程安全)[27257:1146070] 当前线程(销售途径):&lt;NSThread: 0x6000010ee380&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;,当前票数:17</span><br><span class="line">2020-04-10 11:37:38.510758+0800 Dispatch(线程安全)[27257:1146077] 当前线程(销售途径):&lt;NSThread: 0x6000010fae00&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:16</span><br><span class="line">2020-04-10 11:37:38.510920+0800 Dispatch(线程安全)[27257:1146067] 当前线程(销售途径):&lt;NSThread: 0x60000109bc80&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;,当前票数:15</span><br><span class="line">2020-04-10 11:37:39.015058+0800 Dispatch(线程安全)[27257:1146069] 当前线程(销售途径):&lt;NSThread: 0x600001093640&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:14</span><br><span class="line">2020-04-10 11:37:39.015466+0800 Dispatch(线程安全)[27257:1146071] 当前线程(销售途径):&lt;NSThread: 0x6000010e0900&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;,当前票数:13</span><br><span class="line">2020-04-10 11:37:39.015826+0800 Dispatch(线程安全)[27257:1146070] 当前线程(销售途径):&lt;NSThread: 0x6000010ee380&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;,当前票数:12</span><br><span class="line">2020-04-10 11:37:39.016035+0800 Dispatch(线程安全)[27257:1146077] 当前线程(销售途径):&lt;NSThread: 0x6000010fae00&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:11</span><br><span class="line">2020-04-10 11:37:39.016242+0800 Dispatch(线程安全)[27257:1146067] 当前线程(销售途径):&lt;NSThread: 0x60000109bc80&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;,当前票数:10</span><br><span class="line">2020-04-10 11:37:39.519114+0800 Dispatch(线程安全)[27257:1146070] 当前线程(销售途径):&lt;NSThread: 0x6000010ee380&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;,当前票数:9</span><br><span class="line">2020-04-10 11:37:39.519408+0800 Dispatch(线程安全)[27257:1146071] 当前线程(销售途径):&lt;NSThread: 0x6000010e0900&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;,当前票数:8</span><br><span class="line">2020-04-10 11:37:39.519728+0800 Dispatch(线程安全)[27257:1146067] 当前线程(销售途径):&lt;NSThread: 0x60000109bc80&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;,当前票数:7</span><br><span class="line">2020-04-10 11:37:39.520054+0800 Dispatch(线程安全)[27257:1146069] 当前线程(销售途径):&lt;NSThread: 0x600001093640&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:6</span><br><span class="line">2020-04-10 11:37:39.520262+0800 Dispatch(线程安全)[27257:1146077] 当前线程(销售途径):&lt;NSThread: 0x6000010fae00&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:5</span><br><span class="line">2020-04-10 11:37:40.020898+0800 Dispatch(线程安全)[27257:1146071] 当前线程(销售途径):&lt;NSThread: 0x6000010e0900&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;,当前票数:4</span><br><span class="line">2020-04-10 11:37:40.021315+0800 Dispatch(线程安全)[27257:1146070] 当前线程(销售途径):&lt;NSThread: 0x6000010ee380&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;,当前票数:3</span><br><span class="line">2020-04-10 11:37:40.021709+0800 Dispatch(线程安全)[27257:1146067] 当前线程(销售途径):&lt;NSThread: 0x60000109bc80&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125;,当前票数:2</span><br><span class="line">2020-04-10 11:37:40.021944+0800 Dispatch(线程安全)[27257:1146069] 当前线程(销售途径):&lt;NSThread: 0x600001093640&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;,当前票数:1</span><br><span class="line">2020-04-10 11:37:40.022108+0800 Dispatch(线程安全)[27257:1146077] 当前线程(销售途径):&lt;NSThread: 0x6000010fae00&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;,当前票数:0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 线程安全 </tag>
            
            <tag> 线程锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作真机.ipa安装包</title>
      <link href="/2020/04/08/%E5%88%B6%E4%BD%9Cipa%E5%AE%89%E8%A3%85%E5%8C%85/"/>
      <url>/2020/04/08/%E5%88%B6%E4%BD%9Cipa%E5%AE%89%E8%A3%85%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><strong>前提条件:</strong>  </p><blockquote><p>1,需要安装对应app证书;<br>2,证书包含需要安装设备的udid;  </p></blockquote><h4 id="第一种-xcode直接build"><a href="#第一种-xcode直接build" class="headerlink" title="第一种  xcode直接build"></a>第一种  xcode直接build</h4><blockquote><p>选择真机,然后build工程,点击.app后缀文件show in finder, 把里面文件拷贝出来<br>放到文件夹名字为:Payload的文件夹中(自己创建),然后压缩成zip<br>把zip后缀改成ipa,即可安装;  </p></blockquote><h4 id="第二种-xcode先archive"><a href="#第二种-xcode先archive" class="headerlink" title="第二种  xcode先archive"></a>第二种  xcode先archive</h4><p><a href="https://zhuyunsun.github.io/2017/05/04/%E6%AD%A3%E7%A1%AE%E5%AF%BC%E5%87%BA%E4%B8%8A%E6%9E%B6ipa%E5%8C%85/" target="_blank" rel="noopener">之前博客有介绍(点击)</a>  </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> ipa包 </tag>
            
            <tag> 真机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC中的常量和变量</title>
      <link href="/2020/03/25/iOS%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"/>
      <url>/2020/03/25/iOS%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量就是初始化定义之后可以进行修改的实例对象.<br>变量又分为全局变量和局部变量.<br>不赋值的时候默认为0或者空值. <a id="more"></a><br>如:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Int a &#x3D; 1;</span><br><span class="line">a &#x3D; 2;</span><br><span class="line">Int b;</span><br></pre></td></tr></table></figure><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>1,函数外部进行声明.<br>2,可以跨文件进行访问.<br>3,可以在声明的时候进行赋值.<br>4,声明的时候,如果不赋值默认为空值.<br>5,存储的位置不是栈区也不是堆区,而是在专门:全局静态存储区.<br>6,程序启动就分配内存,直到程序结束才会释放;</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>写在代码块或者函数之中;<br>作用域:从创建那一刻开始一直遇到大括号}或者return;<br>可以先定义再初始化,也可以在定义的时候初始化;<br>存储在栈区,由系统进行管理;<br>会在函数结束后释放;  </p><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>写在类声明的大括号内变量叫成员变量(也叫<strong>属性/实例变量</strong>)<br>不能再定义的时候进行初始化;<br>只能通过对象来进行访问;<br>存储于堆中(当前对象的堆对应的存储空间),需要程序员手动进行管理(引用计数);  </p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>一旦定义,不能修改的实例.<br>使用const关键字进行修饰.<br>结合static和extern关键字来使用;</p><h5 id="静态局部常量"><a href="#静态局部常量" class="headerlink" title="静态局部常量"></a>静态局部常量</h5><p>写在代码块或者函数之中;<br>static修饰:静态局部常量<br>只会初始化一次,只有一份内存,延长变量或者常量的生命周期,直到程序结束才被销毁;   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static NSString *const game1 &#x3D; @&quot;game1&quot;;  </span><br><span class="line">&#x2F;&#x2F;game1不可被修改, *game1可以被修改</span><br><span class="line">static const NSString *game2 &#x3D; @&quot;game2&quot;;</span><br><span class="line">static NSString const *game3 &#x3D; @&quot;game3&quot;;</span><br><span class="line">&#x2F;&#x2F;*game2和*game3不可被修改,他们是一样的</span><br><span class="line">&#x2F;&#x2F;game2和game3可以被修改;</span><br></pre></td></tr></table></figure><p>const修饰的右边总是不能被修改;</p><h5 id="全局静态常量"><a href="#全局静态常量" class="headerlink" title="全局静态常量"></a>全局静态常量</h5><p>声明在函数外部<br>在类.h中声明可以被导入的类进行引用;<br>在类.m中声明则只能在该类中使用;  </p><h5 id="extern修饰全局常量"><a href="#extern修饰全局常量" class="headerlink" title="extern修饰全局常量"></a>extern修饰全局常量</h5><p>在.h声明:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern float const age;</span><br></pre></td></tr></table></figure><p>在.m中赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float const age &#x3D; 10;</span><br></pre></td></tr></table></figure><p>需要导入该类才能引用;  </p><p>extern也可以修饰全局变量;  </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 常量const </tag>
            
            <tag> 变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC常用</title>
      <link href="/2019/07/31/%20OC%E5%B8%B8%E7%94%A8/"/>
      <url>/2019/07/31/%20OC%E5%B8%B8%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="iOS14获取idfa"><a href="#iOS14获取idfa" class="headerlink" title="iOS14获取idfa"></a>iOS14获取idfa</h3><p>1,添加系统库:AppTrackingTransparency.framework  <a id="more"></a><br>2,Xcode工程中Info.plist权限配置:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Privacy - Tracking Usage Description  : 需要你允许使用广告标识符,以便追踪广告信息和推送.  </span><br><span class="line">或</span><br><span class="line">NSUserTrackingUsageDescription : 需要你允许使用广告标识符,以便追踪广告信息和推送.</span><br></pre></td></tr></table></figure><p>3,头文件和代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__IPHONE_14_0)</span><br><span class="line">#import &lt;AppTrackingTransparency&#x2F;AppTrackingTransparency.h&gt;&#x2F;&#x2F;适配iOS14</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">关于权限弹窗:每一个不同包名的APP只会在首次安装时弹出,无论是否允许追踪,下次要允许时,需要去(设置-隐私-允许隐私跟踪)进行设置;</span><br><span class="line">测试时,需要每次换不同的包名进行测试.  </span><br><span class="line">*&#x2F;</span><br><span class="line">if (@available(iOS 14, *)) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用该段代码时,会有权限弹窗弹出.</span><br><span class="line">    [ATTrackingManager requestTrackingAuthorizationWithCompletionHandler:^(ATTrackingManagerAuthorizationStatus status) &#123;</span><br><span class="line">      NSLog(@&quot;Status: %lu&quot;, (unsigned long)status);</span><br><span class="line">        if (status &#x3D;&#x3D; ATTrackingManagerAuthorizationStatusAuthorized) &#123;</span><br><span class="line">            NSLog(@&quot;用户允许&quot;);</span><br><span class="line">            NSString *idfa &#x3D; [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;用户不允许&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;OS14下的idfa&quot;);</span><br><span class="line">    NSString *idfa &#x3D; [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iOS14以下的系统直接即可获取到idfa,不需要权限控制.  </p><h3 id="Xcode自动配置证书出现”XXXX-has-conflicting-provisioning-settings”"><a href="#Xcode自动配置证书出现”XXXX-has-conflicting-provisioning-settings”" class="headerlink" title="Xcode自动配置证书出现”XXXX has conflicting provisioning settings”"></a>Xcode自动配置证书出现”XXXX has conflicting provisioning settings”</h3><p>手动导入证书和自动管理的证书导致的冲突</p><blockquote><p>“XXXX is automatically signed,but provisioning profile 45551591-2d82-4cc3-a2b7-99838c6700b3 has been manually specified. Set the provisioning profile value to “Automatic” in the build settings editor,or switch to manual signing in the project editor.”</p></blockquote><p>解决方法:打开project.pbxproj文件,查找45551591-2d82-4cc3-a2b7-99838c6700b3并删除即可</p><h3 id="Mac电脑显示隐藏文件"><a href="#Mac电脑显示隐藏文件" class="headerlink" title="Mac电脑显示隐藏文件"></a>Mac电脑显示隐藏文件</h3><p>(commond + shift + . ) 按一次则是显示,再按一次则是隐藏</p><h3 id="Xcode12后出现静态库-linked-library-‘libPods-xxx-a‘-is-missing-one-or-more-architectures-required-by-this-target-armv7"><a href="#Xcode12后出现静态库-linked-library-‘libPods-xxx-a‘-is-missing-one-or-more-architectures-required-by-this-target-armv7" class="headerlink" title="Xcode12后出现静态库 linked library ‘libPods-xxx.a‘ is missing one or more architectures required by this target: armv7"></a>Xcode12后出现静态库 linked library ‘libPods-xxx.a‘ is missing one or more architectures required by this target: armv7</h3><p>能正常真机测试，但build的时候会失败（红色警告）<br>升级xcode12后，项目在run debug时候是正常运行的，但是在build或者run release的时候就会出现如标题的红色错误。<br>在Target-Build Settings-Excluded Architectures中添加以下代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXCLUDED_ARCHS__EFFECTIVE_PLATFORM_SUFFIX_simulator__NATIVE_ARCH_64_BIT_x86_64&#x3D;arm64 arm64e armv7 armv7s armv6 armv8 EXCLUDED_ARCHS&#x3D;$(inherited) $(EXCLUDED_ARCHS__EFFECTIVE_PLATFORM_SUFFIX_$(EFFECTIVE_PLATFORM_SUFFIX)__NATIVE_ARCH_64_BIT_$(NATIVE_ARCH_64_BIT))</span><br></pre></td></tr></table></figure><h3 id="真机测试包Payload"><a href="#真机测试包Payload" class="headerlink" title="真机测试包Payload"></a>真机测试包Payload</h3><p>出一个支持真机安装的xxx.ipa包<br>1,在xcode工程中,安装支持准备安装设备的证书和描述文件;<br>2,xcode中选择真机,Build工程,在Products文件中找到后缀为xxx.app文件<br>3,show in finder,copy一下xxx.app格式的文件;<br>4,在桌面创建名为Payload的文件夹,把xxx.app复制进去;<br>5,压缩Payload文件夹为Payload.zip<br>6,把Payload.zip修改为Payload.ipa,这个时候就是可以进行安装的ipa包了.<br>最后,可以使用xcode工具或者iTools进行安装ipa包;</p><h3 id="书写block时"><a href="#书写block时" class="headerlink" title="书写block时"></a>书写block时</h3><p>判断block为非空时,再进行赋值;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (self.block) &#123;</span><br><span class="line">    self.block(viewImage,str,location2D);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Errors-were-encountered-while-preparing-your-device-for-development-Please-check-the-Devices-and-Simulators-Window"><a href="#Errors-were-encountered-while-preparing-your-device-for-development-Please-check-the-Devices-and-Simulators-Window" class="headerlink" title="Errors were encountered while preparing your device for development. Please check the Devices and Simulators Window."></a>Errors were encountered while preparing your device for development. Please check the Devices and Simulators Window.</h3><p>方法:<br>1,重启手机<br>2,还不行的话,在手机设置中 Developer-》clear Trusted computers,重新设置信任电脑试试  </p><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GitHub Desktop 使用</span><br><span class="line">1,创建repository:选择本地某个文件夹作为一个repository,称为r1,然后push到自己GitHub账号上面;</span><br><span class="line">2,修改:本地r1的文件,修改完之后,在GitHub Desktop把最新版本推送到GitHub;</span><br><span class="line">3,回滚版本,在GitHub Desktop History选择某个版本,回滚的时候修改的是r1里面的文件</span><br><span class="line">  GitHub没有修改,需要commit-&gt;Fetch origin;</span><br><span class="line">4,注意,不要去修改GitHub上面repository工程文件;</span><br><span class="line"></span><br><span class="line">5,⌘⇧.(Command + Shift + .)来查看当前文件夹是否有其他管理的.git,把他删除,不然无法添加到GitHub.</span><br></pre></td></tr></table></figure><h3 id="NSBundle-initWithURL-nil-URL-argument’"><a href="#NSBundle-initWithURL-nil-URL-argument’" class="headerlink" title="-[NSBundle initWithURL:]: nil URL argument’"></a>-[NSBundle initWithURL:]: nil URL argument’</h3><p>某个资源包.bundle没有导入到工程中</p><h3 id="向工程中添加第三方字体"><a href="#向工程中添加第三方字体" class="headerlink" title="向工程中添加第三方字体"></a>向工程中添加第三方字体</h3><p>1,把字体添加到Xcode中形如:A-OTF-FOLKPRO-MEDIUM.OTF 的文件<br>2,在Info.plist配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一个数组,Fonts provided by application</span><br><span class="line">&lt;key&gt;UIAppFonts&lt;&#x2F;key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;A-OTF-FOLKPRO-MEDIUM.OTF&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;array&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用, [UIFont familyNames]获取当前工程中存在的字体字段</span><br><span class="line">if ([[UIFont familyNames] containsObject:@&quot;A-OTF Folk Pro&quot;]) &#123;</span><br><span class="line">    NSLog(@&quot;导入字体成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    NSLog(@&quot;导入字体失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SF-Symbols中的图标"><a href="#SF-Symbols中的图标" class="headerlink" title="SF Symbols中的图标"></a>SF Symbols中的图标</h3><p>iOS13以后可以使用:UIImage *image = [UIImage systemImageNamed:@”mic”];<br>默认图标颜色是蓝色,修改颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">UIImage *image &#x3D; [UIImage systemImageNamed:@&quot;mic&quot;];</span><br><span class="line">UIImageView *showImage &#x3D; [[UIImageView alloc]init];</span><br><span class="line">showImage.frame &#x3D; CGRectMake(100, 200, 20, 20);</span><br><span class="line">showImage.image &#x3D; image;</span><br><span class="line">showImage.tintColor &#x3D; [UIColor blackColor];&#x2F;&#x2F;设置SF展示图片颜色</span><br><span class="line">showImage.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">[self.view addSubview:showImage];</span><br></pre></td></tr></table></figure><h3 id="xcode导出设备crash日志"><a href="#xcode导出设备crash日志" class="headerlink" title="xcode导出设备crash日志"></a>xcode导出设备crash日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设备能在xcode上安装app,才能正确导出日志</span><br></pre></td></tr></table></figure><h3 id="跳转App-store-对应的app"><a href="#跳转App-store-对应的app" class="headerlink" title="跳转App store 对应的app"></a>跳转App store 对应的app</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;形如</span><br><span class="line">https:&#x2F;&#x2F;itunes.apple.com&#x2F;app&#x2F;apple-store&#x2F;idxxxxxxxx?mt&#x3D;8</span><br><span class="line">&#x2F;&#x2F;例如百度</span><br><span class="line">https:&#x2F;&#x2F;itunes.apple.com&#x2F;app&#x2F;apple-store&#x2F;id452186370?mt&#x3D;8</span><br></pre></td></tr></table></figure><h3 id="关于读取bundle资源中的图片"><a href="#关于读取bundle资源中的图片" class="headerlink" title="关于读取bundle资源中的图片"></a>关于读取bundle资源中的图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;bundle资源中保存不同的@2x,@3x等,使用如下方法会自动读取是使用2x还是3x</span><br><span class="line">NSString *path&#x3D; [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@&quot;GolfBundle.bundle&#x2F;dz16.png&quot;];&#x2F;&#x2F;会自动识别bundle中@2x,@3x图片</span><br></pre></td></tr></table></figure><h3 id="获取当前加载图片的像素px"><a href="#获取当前加载图片的像素px" class="headerlink" title="获取当前加载图片的像素px"></a>获取当前加载图片的像素px</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGFloat w &#x3D; CGImageGetWidth(i2.CGImage);</span><br><span class="line">CGFloat h &#x3D; CGImageGetHeight(i2.CGImage);</span><br><span class="line">&#x2F;&#x2F;i2是UIImage实例对象</span><br></pre></td></tr></table></figure><h3 id="设置导航栏颜色和title字体"><a href="#设置导航栏颜色和title字体" class="headerlink" title="设置导航栏颜色和title字体"></a>设置导航栏颜色和title字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;AppDelegate.m中</span><br><span class="line">[[UINavigationBar appearance] setBarTintColor:[UIColor greenColor]];</span><br><span class="line">[[UINavigationBar appearance] setTitleTextAttributes:@&#123;NSForegroundColorAttributeName:[UIColor blueColor]&#125;];</span><br><span class="line">&#x2F;&#x2F;在对应的ViewController中,修改之后,所有的导航栏都会被改变.</span><br><span class="line">self.navigationController.navigationBar.barTintColor &#x3D; [UIColor greenColor];</span><br><span class="line">self.navigationController.navigationBar.titleTextAttributes &#x3D; @&#123;NSForegroundColorAttributeName:[UIColor blueColor]&#125;;</span><br></pre></td></tr></table></figure><h3 id="iOS13处理通知token值"><a href="#iOS13处理通知token值" class="headerlink" title="iOS13处理通知token值"></a>iOS13处理通知token值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取DeviceToken成功</span><br><span class="line">- (void)application:(UIApplication *)application</span><br><span class="line">didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;Xcode11打的包，iOS13获取Token有变化</span><br><span class="line">    if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;&#x3D; 13) &#123;</span><br><span class="line">        if (![deviceToken isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">            &#x2F;&#x2F;记录获取token失败的描述</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        const unsigned *tokenBytes &#x3D; (const unsigned *)[deviceToken bytes];</span><br><span class="line">        NSString *strToken &#x3D; [NSString stringWithFormat:@&quot;%08x%08x%08x%08x%08x%08x%08x%08x&quot;,</span><br><span class="line">                              ntohl(tokenBytes[0]), ntohl(tokenBytes[1]), ntohl(tokenBytes[2]),</span><br><span class="line">                              ntohl(tokenBytes[3]), ntohl(tokenBytes[4]), ntohl(tokenBytes[5]),</span><br><span class="line">                              ntohl(tokenBytes[6]), ntohl(tokenBytes[7])];</span><br><span class="line">        NSLog(@&quot;deviceToken1:%@&quot;, strToken);</span><br><span class="line">        return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSString *token &#x3D; [NSString</span><br><span class="line">                       stringWithFormat:@&quot;%@&quot;,deviceToken];</span><br><span class="line">        token &#x3D; [token stringByReplacingOccurrencesOfString:@&quot;&lt;&quot; withString:@&quot;&quot;];</span><br><span class="line">        token &#x3D; [token stringByReplacingOccurrencesOfString:@&quot;&gt;&quot; withString:@&quot;&quot;];</span><br><span class="line">        token &#x3D; [token stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];</span><br><span class="line">        NSLog(@&quot;deviceToken2 is: %@&quot;, token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串和数组-字典之间的相互转换"><a href="#字符串和数组-字典之间的相互转换" class="headerlink" title="字符串和数组,字典之间的相互转换"></a>字符串和数组,字典之间的相互转换</h3><p>NSData作为中间键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;字典或者数组转字符串  </span><br><span class="line">NSData * newOne &#x3D; [myString dataUsingEncoding:NSUTF8StringEncoding];  </span><br><span class="line">id content &#x3D; [NSJSONSerialization JSONObjectWithData:newOne options:NSJSONReadingMutableContainers error:nil];  </span><br><span class="line">&#x2F;&#x2F;字符串(本身原来是字典或者是数组)转字典或者数组  </span><br><span class="line">NSData * jsonData &#x3D; [NSJSONSerialization dataWithJSONObject:myObject options:NSJSONWritingPrettyPrinted error:nil];</span><br><span class="line">NSString * string &#x3D; [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br></pre></td></tr></table></figure><h3 id="比较稳定判断iPhoneX全面屏系列"><a href="#比较稳定判断iPhoneX全面屏系列" class="headerlink" title="比较稳定判断iPhoneX全面屏系列"></a>比较稳定判断iPhoneX全面屏系列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 是否是iPhoneX全面屏系列</span><br><span class="line">FOUNDATION_STATIC_INLINE BOOL MYPhoneX()&#123;</span><br><span class="line">    BOOL IS_iPhone &#x3D; ([[UIDevice currentDevice] userInterfaceIdiom] &#x3D;&#x3D; UIUserInterfaceIdiomPhone);&#x2F;&#x2F;是iPhone不是iPad</span><br><span class="line">    BOOL IS_iOS11 &#x3D; ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;&#x3D; 11.f);&#x2F;&#x2F;全面屏iOS11以上才有</span><br><span class="line">    BOOL iPhoneX &#x3D; (IS_iOS11 &amp;&amp; IS_iPhone &amp;&amp; (MIN([UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) &gt;&#x3D; 375 &amp;&amp; MAX([UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) &gt;&#x3D; 812));&#x2F;&#x2F;后面min和max是判断横竖屏宽和高</span><br><span class="line">    return iPhoneX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置CGSize常量值"><a href="#设置CGSize常量值" class="headerlink" title="设置CGSize常量值"></a>设置CGSize常量值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line">CG_EXTERN  CGSize const MySize;</span><br><span class="line">.m</span><br><span class="line">CGSize const MySize &#x3D; &#123;3.0,2.0&#125;;</span><br></pre></td></tr></table></figure><h3 id="pod用法示例"><a href="#pod用法示例" class="headerlink" title="pod用法示例"></a>pod用法示例</h3><blockquote><p>cd 工程目录<br>vim Podfile<br>按esc退出编辑<br>:wq 保存<br>pod install  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;#turk</span><br><span class="line">platform:ios, &#39;10.0&#39; #最低版本</span><br><span class="line">inhibit_all_warnings! #忽略第三方警告</span><br><span class="line">target &#39;xxx&#39; do #target对应的名称</span><br><span class="line">pod &#39;xxxxx&#39;, &#39;~&gt; 1.1.1&#39; #第三方库名称</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="卡在pod-install-xxx"><a href="#卡在pod-install-xxx" class="headerlink" title="卡在pod install xxx"></a>卡在pod install xxx</h4><blockquote><p>使用:  pod install –verbose –no-repo-update 命令  </p></blockquote><h4 id="truk报错"><a href="#truk报错" class="headerlink" title="truk报错"></a>truk报错</h4><blockquote><p>终端执行命令:pod repo remove trunk</p></blockquote><h3 id="UITableView部分设置"><a href="#UITableView部分设置" class="headerlink" title="UITableView部分设置"></a>UITableView部分设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;去掉cell之间的下划线</span><br><span class="line">self.menuTableView.separatorStyle &#x3D; UITableViewCellSeparatorStyleNone;</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>URL包含中文时候必要的转码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;编码</span><br><span class="line">NSString *charactersToEscape &#x3D; @&quot;?!@#$^&amp;%*+,:;&#x3D;&#39;\&quot;&#96;&lt;&gt;()[]&#123;&#125;&#x2F;\\| &quot;;</span><br><span class="line">NSCharacterSet *allowedCharacters &#x3D; [[NSCharacterSet characterSetWithCharactersInString:charactersToEscape] invertedSet];</span><br><span class="line">NSString *encodedUrl &#x3D; [aes stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters];  </span><br><span class="line"></span><br><span class="line">NSString *new &#x3D; [encodedUrl stringByRemovingPercentEncoding];&#x2F;&#x2F;解码</span><br></pre></td></tr></table></figure><h3 id="横竖屏判断"><a href="#横竖屏判断" class="headerlink" title="横竖屏判断"></a>横竖屏判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UIInterfaceOrientation currentOrientation &#x3D; [[UIApplication sharedApplication] statusBarOrientation];</span><br><span class="line">if(UIInterfaceOrientationIsPortrait(currentOrientation) &#x3D;&#x3D; YES)&#123;</span><br><span class="line">    NSLog(@&quot;当前为竖屏1&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    NSLog(@&quot;横屏&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Find-Regular-Expression-查找xcode中所有中文"><a href="#Find-Regular-Expression-查找xcode中所有中文" class="headerlink" title="Find(Regular Expression)查找xcode中所有中文:"></a>Find(Regular Expression)查找xcode中所有中文:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;[^&quot;]*[\u4E00-\u9FA5]+[^&quot;\n]*?&quot;</span><br></pre></td></tr></table></figure><h3 id="前往xcode证书路径"><a href="#前往xcode证书路径" class="headerlink" title="前往xcode证书路径"></a>前往xcode证书路径</h3><p>~/Library/MobileDevice/Provisioning Profiles</p><h3 id="UIButton文字靠左"><a href="#UIButton文字靠左" class="headerlink" title="UIButton文字靠左"></a>UIButton文字靠左</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forgetBtn.contentHorizontalAlignment &#x3D; UIControlContentHorizontalAlignmentLeft;</span><br><span class="line">forgetBtn.titleEdgeInsets &#x3D; UIEdgeInsetsMake(0,0, 0, 0);</span><br></pre></td></tr></table></figure><h3 id="UITextFiled-左边留出空隙"><a href="#UITextFiled-左边留出空隙" class="headerlink" title="UITextFiled 左边留出空隙"></a>UITextFiled 左边留出空隙</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView * viewLeft1 &#x3D; [[UIView alloc]initWithFrame:CGRectMake(0, 0, 5, 5)];</span><br><span class="line">filed.leftView &#x3D; viewLeft1;</span><br><span class="line">filed.leftViewMode &#x3D; UITextFieldViewModeAlways;</span><br></pre></td></tr></table></figure><h3 id="设置父视图透明度-不改变子视图透明度"><a href="#设置父视图透明度-不改变子视图透明度" class="headerlink" title="设置父视图透明度,不改变子视图透明度"></a>设置父视图透明度,不改变子视图透明度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在父视图上设置:  </span><br><span class="line">self.view.backgroundColor&#x3D;[[UIColor blackColor]colorWithAlphaComponent:0.5];</span><br></pre></td></tr></table></figure><h3 id="UITextFiled-首字母不大写"><a href="#UITextFiled-首字母不大写" class="headerlink" title="UITextFiled 首字母不大写"></a>UITextFiled 首字母不大写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[filed setAutocapitalizationType:UITextAutocapitalizationTypeNone];</span><br></pre></td></tr></table></figure><h3 id="重签名教程地址"><a href="#重签名教程地址" class="headerlink" title="重签名教程地址"></a><a href="http://blog.hudongdong.com/skill/363.html" target="_blank" rel="noopener">重签名教程地址</a></h3><h3 id="设置WKWebView-背景色"><a href="#设置WKWebView-背景色" class="headerlink" title="设置WKWebView 背景色"></a>设置WKWebView 背景色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.myWebView setOpaque:NO];</span><br><span class="line">self.myWebView.backgroundColor &#x3D; [UIColor blackColor];</span><br></pre></td></tr></table></figure><h3 id="代码块声明-lt-state-gt"><a href="#代码块声明-lt-state-gt" class="headerlink" title="代码块声明 &lt;#state#&gt;"></a>代码块声明 &lt;#state#&gt;</h3><h3 id="iPhone-X-相关1"><a href="#iPhone-X-相关1" class="headerlink" title="iPhone X 相关1"></a>iPhone X 相关1</h3><blockquote><p>顶部:44(导航栏)-44(状态栏+圆弧部分);<br>底部:49(导航栏)-34(圆弧部分);    </p></blockquote><h3 id="iOS13-vc-present方式改回之前"><a href="#iOS13-vc-present方式改回之前" class="headerlink" title="iOS13 vc present方式改回之前"></a>iOS13 vc present方式改回之前</h3><blockquote><p>naVC.modalPresentationStyle = UIModalPresentationFullScreen;<br>naVC被推出来的vc</p></blockquote><h3 id="默认选中某个cell"><a href="#默认选中某个cell" class="headerlink" title="默认选中某个cell"></a>默认选中某个cell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认选中某个cell</span><br><span class="line">NSIndexPath *selectIndex &#x3D; [NSIndexPath indexPathForRow:0 inSection:0];</span><br><span class="line">[_leftTableView selectRowAtIndexPath:selectIndex animated:YES scrollPosition:UITableViewScrollPositionNone];</span><br></pre></td></tr></table></figure><h3 id="判断是否是iphoneX-刘海-不算精准"><a href="#判断是否是iphoneX-刘海-不算精准" class="headerlink" title="判断是否是iphoneX(刘海),不算精准."></a>判断是否是iphoneX(刘海),不算精准.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_STATIC_INLINE BOOL FDIS_IPHONEX()&#123;</span><br><span class="line">    BOOL isPhoneX &#x3D; NO;</span><br><span class="line">    if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">        isPhoneX &#x3D; [[UIApplication sharedApplication] delegate].window.safeAreaInsets.bottom &gt; 0.0;</span><br><span class="line">    &#125;</span><br><span class="line">    return isPhoneX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UINavigationController-导航栏下坐标从-0-0-开始"><a href="#UINavigationController-导航栏下坐标从-0-0-开始" class="headerlink" title="UINavigationController    导航栏下坐标从(0,0)开始"></a>UINavigationController    导航栏下坐标从(0,0)开始</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;iOS7之后默认全屏布局,也就说(0,0)是从左上角开始的,有导航栏的时候,可以在VC中设置如下</span><br><span class="line">self.edgesForExtendedLayout &#x3D; UIRectEdgeNone;</span><br></pre></td></tr></table></figure><h3 id="自定义返回按钮"><a href="#自定义返回按钮" class="headerlink" title="自定义返回按钮"></a>自定义返回按钮</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.leftBackButton &#x3D; [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">[self.leftBackButton addTarget:self action:@selector(hideAction) forControlEvents:UIControlEventTouchDown];</span><br><span class="line">[self.leftBackButton setImage:[UIImage imageNamed:@&quot;back.png&quot;] forState:UIControlStateNormal];</span><br><span class="line">UIBarButtonItem *item &#x3D; [[UIBarButtonItem alloc]initWithCustomView:self.leftBackButton];</span><br><span class="line">self.navigationItem.leftBarButtonItem &#x3D; item;</span><br></pre></td></tr></table></figure><h3 id="关闭暗黑模式的适配"><a href="#关闭暗黑模式的适配" class="headerlink" title="关闭暗黑模式的适配"></a>关闭暗黑模式的适配</h3><p>全局关闭暗黑模式:<br>在Info.plist文件中,添加key为User Interface Style,类型为String,value设置为Light即可.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;source code 模式下是</span><br><span class="line">&lt;key&gt;UIUserInterfaceStyle&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;Dark&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure><p>单页面关闭暗黑模式:<br>单个页面或视图关闭暗黑模式，设置 overrideUserInterfaceStyle 为对应的模式，强制限制该视图与其子视图以设置的模式进行展示，不跟随系统模式改变进行改变.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.overrideUserInterfaceStyle &#x3D; UIUserInterfaceStyleLight;</span><br></pre></td></tr></table></figure><p>设置此属性会影响当前view/viewController/window 以及它下面的任何内容。</p><h3 id="iOS13创建工程-SceneDelegagte"><a href="#iOS13创建工程-SceneDelegagte" class="headerlink" title="iOS13创建工程:SceneDelegagte"></a>iOS13创建工程:SceneDelegagte</h3><p><a href="https://blog.csdn.net/weixin_38735568/article/details/101266408" target="_blank" rel="noopener">iOS13 创建工程多了类:SceneDelegate(iPadOS多窗口支持)</a></p><p><a href="/Users/zhuyun/Desktop/MyBlogCode/测试.md">打开本地文件地址测试</a></p><h3 id="判断机型-iPad-iPhone…"><a href="#判断机型-iPad-iPhone…" class="headerlink" title="判断机型:iPad,iPhone…"></a>判断机型:iPad,iPhone…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;判断是iPad:UIUserInterfaceIdiom(枚举类型)</span><br><span class="line">[[UIDevice currentDevice] userInterfaceIdiom] &#x3D;&#x3D; UIUserInterfaceIdiomPad</span><br></pre></td></tr></table></figure><h3 id="xcode-代码修改不生效"><a href="#xcode-代码修改不生效" class="headerlink" title="xcode 代码修改不生效"></a>xcode 代码修改不生效</h3><p><a href="https://blog.csdn.net/zww1984774346/article/details/95474862" target="_blank" rel="noopener">方案</a></p><h3 id="respondsToSelector-返回一个布尔值-判断某个对象是否响应某个方法-防止异常"><a href="#respondsToSelector-返回一个布尔值-判断某个对象是否响应某个方法-防止异常" class="headerlink" title="respondsToSelector 返回一个布尔值,判断某个对象是否响应某个方法,防止异常."></a>respondsToSelector 返回一个布尔值,判断某个对象是否响应某个方法,防止异常.</h3><p>—-分割线—</p><h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><p>hexo n<br>hexo g  提交<br>hexo s  静态预览<br>hexo d  发布  </p><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">hexo说明官网</a>  </p><h3 id="判断苹果当前手机机型-如-iPhone7"><a href="#判断苹果当前手机机型-如-iPhone7" class="headerlink" title="判断苹果当前手机机型(如:iPhone7)"></a><a href="https://www.theiphonewiki.com/wiki/Models" target="_blank" rel="noopener">判断苹果当前手机机型(如:iPhone7)</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码  </span><br><span class="line">#import &lt;sys&#x2F;utsname.h&gt;</span><br><span class="line">struct utsname systemInfo;</span><br><span class="line">uname(&amp;systemInfo);</span><br><span class="line">NSString * platform &#x3D; [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];</span><br><span class="line">NSLog(@&quot;platform &#x3D; %@&quot;,platform);</span><br></pre></td></tr></table></figure><h3 id="SF-smybols下载路径"><a href="#SF-smybols下载路径" class="headerlink" title="SF smybols下载路径"></a><a href="https://developer.apple.com/design/downloads/SF-Symbols.dmg" target="_blank" rel="noopener">SF smybols下载路径</a></h3><blockquote><p>简单说明:<a href=",https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/">SF是苹果iOS13之后本身自带的图片</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实例,通过SF找到对应的图片名字即可</span><br><span class="line">[UIImage systemImageNamed:@&quot;lock.fill&quot;];</span><br><span class="line">&#x2F;&#x2F;图片颜色设置</span><br><span class="line">self.leftImageView.tintColor &#x3D; [UIColor whiteColor];</span><br><span class="line">&#x2F;&#x2F;weights and scales,配置图片的大小和重量</span><br><span class="line">UIImageSymbolConfiguration *con  &#x3D; [UIImageSymbolConfiguration configurationWithPointSize:1 weight:UIImageSymbolWeightLight scale:UIImageSymbolScaleMedium];</span><br><span class="line">[self.leftImageView.image imageByApplyingSymbolConfiguration:con];</span><br></pre></td></tr></table></figure><h3 id="GO下载主页"><a href="#GO下载主页" class="headerlink" title="GO下载主页"></a><a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">GO下载主页</a></h3><p><a href="http://c.biancheng.net/view/6241.html" target="_blank" rel="noopener">go教学</a>  </p><h3 id="crash-NSNull-length-unrecognized-selector-sent-to-instance"><a href="#crash-NSNull-length-unrecognized-selector-sent-to-instance" class="headerlink" title="crash:[NSNull length]:unrecognized selector sent to instance"></a>crash:[NSNull length]:unrecognized selector sent to instance</h3><p>json数据中存在字符串,name = @”<null>“这样的值<br>使用:isKindOfClass:[NSNull class]]来进行判断 </p><h3 id="提问-同步-主队列是否一定会造成死锁"><a href="#提问-同步-主队列是否一定会造成死锁" class="headerlink" title="提问:同步+主队列是否一定会造成死锁?"></a>提问:同步+主队列是否一定会造成死锁?</h3><p>答案:不一定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1,在主线程中执行该段代码会造成死锁</span><br><span class="line">dispatch_sync(mainQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;不会崩溃&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;2,在子线程中执行该段代码不会造成死锁,concurrent1是并发队列</span><br><span class="line">dispatch_async(concurrent1, ^&#123;</span><br><span class="line">    dispatch_sync(mainQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;不会崩溃&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内联函数</title>
      <link href="/2019/07/17/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2019/07/17/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>内联函数:替换宏定义函数,并且会检查数据类型.</strong>  </p><blockquote><p>static inline 或者 UIKIT_STATIC_INLINE)进行定义<br>在.h或者.m替换之前宏定义的位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">返回值 函数名(参数1,参数2)&#123;</span><br><span class="line">&#x2F;&#x2F;其他操作</span><br><span class="line">   return xxx;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;例子</span><br><span class="line">static inline CGFloat WindowHeight()&#123;</span><br><span class="line">    return [UIScreen mainScreen].bounds.size.height;</span><br><span class="line">&#125;</span><br><span class="line">UIKIT_STATIC_INLINE CGFloat WindowWidth()&#123;</span><br><span class="line">    return [UIScreen mainScreen].bounds.size.width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 内联函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅拷贝与深拷贝</title>
      <link href="/2019/06/12/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/06/12/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><blockquote><p>对象的(<strong>指针</strong>指向)内存地址  </p></blockquote><p><strong>浅拷贝:<br>第一,拷贝了指向对象的指针,拷贝出来的对象的指针和原对象的指针指向同一块内存地址.<br>第二,几个对象共用一块内存,当内存被回收时候,指向这块内存的对象指针需要重新定义,不然会造成野指针错误.<br>深拷贝:<br>第一,拷贝对象的具体内容,开辟新的内存,内存地址自助分配.<br>第二,拷贝完成之后,内存中的值是一样的,但是内存地址不一样,2个对象之间相互不影响,也不相互干涉;</strong>  </p><p>小结:用通俗话来讲,<br>浅拷贝就是一个人和他的影子,本体被销毁了,那么影子也不存在;<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" width="50%" align="center"><br>深拷贝就好比一个人和他的克隆人,本体被销毁了,克隆人依然存在;<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" width="50%" height="" align="center">   </p><blockquote><p>额外知识:    </p><blockquote><p><strong>野指针</strong>:当前对象指针指向的内存已经被回收,但是依然有其他对象的指针指向这块内存,那么指向这块内存的对象指针就是野指针;<br><strong>内存泄漏</strong>:申请内存没有释放,造成内存越来越少;常见是block,delegate,NSTimer的使用不当造成的循环引用;  </p></blockquote></blockquote><a id="more"></a><p><strong><span style="color:red">注意</span>:要实现浅拷贝和深拷贝的类必须遵循NSCopying,NSMutableCopying这2个协议,他们分别实现了以下2个协议的方法;</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSCopying</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol NSMutableCopying</span><br><span class="line"></span><br><span class="line">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="验证例子"><a href="#验证例子" class="headerlink" title="验证例子"></a>验证例子</h3><blockquote><p>copy,mutableCopy<br>第一,区分拷贝之后返回的对象是可变还是不可变;<br>第二,区分是深拷贝还是浅拷贝;</p></blockquote><h4 id="非容器类-NSString-NSMutableString"><a href="#非容器类-NSString-NSMutableString" class="headerlink" title="非容器类:NSString,NSMutableString"></a>非容器类:NSString,NSMutableString</h4><h5 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSString *str &#x3D; @&quot;123&quot;;</span><br><span class="line">NSMutableString *c01 &#x3D; [str copy];</span><br><span class="line">&#x2F;&#x2F; [c01 appendFormat:@&quot;123&quot;];&#x2F;&#x2F;会出现崩溃,表明不可变字符串copy之后对象是不可变的</span><br><span class="line">NSMutableString *c02 &#x3D; [str mutableCopy];</span><br><span class="line">[c02 appendFormat:@&quot;321&quot;];&#x2F;&#x2F;表明mutableCopy之后的对象是可变的</span><br><span class="line">NSLog(@&quot;\nstr&#x3D;%p,\nc01&#x3D;%p,\nc02&#x3D;%p&quot;,str,c01,c02);</span><br><span class="line"></span><br><span class="line">打印结果:</span><br><span class="line">str&#x3D;0x103799078,</span><br><span class="line">c01&#x3D;0x103799078,</span><br><span class="line">c02&#x3D;0x600001904cf0</span><br></pre></td></tr></table></figure><p><strong>小结1.1:不可变字符串NSString:copy是浅拷贝,返回不可变字符串;mutableCopy是深拷贝,返回类型可变字符串;</strong>  </p><h5 id="NSMutableString"><a href="#NSMutableString" class="headerlink" title="NSMutableString"></a>NSMutableString</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *muStr &#x3D; [[NSMutableString alloc]initWithString:@&quot;123&quot;];</span><br><span class="line">NSMutableString *mu001 &#x3D; [muStr copy];</span><br><span class="line">&#x2F;&#x2F;    [mu001 appendFormat:@&quot;123&quot;];</span><br><span class="line">NSMutableString *mu002 &#x3D; [muStr mutableCopy];</span><br><span class="line">[mu002 appendFormat:@&quot;23&quot;];</span><br><span class="line">NSLog(@&quot;\nmuStr&#x3D;%p,\nmu001&#x3D;%p,\nmu002&#x3D;%p&quot;,muStr,mu001,mu002);</span><br><span class="line"></span><br><span class="line">打印结果:</span><br><span class="line">muStr&#x3D;0x600001904ba0,</span><br><span class="line">mu001&#x3D;0x9da610ee44eb2338,</span><br><span class="line">mu002&#x3D;0x600001904f00</span><br></pre></td></tr></table></figure><p><strong>小结1.2:可变字符串NSMutableString:copy和mutabCopy都是深拷贝,copy返回对象是不可变对象,mutableCopy返回的对象是可变对象;</strong></p><blockquote><p><strong><span style="color:green">copy返回的对象类型都是不可变类型,mutableCopy返回的类型都是可变类型,无论被拷贝的对象是可变还是不可变;<br>mutbalCopy都是深拷贝;<br>copy当被拷贝对象是不可变时候,是浅拷贝;当被拷贝的对象是可变时,是深拷贝;</span></strong>  </p></blockquote><h4 id="容器类-NSArray-NSMutableArray"><a href="#容器类-NSArray-NSMutableArray" class="headerlink" title="容器类:NSArray,NSMutableArray"></a>容器类:NSArray,NSMutableArray</h4><blockquote><p>copy返回的对象类型都是不可变,被拷贝的对象是不可变时,依然是浅拷贝;被拷贝的对象是可变时,是深拷贝;<br>mutableCopy返回对象都是都是可变类型的,并且都是深拷贝;  </p></blockquote><h5 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr &#x3D; @[@&quot;321&quot;];</span><br><span class="line">NSArray *a01 &#x3D; [arr copy];&#x2F;&#x2F;返回不可变对象</span><br><span class="line">NSMutableArray *a02 &#x3D; [arr mutableCopy];&#x2F;&#x2F;返回可变对象</span><br><span class="line">NSLog(@&quot;\narr&#x3D;%p,\narr[0]&#x3D;%p,\na01&#x3D;%p,\na02&#x3D;%p,\na02[0]&#x3D;%p&quot;,arr,arr[0],a01,a02,a02[0]);</span><br><span class="line"></span><br><span class="line">打印结果:</span><br><span class="line">arr&#x3D;0x600003c9dfb0,&#x2F;&#x2F;原对象</span><br><span class="line">arr[0]&#x3D;0x10fbd9098,</span><br><span class="line">a01&#x3D;0x600003c9dfb0,&#x2F;&#x2F;copy浅拷贝</span><br><span class="line">a02&#x3D;0x6000030d0780,&#x2F;&#x2F;mutableCopy深拷贝</span><br><span class="line">a02[0]&#x3D;0x10fbd9098</span><br></pre></td></tr></table></figure><h5 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *muArr &#x3D; [[NSMutableArray alloc]initWithObjects:@&quot;231&quot;, nil];</span><br><span class="line">NSArray *muAr1 &#x3D; [muArr copy];&#x2F;&#x2F;返回不可变对象</span><br><span class="line">NSMutableArray *muAr2 &#x3D; [muArr mutableCopy];&#x2F;&#x2F;返回可变对象</span><br><span class="line">NSLog(@&quot;\narr&#x3D;%p,\narr[0]&#x3D;%p,\na01&#x3D;%p,\na02&#x3D;%p,\na02[0]&#x3D;%p&quot;,muArr,muArr[0],muAr1,muAr2,muAr2[0]);</span><br><span class="line"></span><br><span class="line">打印结果:</span><br><span class="line">muArr&#x3D;0x6000017b5740,</span><br><span class="line">muArr[0]&#x3D;0x108071158,&#x2F;&#x2F;</span><br><span class="line">muAr1&#x3D;0x600001beca90,&#x2F;&#x2F;深拷贝</span><br><span class="line">muAr2&#x3D;0x6000017b58c0,&#x2F;&#x2F;深拷贝</span><br><span class="line">muAr2[0]&#x3D;0x108071158&#x2F;&#x2F;和muArr[0]相同</span><br></pre></td></tr></table></figure><p>小结2.1:集合类深拷贝,虽然开辟了新的内存空间,但集合里面的值的内存还是指向相同的内存(指针拷贝),这叫单层深复制;</p><h5 id="容器类实现完全深拷贝"><a href="#容器类实现完全深拷贝" class="headerlink" title="容器类实现完全深拷贝"></a>容器类实现完全深拷贝</h5><p>使用归档:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *muA &#x3D; [[NSMutableArray alloc]init];</span><br><span class="line">NSMutableString *table1 &#x3D; [[NSMutableString alloc]initWithFormat:@&quot;123&quot;];</span><br><span class="line">NSMutableString *table2 &#x3D; [[NSMutableString alloc]initWithFormat:@&quot;321&quot;];</span><br><span class="line">[muA addObject:table1];</span><br><span class="line">[muA addObject:table2];</span><br><span class="line">NSLog(@&quot;归档前:\nmuA   :%p,\nmuA[0]:%p,\nmuA[1]:%p&quot;,muA,muA[0],muA[1]);</span><br><span class="line">NSData *data &#x3D; [NSKeyedArchiver archivedDataWithRootObject:muA];</span><br><span class="line">NSMutableArray *archiverMuA &#x3D; [NSKeyedUnarchiver unarchiveObjectWithData:data];&#x2F;&#x2F;注意,解档后的数据类型和解档前的保持一致;</span><br><span class="line">NSLog(@&quot;归档后:\narchiverMuA   :%p,\narchiverMuA[0]:%p,\narchiverMuA[1]:%p&quot;,archiverMuA,archiverMuA[0],archiverMuA[1]);</span><br><span class="line"></span><br><span class="line">打印:</span><br><span class="line">2019-06-14 11:55:32.870731+0800 Copy[15136:2127544] 归档前:</span><br><span class="line">muA   :0x600002a32490,</span><br><span class="line">muA[0]:0x600002a32250,</span><br><span class="line">muA[1]:0x600002a32550</span><br><span class="line">2019-06-14 11:55:32.871096+0800 Copy[15136:2127544] 归档后:</span><br><span class="line">archiverMuA   :0x600002a323d0,</span><br><span class="line">archiverMuA[0]:0x600002a32310,</span><br><span class="line">archiverMuA[1]:0x600002a32400</span><br></pre></td></tr></table></figure><p>小结3.1:可以看出经过归档和解档之后,容器类内存地址和里面的值的内存地址和原来的不一样;</p><p>end</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 拷贝 </tag>
            
            <tag> copy </tag>
            
            <tag> mutableCopy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之-NSOperation</title>
      <link href="/2018/08/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B-NSOperation/"/>
      <url>/2018/08/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B-NSOperation/</url>
      
        <content type="html"><![CDATA[<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><blockquote><p>1.和NSThread,GCD一样,NSOperation也是苹果提供的一套多线程并发编程方案;<br>2.它是对GCD在OC层面的一个封装,是完全面向对象的;<br>3.它比GCD多了一些更加实用的功能;<br>4.经常使用;<br>5.自动管理; </p></blockquote><h4 id="NSOperation用法"><a href="#NSOperation用法" class="headerlink" title="NSOperation用法"></a>NSOperation用法</h4><p>NSOperation是一个抽象类,在使用的时候,需要使用的是它的子类,并且有3种方式:  </p><blockquote><p>1.NSInvocationOperation类;<br>2.NSBlockOperation类;<br>3.继承于NSOperation的子类,重写main方法;  </p></blockquote><a id="more"></a>  <p>要实现多线程,需要配合<strong>NSOperationQueue</strong>类进行配合;<br>NSOperationQueue表示队列,分为主队列和其他队列:  </p><blockquote><p>主队列是一个特殊的串行队列;<br>其他队列包含了串行队列和并发队列;  </p></blockquote><h5 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h5><p>获取主队列:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *mainQueue &#x3D; [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure><p>其他队列:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *q1 &#x3D; [[NSOperationQueue alloc]init];</span><br><span class="line">q1.maxConcurrentOperationCount &#x3D; 1;</span><br></pre></td></tr></table></figure><blockquote><p>maxConcurrentOperationCount属性:<br>线程的最大个数,该属性不进行设置时,默认为-1即为<strong>并发队列</strong>,不限制线程开启个数,开启新线程;<br>当值为1时,表示为串行队列,虽然开启了线程,但是是一个一个执行;<br>不要无脑的认为设置该值越大,开启的线程数量就越多,线程开启最大数系统会自行调整;  </p></blockquote><p>其他方法:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;队列添加任务,并自动开启</span><br><span class="line">- (void)addOperation:(NSOperation *)op;  </span><br><span class="line">&#x2F;&#x2F;添加任务数组,wait&#x3D;YES的时候,阻塞线程,表示等待任务完成再往下操作</span><br><span class="line">- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;  </span><br><span class="line">&#x2F;&#x2F;直接开始任务操作,会开始新的线程</span><br><span class="line">- (void)addOperationWithBlock:(void (^)(void))block;</span><br><span class="line">&#x2F;&#x2F;YES表示暂停,设置为NO可以恢复</span><br><span class="line">@property (getter&#x3D;isSuspended) BOOL suspended;</span><br><span class="line">&#x2F;&#x2F;已经加入到队列的任务无法删除,但是可以暂停,下面表示暂停当前队列所有的任务,当然,已经开始的任务是无法暂停的</span><br><span class="line">- (void)cancelAllOperations;</span><br><span class="line">&#x2F;&#x2F;等待队列中所有任务的完成,会阻塞线程</span><br><span class="line">- (void)waitUntilAllOperationsAreFinished;</span><br></pre></td></tr></table></figure><h5 id="NSInvocationOperation使用"><a href="#NSInvocationOperation使用" class="headerlink" title="NSInvocationOperation使用"></a>NSInvocationOperation使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;队列,默认并发</span><br><span class="line">NSOperationQueue *q1 &#x3D; [[NSOperationQueue alloc]init];</span><br><span class="line">&#x2F;&#x2F;创建</span><br><span class="line"> NSInvocationOperation *invocationOperation1 &#x3D; [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(invationAction1) object:nil];</span><br><span class="line">&#x2F;&#x2F;队列添加任务并开始</span><br><span class="line">[q1 addOperation:invocationOperation1];</span><br><span class="line">-(void)invationAction1&#123;</span><br><span class="line">    for (NSUInteger i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;Invocation1 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2018-08-06 16:38:39.462458+0800 FDThread[7300:689575] Invocation1 &#x3D; &lt;NSThread: 0x600003b7a7c0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-06 16:38:41.464461+0800 FDThread[7300:689575] Invocation1 &#x3D; &lt;NSThread: 0x600003b7a7c0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开启的了新的线程;  </p></blockquote><h5 id="NSBlockOperation使用"><a href="#NSBlockOperation使用" class="headerlink" title="NSBlockOperation使用"></a>NSBlockOperation使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *block1 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (NSUInteger i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;block1 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">[q1 addOperation:block1];</span><br><span class="line"></span><br><span class="line">2018-08-06 16:38:43.467961+0800 FDThread[7300:689574] block1 &#x3D; &lt;NSThread: 0x600003b6f7c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-06 16:38:45.469692+0800 FDThread[7300:689574] block1 &#x3D; &lt;NSThread: 0x600003b6f7c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义NSOperation子类"><a href="#自定义NSOperation子类" class="headerlink" title="自定义NSOperation子类"></a>自定义NSOperation子类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line">@interface CoustomOperation : NSOperation</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">.m</span><br><span class="line">@implementation CoustomOperation</span><br><span class="line">&#x2F;&#x2F;重写main方法,进行相关操作</span><br><span class="line">-(void)main&#123;</span><br><span class="line">    for (NSUInteger i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;CoustomOperation &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">CoustomOperation *c1 &#x3D; [[CoustomOperation alloc]init];</span><br><span class="line">[q1 addOperation:c1];</span><br><span class="line"></span><br><span class="line">2018-08-06 16:38:47.473828+0800 FDThread[7300:689574] CoustomOperation &#x3D; &lt;NSThread: 0x600003b6f7c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-06 16:38:49.477721+0800 FDThread[7300:689574] CoustomOperation &#x3D; &lt;NSThread: 0x600003b6f7c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h5 id="NSOperationQueue的方法"><a href="#NSOperationQueue的方法" class="headerlink" title="NSOperationQueue的方法"></a>NSOperationQueue的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *q2 &#x3D; [[NSOperationQueue alloc]init];</span><br><span class="line">[q2 addOperationWithBlock:^&#123;</span><br><span class="line">    &#x2F;&#x2F;直接添加任务,会开启新线程</span><br><span class="line">    for (NSUInteger i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;queue &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">2018-08-06 16:38:39.462458+0800 FDThread[7300:689576] queue &#x3D; &lt;NSThread: 0x600003b8e000&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-06 16:38:41.464419+0800 FDThread[7300:689576] queue &#x3D; &lt;NSThread: 0x600003b8e000&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure><h5 id="不同操作队列任务之间可以设置依赖"><a href="#不同操作队列任务之间可以设置依赖" class="headerlink" title="不同操作队列任务之间可以设置依赖"></a>不同操作队列任务之间可以设置依赖</h5><blockquote><p>设置依赖的意思就是可以设置某个任务的开始执行依赖于另外一个任务的完成</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;blcok1 任务会在invocationOperation1所有任务完成之后才开始执行</span><br><span class="line">[block1 addDependency:invocationOperation1];</span><br><span class="line">&#x2F;&#x2F;可以移除依赖</span><br><span class="line">- (void)removeDependency:(NSOperation *)op;</span><br></pre></td></tr></table></figure><h5 id="NSOperation其他的一些设置"><a href="#NSOperation其他的一些设置" class="headerlink" title="NSOperation其他的一些设置"></a>NSOperation其他的一些设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置任务的优先级,默认NSOperationQueuePriorityNormal,优先级高只表明优先被执行,而不代表被完成,在</span><br><span class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</span><br><span class="line">NSOperationQueuePriorityVeryLow &#x3D; -8L,</span><br><span class="line">NSOperationQueuePriorityLow &#x3D; -4L,</span><br><span class="line">NSOperationQueuePriorityNormal &#x3D; 0,</span><br><span class="line">NSOperationQueuePriorityHigh &#x3D; 4,</span><br><span class="line">NSOperationQueuePriorityVeryHigh &#x3D; 8</span><br><span class="line">&#125;;</span><br><span class="line">@property NSOperationQueuePriority queuePriority;</span><br><span class="line">&#x2F;&#x2F;获取某个任务的所有依赖,只读属性</span><br><span class="line">@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;</span><br><span class="line">&#x2F;&#x2F;等待某个任务完成,会阻塞主线程</span><br><span class="line">- (void)waitUntilFinished</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> NSOperation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之-GCD</title>
      <link href="/2018/07/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B-GCD/"/>
      <url>/2018/07/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B-GCD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>队列:串行,执行完一个任务再执行下一个任务;并发,可以多个任务同时执行;<br>函数:同步,不开启新线程,在主线程执行;异步,开启新线程(当队列是主队列时,不开新线程);<br>最佳执行方案:异步函数+并发队列<br>死锁问题;<br>耗时的任务放到后台去运行;<a id="more"></a>      </p></blockquote><h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><blockquote><p>GCD全称是Grand Central Dispatch,是一套纯C的API;<br>GCD会自动利用更多的CPU内核;<br>GCD会自动管理线程的生命周期,使用block块来执行任务;<br>常用;  </p></blockquote><h4 id="队列和任务"><a href="#队列和任务" class="headerlink" title="队列和任务"></a>队列和任务</h4><p>在了解GCD之前,我们先来了解GCD的核心:队列和任务;  </p><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><blockquote><p>队列是用来放置任务的,分为串行队列和并发队列;<br><strong>串行队列</strong>:任务执行方式是一个接着一个,只有一个任务完成了才会执行下一个任务,一个app中的主队列就是一个特殊串行队列;<br><strong>并发队列</strong>:任务执行方式可以在同一时间执行多个任务;  </p></blockquote><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><blockquote><p>任务,就是我们要执行的代码块,方式有异步async和同步sync;<br>异步函数,会开启新线程(当队列是主队列的时候,不会开启新线程);<br>同步函数,不会开启新线程,就是说会在当前主线程中执行任务,会阻塞当前主线程;  </p></blockquote><h4 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h4><p>GCD的使用主要是队列与任务之间相互组合;  </p><blockquote><p>异步+串行:会创建新的线程,一个任务完成后接着下一个任务;<br>异步+并行:开启新的线程,任务可以同时执行,任务同时开启数量取决于cpu的调度;<br>异步+主队列:没有开启新线程,串行执行任务;<br>同步+串行:不会开启新的线程,并且会阻塞主线程,直到该任务完成;<br>同步+并行:不会开启新的线程,会阻塞主线程,直到函数内任务执行完毕,并发队列失效;<br>同步+主队列:相互之间等待对方完成,会造成死锁,避免使用该组合;  </p></blockquote><h5 id="队列创建"><a href="#队列创建" class="headerlink" title="队列创建"></a>队列创建</h5><p>串行队列的创建有2种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;DISPATCH_QUEUE_SERIAL,NULL</span><br><span class="line">dispatch_queue_t queue2 &#x3D; dispatch_queue_create(&quot;queue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue3 &#x3D; dispatch_queue_create(&quot;queue1&quot;, NULL);</span><br></pre></td></tr></table></figure><p>并行队列创建:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;DISPATCH_QUEUE_CONCURRENT</span><br><span class="line">dispatch_queue_t queue1 &#x3D; dispatch_queue_create(&quot;queue1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">&#x2F;&#x2F;优先级的并发队列</span><br><span class="line">dispatch_queue_t queue212 &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br><span class="line">&#x2F;&#x2F;DISPATCH_QUEUE_PRIORITY_DEFAULT  默认</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span><br></pre></td></tr></table></figure><p>获取主队列,主队列是一个特殊的串行队列,更新UI等一系列操作都必须在主队列中进行:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mainQueue &#x3D; dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><h5 id="配合同步函数和异步函数的使用"><a href="#配合同步函数和异步函数的使用" class="headerlink" title="配合同步函数和异步函数的使用"></a>配合同步函数和异步函数的使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serial1 &#x3D; dispatch_queue_create(&quot;serial1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t serial2 &#x3D; dispatch_queue_create(&quot;serial2&quot;, NULL);</span><br><span class="line">  </span><br><span class="line">dispatch_queue_t concurrent &#x3D; dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t mainQueue1 &#x3D; dispatch_get_main_queue();</span><br><span class="line">NSLog(@&quot;当前主线程 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#x2F;&#x2F;异步+串行</span><br><span class="line">dispatch_async(serial1, ^&#123;</span><br><span class="line">    NSLog(@&quot;异步+串行 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;异步+并行</span><br><span class="line">dispatch_async(concurrent, ^&#123;</span><br><span class="line">    NSLog(@&quot;异步+并行 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;异步+主队列</span><br><span class="line">dispatch_async(mainQueue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;异步+主队列 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同步+串行</span><br><span class="line">dispatch_sync(serial2, ^&#123;</span><br><span class="line">    NSLog(@&quot;同步+串行 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;同步+并行</span><br><span class="line">dispatch_sync(concurrent, ^&#123;</span><br><span class="line">    NSLog(@&quot;同步+并行 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;    &#x2F;&#x2F;同步+主队列</span><br><span class="line">&#x2F;&#x2F; dispatch_sync(mainQueue1, ^&#123;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;造成死锁</span><br><span class="line">&#x2F;&#x2F; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  3.3,在子线程中同步+主队列不会造成死锁</span><br><span class="line">dispatch_async(concurrent1, ^&#123;</span><br><span class="line">dispatch_sync(mainQueue, ^&#123;</span><br><span class="line">NSLog(@&quot;不会崩溃&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2018-08-02 15:13:55.410236+0800 FDThread[5090:518486] 当前主线程 &#x3D; &lt;NSThread: 0x600003dbd640&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-02 15:13:55.410445+0800 FDThread[5090:518486] 同步+串行 &#x3D; &lt;NSThread: 0x600003dbd640&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-02 15:13:55.410467+0800 FDThread[5090:518529] 异步+串行 &#x3D; &lt;NSThread: 0x600003dfa180&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-02 15:13:55.410508+0800 FDThread[5090:518626] 异步+并行 &#x3D; &lt;NSThread: 0x600003d8f540&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-02 15:13:55.410670+0800 FDThread[5090:518486] 同步+并行 &#x3D; &lt;NSThread: 0x600003dbd640&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-02 15:13:55.442415+0800 FDThread[5090:518486] 异步+主队列 &#x3D; &lt;NSThread: 0x600003dbd640&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br></pre></td></tr></table></figure><h4 id="GCD中的死锁"><a href="#GCD中的死锁" class="headerlink" title="GCD中的死锁"></a>GCD中的死锁</h4><p>1,在主线程中当使用<strong>同步+主队列</strong>的时候,会造成线程的死锁;<br>要避免死锁,队列不要使用主队列,换成其他串行队列或者并发队列;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mainQueue &#x3D; dispatch_get_main_queue();</span><br><span class="line">&#x2F;&#x2F;    NSLog(@&quot;1&quot;);</span><br><span class="line">&#x2F;&#x2F;    dispatch_sync(mainQueue, ^&#123;</span><br><span class="line">&#x2F;&#x2F;        NSLog(@&quot;2&quot;);</span><br><span class="line">&#x2F;&#x2F;    &#125;);</span><br><span class="line">&#x2F;&#x2F;    NSLog(@&quot;3&quot;);</span><br><span class="line">&#x2F;&#x2F;线程相互阻塞,死锁:队列已经分发在等待执行;</span><br><span class="line">&#x2F;&#x2F;主线程,串行队列:要执行3必须要先执行2</span><br><span class="line">&#x2F;&#x2F;同步,串行主队列:要执行2,必须要执行获取到主队列中3;</span><br><span class="line">&#x2F;&#x2F;最后导致线程相互等待;</span><br></pre></td></tr></table></figure><p>2,在子线程中使用<strong>同步+主队列</strong>的时,不会造成死锁.</p><h4 id="GCD之间的通讯"><a href="#GCD之间的通讯" class="headerlink" title="GCD之间的通讯"></a>GCD之间的通讯</h4><blockquote><p>例子,<br>1,当你使用GCD进行下载图片而有需要在主线程中进行UI界面更新的时候,会用到线程之间的通讯;<br>2,线程2开启依赖线程1任务是否执行完毕</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t q1 &#x3D; dispatch_queue_create(&quot;q1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(q1, ^&#123;</span><br><span class="line">   &#x2F;&#x2F;dowload image</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        &#x2F;&#x2F;update UI</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="GCD其他方法"><a href="#GCD其他方法" class="headerlink" title="GCD其他方法"></a>GCD其他方法</h4><h5 id="延迟函数-dispatch-after"><a href="#延迟函数-dispatch-after" class="headerlink" title="延迟函数:dispatch_after"></a>延迟函数:dispatch_after</h5><blockquote><p>延迟2秒执行block内的任务,严格来说,这个时间不是绝对正确的;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">     NSLog(@&quot;late 2min&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h5><blockquote><p>通常被用在单例的创建;  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    &#x2F;&#x2F;只会被执行一次代码,是线程安全的</span><br><span class="line">&#125;);</span><br><span class="line">示例:</span><br><span class="line">#import &quot;ZYInfo.h&quot;</span><br><span class="line">static ZYInfo * _info &#x3D; nil;</span><br><span class="line">@implementation ZYInfo</span><br><span class="line">#pragma mark -- GCD单例创建</span><br><span class="line">+(ZYInfo *)shareInstance&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _info &#x3D; [[super allocWithZone:NULL]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _info;</span><br><span class="line">&#125;</span><br><span class="line">+(id)allocWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    return [ZYInfo shareInstance];</span><br><span class="line">&#125;</span><br><span class="line">+(id)copyWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    return [ZYInfo shareInstance] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="栅栏barrier"><a href="#栅栏barrier" class="headerlink" title="栅栏barrier"></a>栅栏barrier</h5><blockquote><p>我们有时候需要异步来执行2组操作,但是却希望是第一组操作完成之后再执行另外一组;这个时候,我们就可以使用来barrier实现:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync </span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentBarrier &#x3D; dispatch_queue_create(&quot;barrier&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">   </span><br><span class="line">dispatch_async(concurrentBarrier, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];&#x2F;&#x2F;模拟耗时操作</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentBarrier, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];&#x2F;&#x2F;模拟耗时操作</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line">dispatch_barrier_sync(concurrentBarrier, ^&#123;</span><br><span class="line">    NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_async(concurrentBarrier, ^&#123;</span><br><span class="line">    NSLog(@&quot;4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">2018-08-02 18:13:30.307159+0800 FDThread[1514:109487] 2</span><br><span class="line">2018-08-02 18:13:30.307159+0800 FDThread[1514:109488] 1</span><br><span class="line">2018-08-02 18:13:32.312161+0800 FDThread[1514:109488] 1</span><br><span class="line">2018-08-02 18:13:32.312199+0800 FDThread[1514:109487] 2</span><br><span class="line">2018-08-02 18:13:34.314149+0800 FDThread[1514:109488] 1</span><br><span class="line">2018-08-02 18:13:34.314368+0800 FDThread[1514:109403] 3</span><br><span class="line">2018-08-02 18:13:34.314510+0800 FDThread[1514:109488] 4</span><br><span class="line"></span><br><span class="line">4是在1,2,3之后完成;</span><br></pre></td></tr></table></figure><h5 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h5><blockquote><p>把一个任务提交到队列中多次执行,具体是串行还是并行由队列本身决定;<br>apply不会立即返回,在执行完毕之后才会返回,是同步的调用;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrent &#x3D; dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">NSLog(@&quot;apply-begin&quot;);</span><br><span class="line">dispatch_apply(6, concurrent, ^(size_t index) &#123;</span><br><span class="line">    NSLog(@&quot;%ld -- %@&quot;,index,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;apply-end&quot;);</span><br><span class="line">2018-08-03 10:25:47.157811+0800 FDThread[2873:199134] apply-begin</span><br><span class="line">2018-08-03 10:25:47.157936+0800 FDThread[2873:199134] 0 -- &lt;NSThread: 0x600003b50ec0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:25:47.158042+0800 FDThread[2873:199134] 1 -- &lt;NSThread: 0x600003b50ec0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:25:47.158098+0800 FDThread[2873:199256] 2 -- &lt;NSThread: 0x600003b229c0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-03 10:25:47.158275+0800 FDThread[2873:199134] 3 -- &lt;NSThread: 0x600003b50ec0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:25:47.158356+0800 FDThread[2873:199258] 4 -- &lt;NSThread: 0x600003b22a00&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-03 10:25:47.158385+0800 FDThread[2873:199259] 5 -- &lt;NSThread: 0x600003b22840&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-03 10:25:47.159049+0800 FDThread[2873:199134] apply-end</span><br></pre></td></tr></table></figure><blockquote><p>可以看出,当队列是并发队列的时候,除了会在主线程中执行还会开启其他的线程;<br>当队列是串行队列的时候,只会在主线程执行,不会开启新的线程;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serial1 &#x3D; dispatch_queue_create(&quot;serial1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">NSLog(@&quot;apply-begin&quot;);</span><br><span class="line">dispatch_apply(6, serial1, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;%ld -- %@&quot;,index,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;apply-end&quot;);</span><br><span class="line"></span><br><span class="line">2018-08-03 10:41:44.982335+0800 FDThread[3031:209835] apply-begin</span><br><span class="line">2018-08-03 10:41:44.982459+0800 FDThread[3031:209835] 0 -- &lt;NSThread: 0x600002fd93c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:41:44.982570+0800 FDThread[3031:209835] 1 -- &lt;NSThread: 0x600002fd93c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:41:44.982682+0800 FDThread[3031:209835] 2 -- &lt;NSThread: 0x600002fd93c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:41:44.982981+0800 FDThread[3031:209835] 3 -- &lt;NSThread: 0x600002fd93c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:41:44.983332+0800 FDThread[3031:209835] 4 -- &lt;NSThread: 0x600002fd93c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:41:44.983653+0800 FDThread[3031:209835] 5 -- &lt;NSThread: 0x600002fd93c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2018-08-03 10:41:44.983951+0800 FDThread[3031:209835] apply-end</span><br></pre></td></tr></table></figure><h5 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h5><blockquote><p>有时候,我们会有这样的需求:分别要求执行2个耗时任务,在这2个耗时的任务完成之后,我们在回到主线程或者指定线程来进行下一步的操作,这个时候就需要用到GCD中的队列组;  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">NSLog(@&quot;group_begin&quot;);</span><br><span class="line">dispatch_group_async(group, concurrent, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];&#x2F;&#x2F;模拟延时操作</span><br><span class="line">        NSLog(@&quot;group1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, serial2, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];&#x2F;&#x2F;模拟延时操作</span><br><span class="line">        NSLog(@&quot;group2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    &#x2F;&#x2F;等队列组内操作完成后,回到指定线程中进行下一步操作</span><br><span class="line">    NSLog(@&quot;group_end&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2018-08-03 11:10:38.731557+0800 FDThread[3334:233506] group_begin</span><br><span class="line">2018-08-03 11:10:40.733320+0800 FDThread[3334:233602] group2</span><br><span class="line">2018-08-03 11:10:40.733355+0800 FDThread[3334:233599] group1</span><br><span class="line">2018-08-03 11:10:42.737682+0800 FDThread[3334:233599] group1</span><br><span class="line">2018-08-03 11:10:42.737677+0800 FDThread[3334:233602] group2</span><br><span class="line">2018-08-03 11:10:42.738053+0800 FDThread[3334:233506] group_end</span><br></pre></td></tr></table></figure><h5 id="dispatch-group的enter和leave"><a href="#dispatch-group的enter和leave" class="headerlink" title="dispatch_group的enter和leave"></a>dispatch_group的enter和leave</h5><blockquote><p>使用达到上面相同效果,他们的使用必须要是配对出现  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_group_leave(group);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group2 &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t q22 &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    </span><br><span class="line">dispatch_group_enter(group2);</span><br><span class="line">dispatch_async(q22, ^&#123;</span><br><span class="line">    &#x2F;&#x2F;task1</span><br><span class="line">    NSLog(@&quot;enter1 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_group_leave(group2);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_enter(group2);</span><br><span class="line">dispatch_async(q22, ^&#123;</span><br><span class="line">    &#x2F;&#x2F;task2</span><br><span class="line">    NSLog(@&quot;enter2 &#x3D; %@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_group_leave(group2);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_notify(group2, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">   &#x2F;&#x2F;执行task1和task2群组之后,才会执行这里面的任务</span><br><span class="line">    NSLog(@&quot;enter3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2018-08-07 15:28:48.754127+0800 FDThread[1480:55093] enter2 &#x3D; &lt;NSThread: 0x60000085e9c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-07 15:28:48.754163+0800 FDThread[1480:55095] enter1 &#x3D; &lt;NSThread: 0x60000085e680&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2018-08-07 15:28:48.778816+0800 FDThread[1480:55003] enter3</span><br></pre></td></tr></table></figure><h5 id="dispatch-wait"><a href="#dispatch-wait" class="headerlink" title="dispatch_wait"></a>dispatch_wait</h5><blockquote><p>暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">NSLog(@&quot;group_begin&quot;);</span><br><span class="line">dispatch_group_async(group, concurrent, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];&#x2F;&#x2F;模拟延时操作</span><br><span class="line">        NSLog(@&quot;group1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, serial2, ^&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 2; i ++) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];&#x2F;&#x2F;模拟延时操作</span><br><span class="line">        NSLog(@&quot;group2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;等队列组内操作完成后,回到指定线程中进行下一步操作</span><br><span class="line">&#x2F;&#x2F;        NSLog(@&quot;group_end&quot;);</span><br><span class="line">&#x2F;&#x2F;    &#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;group_end&quot;);</span><br><span class="line"></span><br><span class="line">2018-08-03 11:20:41.968222+0800 FDThread[3430:240751] group_begin</span><br><span class="line">2018-08-03 11:20:43.973824+0800 FDThread[3430:240815] group1</span><br><span class="line">2018-08-03 11:20:43.973805+0800 FDThread[3430:240809] group2</span><br><span class="line">2018-08-03 11:20:45.975265+0800 FDThread[3430:240815] group1</span><br><span class="line">2018-08-03 11:20:45.975284+0800 FDThread[3430:240809] group2</span><br><span class="line">2018-08-03 11:20:45.975725+0800 FDThread[3430:240751] group_end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之-NSThread</title>
      <link href="/2018/07/20/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B-NSThread/"/>
      <url>/2018/07/20/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B-NSThread/</url>
      
        <content type="html"><![CDATA[<h4 id="进程和线程概念"><a href="#进程和线程概念" class="headerlink" title="进程和线程概念"></a>进程和线程概念</h4><blockquote><p><strong>1,进程</strong>:进程是计算机系统分配的单位,每个进程之间是相互独立的,如同时打开微信,QQ,那么就开启了2个进程;<br><strong>2,线程</strong>:线程是进程的基本执行单位,进程中所有的任务都是在线程中执行的,每一个进程都必须存在并且只有一个<strong>主线程</strong>,允许存在多个子线程;<br><strong>3,多线程</strong>:在不阻塞主线程情况下,充分利用CPU资源开启多个线程去执行耗时任务,优化app体验; </p></blockquote><a id="more"></a><h4 id="NSThread使用"><a href="#NSThread使用" class="headerlink" title="NSThread使用"></a>NSThread使用</h4><blockquote><p>异步,并发队列<br>需要对线程进行手动管理<br>较少用到  </p></blockquote><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>第一种是类方法:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(action4) toTarget:self withObject:@&quot;123&quot;];  </span><br><span class="line">-(void)action4&#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该类方法创建的线程会自动启动,@”123”是线程的标识符;  </p></blockquote><p>iOS10之后提供了一种Block方法:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadWithBlock:^&#123;  </span><br><span class="line">       &#x2F;&#x2F;iOS10之后的block方法</span><br><span class="line">       NSLog(@&quot;NSThread1&#x3D;%@&quot;,[NSThread currentThread]);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><p>第二种是init方法:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> NSThread *t1 &#x3D; [[NSThread alloc]initWithTarget:self selector:@selector(action1) object:nil];  </span><br><span class="line"> t1.name &#x3D; @&quot;1&quot;;  </span><br><span class="line"> [t1 start];  </span><br><span class="line">-(void)action1&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要手动去开启,name=@“1”是线程的标识符;  </p></blockquote><h5 id="NSThread一些方法和属性"><a href="#NSThread一些方法和属性" class="headerlink" title="NSThread一些方法和属性"></a>NSThread一些方法和属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;是否是多线程</span><br><span class="line">[NSThread isMultiThreaded];</span><br><span class="line">&#x2F;&#x2F;是否是主线程</span><br><span class="line">[NSThread isMainThread];</span><br><span class="line">&#x2F;&#x2F;获取当前线程,number&#x3D;1表示是主线程</span><br><span class="line">[NSThread currentThread];</span><br><span class="line">&#x2F;&#x2F;休眠多久</span><br><span class="line">[NSThread sleepForTimeInterval:1.2];</span><br><span class="line">&#x2F;&#x2F;休眠到什么时间</span><br><span class="line">[NSThread sleepUntilDate:[NSDate date]];</span><br><span class="line">&#x2F;&#x2F;退出线程</span><br><span class="line">[NSThread exit];</span><br><span class="line">&#x2F;&#x2F;当前线程优先级</span><br><span class="line">[NSThread threadPriority];</span><br><span class="line">&#x2F;&#x2F;设置线程的优先级0.0~1.0,默认0.5,数值越大,表示cpu调用的频率高</span><br><span class="line">[NSThread setThreadPriority:0.2];</span><br><span class="line">&#x2F;&#x2F;主线程对象</span><br><span class="line">NSThread *main &#x3D; [NSThread mainThread];  </span><br><span class="line"></span><br><span class="line">NSThread *t3 &#x3D; [[NSThread alloc]initWithBlock:^&#123;</span><br><span class="line">        &#x2F;&#x2F;iOS10新增加方法</span><br><span class="line"> &#125;];</span><br><span class="line">[t3 start];</span><br><span class="line">&#x2F;&#x2F;name,线程标识</span><br><span class="line">t3.name &#x3D; @&quot;name1&quot;;</span><br><span class="line">if (t3.isExecuting) &#123;</span><br><span class="line">    &#x2F;&#x2F;是否在执行</span><br><span class="line">&#125;</span><br><span class="line">if (t3.isCancelled) &#123;</span><br><span class="line">    &#x2F;&#x2F;是否停止</span><br><span class="line">&#125;</span><br><span class="line">if (t3.isFinished) &#123;</span><br><span class="line">    &#x2F;&#x2F;是否完成</span><br><span class="line">&#125;</span><br><span class="line">if (t3.isMainThread) &#123;</span><br><span class="line">    &#x2F;&#x2F;是否是主线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><blockquote><p>线程同步,指的是不同的线程同时去争夺同一块资源,造成的数据混乱和数据安全的问题;就好比几个人修改同一个表的时候造成的数据混乱;  </p></blockquote><h5 id="解决方案1-synchronized"><a href="#解决方案1-synchronized" class="headerlink" title="解决方案1:@synchronized"></a>解决方案1:@synchronized</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(self) &#123;</span><br><span class="line">    &#x2F;&#x2F; 需要锁定的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决方案2-NSLock"><a href="#解决方案2-NSLock" class="headerlink" title="解决方案2:NSLock"></a>解决方案2:NSLock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全局变量:NSLock *lock &#x3D; [[NSLock alloc]init];</span><br><span class="line">[lock lock];</span><br><span class="line">&#x2F;&#x2F;需要锁定的代码</span><br><span class="line">[lock unlock];</span><br></pre></td></tr></table></figure><h4 id="互斥锁和自旋锁"><a href="#互斥锁和自旋锁" class="headerlink" title="互斥锁和自旋锁"></a>互斥锁和自旋锁</h4><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>上面的方案1和方案2都属于<strong>互斥锁</strong>:加了互斥锁的代码,当新线程访问时,如果发现其他线程正在执行锁定的代码，新线程就会进入休眠.  </p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>另外还有一种叫<strong>自旋锁</strong>:加了自旋锁，当新线程访问代码时，如果发现有其他线程正在锁定代码，新线程会用死循环的方式，一直等待锁定的代码执行完成。相当于不停尝试执行代码，比较消耗性能。<br>属性修饰atomic本身就有一把自旋锁。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nonatomic 非原子属性,同一时间可以有很多线程读和写</span><br><span class="line">atomic 原子属性(线程安全)，保证同一时间只有一个线程能够写入(但是同一个时间多个线程都可以取值)，atomic 本身就有一把锁(自旋锁)</span><br><span class="line">atomic：线程安全，需要消耗大量的资源</span><br><span class="line">nonatomic：非线程安全，不过效率更高，一般使用nonatomic</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> NSThread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcode10_beta:block内_出现self替换警告</title>
      <link href="/2018/07/11/xcode10_%E4%BD%93%E9%AA%8C1/"/>
      <url>/2018/07/11/xcode10_%E4%BD%93%E9%AA%8C1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>新版本xcode10在使用block时,如果使用全局变量会出现:self-&gt;去替换_的警告;  </p></blockquote><p>处理:在Build Setting中设置Implicit retain of ‘self’ within blocks为NO;<br>如下图所示:<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode10self%E8%AD%A6%E5%91%8A/block%E5%86%85_%E5%87%BA%E7%8E%B0self%E6%9B%BF%E6%8D%A2%E8%AD%A6%E5%91%8A.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发-JSON数据</title>
      <link href="/2018/03/16/iOS%E5%BC%80%E5%8F%91-JSON%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/03/16/iOS%E5%BC%80%E5%8F%91-JSON%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h4><blockquote><p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的<strong>数据交换格式</strong>。它基于ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<a id="more"></a></p></blockquote><p><a href="https://baike.baidu.com/item/JSON/2462549?fr=aladdin" target="_blank" rel="noopener">百度词条</a>  </p><h4 id="JSON数据格式"><a href="#JSON数据格式" class="headerlink" title="JSON数据格式"></a>JSON数据格式</h4><blockquote><p>JSON数据主要有两种数据格式</p></blockquote><h5 id="第一种是键-值对-对oc来说就是字典"><a href="#第一种是键-值对-对oc来说就是字典" class="headerlink" title="第一种是键/值对,对oc来说就是字典"></a>第一种是键/值对,对oc来说就是字典</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:&quot;23&quot;,&quot;name&quot;:&quot;mark&quot;&#125;;  </span><br><span class="line">解析出来在oc的展示就是:</span><br><span class="line">@&#123;@&quot;id&quot;:@&quot;23&quot;,@&quot;name&quot;:@&quot;mark&quot;&#125;;</span><br></pre></td></tr></table></figure><h5 id="第二种是数组的格式"><a href="#第二种是数组的格式" class="headerlink" title="第二种是数组的格式"></a>第二种是数组的格式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;id&quot;:&quot;12&quot;,&quot;name&quot;:&quot;mark&quot;&#125;,</span><br><span class="line"> &#123;&quot;id&quot;:&quot;11&quot;,&quot;name&quot;:&quot;zhu&quot;&#125;]</span><br><span class="line"> 这样解析出来的数据就是数组中每个值都是一个字典;</span><br></pre></td></tr></table></figure><h4 id="对象转换成JSON格式数据"><a href="#对象转换成JSON格式数据" class="headerlink" title="对象转换成JSON格式数据"></a>对象转换成JSON格式数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *JSON_dic &#x3D; @&#123;@&quot;id&quot;:@&quot;12&quot;,@&quot;name&quot;:@&quot;mark&quot;&#125;;</span><br><span class="line">BOOL isJSON &#x3D; [NSJSONSerialization isValidJSONObject:JSON_dic];</span><br><span class="line">if (isJSON) &#123;</span><br><span class="line">    NSLog(@&quot;可以进行转换&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    NSLog(@&quot;转换失败,请查看数据格式是否正确&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSArray *JSON_arr &#x3D; @[@&quot;name&quot;,@&quot;age&quot;,@&quot;number&quot;];</span><br><span class="line">BOOL JSON &#x3D; [NSJSONSerialization isValidJSONObject:JSON_arr];</span><br><span class="line">if (JSON) &#123;</span><br><span class="line">    NSLog(@&quot;可以进行转换&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    NSLog(@&quot;转换失败,请查看数据格式是否正确&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析JSON数据"><a href="#解析JSON数据" class="headerlink" title="解析JSON数据"></a>解析JSON数据</h4><h5 id="第三方TouchJSON"><a href="#第三方TouchJSON" class="headerlink" title="第三方TouchJSON"></a>第三方TouchJSON</h5><p><a href="https://github.com/TouchCode/TouchJSON" target="_blank" rel="noopener">TouchJSON</a></p><h5 id="第三方SBJson"><a href="#第三方SBJson" class="headerlink" title="第三方SBJson"></a>第三方SBJson</h5><p><a href="https://github.com/stig/json-framework.git" target="_blank" rel="noopener">SBJson</a></p><h5 id="iOS5之后NSJSONSerialization类-推荐使用"><a href="#iOS5之后NSJSONSerialization类-推荐使用" class="headerlink" title="iOS5之后NSJSONSerialization类(推荐使用)"></a>iOS5之后NSJSONSerialization类(推荐使用)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> NSData *data;</span><br><span class="line">id message &#x3D;  [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]</span><br></pre></td></tr></table></figure><h5 id="第三方JSONKit"><a href="#第三方JSONKit" class="headerlink" title="第三方JSONKit"></a>第三方JSONKit</h5><p><a href="https://github.com/johnezang/JSONKit" target="_blank" rel="noopener">JSONKit</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>系统的API的解析速度最快,<br>SBJSON的解析速度为倒数第二差,<br>与系统API较为接近的是JSONKit;</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据解析 </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个点击cell的动画效果</title>
      <link href="/2018/02/23/%E4%B8%80%E4%B8%AA%E7%82%B9%E5%87%BBcell%E7%82%AB%E9%85%B7%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
      <url>/2018/02/23/%E4%B8%80%E4%B8%AA%E7%82%B9%E5%87%BBcell%E7%82%AB%E9%85%B7%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天给大家介绍一个关于cell的比较炫酷的点击动画效果,具体效果请看下面  </p></blockquote><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/cell%E5%8A%A8%E6%80%81%E6%95%88%E6%9E%9C/3.gif" alt="image"></p><p>代码如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;点击状态</span><br><span class="line">-(void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    UITableViewCell *cell &#x3D; [tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">    [UIView beginAnimations:nil context:nil];</span><br><span class="line">    [UIView setAnimationDuration:0.2];</span><br><span class="line">    cell.transform &#x3D; CGAffineTransformMakeScale(0.87, 0.87);&#x2F;&#x2F;cell进行缩放</span><br><span class="line">    [UIView commitAnimations];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;复原</span><br><span class="line">-(void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    UITableViewCell *cell &#x3D; [tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">    [UIView beginAnimations:nil context:nil];</span><br><span class="line">    [UIView setAnimationDuration:0.2];</span><br><span class="line">    cell.transform &#x3D; CGAffineTransformMakeScale(1, 1);</span><br><span class="line">    [UIView commitAnimations];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cell </tag>
            
            <tag> 动画效果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC记录3--UIImagePickerController</title>
      <link href="/2018/01/23/OC%E8%AE%B0%E5%BD%953--UIImagePickerController/"/>
      <url>/2018/01/23/OC%E8%AE%B0%E5%BD%953--UIImagePickerController/</url>
      
        <content type="html"><![CDATA[<p><strong>UIImagePickerController一个获取图片和视频的类,简单特点:</strong> </p><blockquote><p>1,可获取相册,图库的图片;<br>2,可进行拍照,视频录制;<br>3,可对图片进行编辑;<br>4,可保存图片和视频到手机;<br>5,由下面方法推出:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion; </span><br></pre></td></tr></table></figure><p>6,只支持竖屏模式;</p></blockquote><a id="more"></a><h3 id="UIImagePickerController-h文件查看"><a href="#UIImagePickerController-h文件查看" class="headerlink" title="UIImagePickerController.h文件查看"></a>UIImagePickerController.h文件查看</h3><p>UIImagePickerController 父类继承关系<br>UIImagePickerController -&gt; UINavigationController -&gt; UIViewController -&gt; UIResponder -&gt; NSObject</p><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>1,当前UIImagePickerControllerSourceType类型是否可用;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isSourceTypeAvailable:(UIImagePickerControllerSourceType)sourceType;</span><br></pre></td></tr></table></figure><p>UIImagePickerControllerSourceType是一个枚举类型,表示打开类型:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIImagePickerControllerSourceType) &#123;</span><br><span class="line">    UIImagePickerControllerSourceTypePhotoLibrary,&#x2F;&#x2F;图库,所有图片</span><br><span class="line">    UIImagePickerControllerSourceTypeCamera,&#x2F;&#x2F;相机</span><br><span class="line">    UIImagePickerControllerSourceTypeSavedPhotosAlbum&#x2F;&#x2F;相册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2,返回一个当前相机支持类型,拍照,视频,拍照和视频等三种方式;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable NSArray&lt;NSString *&gt; *)availableMediaTypesForSourceType:(UIImagePickerControllerSourceType)sourceType;</span><br></pre></td></tr></table></figure><p>3,判断当前手机摄像头是否可用;    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isCameraDeviceAvailable:(UIImagePickerControllerCameraDevice)cameraDevice;</span><br></pre></td></tr></table></figure><p>UIImagePickerControllerCameraDevice是一个枚举类型,表示的是摄像头的方向;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIImagePickerControllerCameraDevice) &#123;</span><br><span class="line">    UIImagePickerControllerCameraDeviceRear,&#x2F;&#x2F;后置摄像头</span><br><span class="line">    UIImagePickerControllerCameraDeviceFront&#x2F;&#x2F;前置摄像头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4,判断手机前置摄像头或者后置摄像头是否支持闪光灯和手电筒;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isFlashAvailableForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice;</span><br></pre></td></tr></table></figure><p>5,判断手机不同摄像头支持的拍摄类型,有图片和视频;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable NSArray&lt;NSNumber *&gt; *)availableCaptureModesForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice</span><br></pre></td></tr></table></figure><p>UIImagePickerControllerCameraDevice一个枚举,表示摄像头支持拍摄类型;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIImagePickerControllerCameraCaptureMode) &#123;</span><br><span class="line">    UIImagePickerControllerCameraCaptureModePhoto,&#x2F;&#x2F;照片</span><br><span class="line">    UIImagePickerControllerCameraCaptureModeVideo&#x2F;&#x2F;视频</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>1,UIImagePickerController协议,包含本身UIImagePickerControllerDelegate和父类中的UINavigationControllerDelegate;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable,nonatomic,weak)id &lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><p>UIImagePickerControllerDelegate协议方法;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@optional&#x2F;&#x2F;该修饰词修饰的方法不要求强制实现</span><br><span class="line">&#x2F;&#x2F;需要在如下可用方法中关闭相册等界面,调用方法:  </span><br><span class="line">- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^ __nullable)(void))completion;</span><br><span class="line">&#x2F;&#x2F;该方法已经被废弃</span><br><span class="line">- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingImage:(UIImage *)image editingInfo:(nullable NSDictionary&lt;NSString *,id&gt; *)editingInfo NS_DEPRECATED_IOS(2_0, 3_0);</span><br><span class="line">&#x2F;&#x2F;获取到的图片或者视频的信息的回调</span><br><span class="line">- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info;</span><br><span class="line">info中的key值</span><br><span class="line">NSString *const UIImagePickerControllerMediaType &#x2F;&#x2F;用户指定的媒体类型:public.image或者是public.movie</span><br><span class="line">NSString *const UIImagePickerControllerOriginalImage  &#x2F;&#x2F;原始图片</span><br><span class="line">NSString *const UIImagePickerControllerEditedImage &#x2F;&#x2F;编辑后的图片</span><br><span class="line">NSString *const UIImagePickerControllerCropRect &#x2F;&#x2F;裁剪尺寸</span><br><span class="line">NSString *const UIImagePickerControllerMediaURL &#x2F;&#x2F; 媒体的url</span><br><span class="line">NSString *const UIImagePickerControllerReferenceURL &#x2F;&#x2F; NS_DEPRECATED_IOS(4_1, 11_0, &quot;Replace with public API: UIImagePickerControllerPHAsset&quot;) 原件的url</span><br><span class="line">UIImagePickerControllerMediaMetadata &#x2F;&#x2F; 图片的元数据</span><br><span class="line">NSString *const UIImagePickerControllerLivePhoto &#x2F;&#x2F;iOS9.1之后 所选或拍摄的照片的实时照片表示</span><br><span class="line">NSString *const UIImagePickerControllerPHAsset &#x2F;&#x2F; iOS11.0之后 原件的url</span><br><span class="line">NSString *const UIImagePickerControllerImageURL &#x2F;&#x2F;iOS11.0之后 包含图像文件的URL</span><br><span class="line">&#x2F;&#x2F;取消</span><br><span class="line">- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker;</span><br></pre></td></tr></table></figure><p>2,设置打开类型,UIImagePickerControllerSourceType,包含:图库,照相机,相册;默认是:UIImagePickerControllerSourceTypePhotoLibrary,图库  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic)UIImagePickerControllerSourceType  sourceType;</span><br></pre></td></tr></table></figure><p>3,在<strong>打开照相机</strong>下该值才有效,3中情况:只有拍照,只有视频,视频和拍照;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@[@&quot;public.image&quot;,@&quot;public.movie&quot;]</span><br><span class="line">@property(nonatomic,copy) NSArray&lt;NSString *&gt; *mediaTypes;&#x2F;&#x2F;kUTTypeImage</span><br></pre></td></tr></table></figure><p>4,获取到的图片(视频无效)是否可以编辑,默认为NO:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">@property(nonatomic)BOOL  allowsEditing NS_AVAILABLE_IOS(3_1);</span><br><span class="line">&#x2F;&#x2F;废弃</span><br><span class="line">@property(nonatomic)BOOL  allowsImageEditing NS_DEPRECATED_IOS(2_0, 3_1);</span><br></pre></td></tr></table></figure><p>5,获取到图片转换的类型,枚举类型;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;iOS11 的一个新属性,默认Current</span><br><span class="line">@property(nonatomic)UIImagePickerControllerImageURLExportPreset imageExportPreset NS_AVAILABLE_IOS(11_0);</span><br></pre></td></tr></table></figure><p>UIImagePickerControllerImageURLExportPreset </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIImagePickerControllerImageURLExportPreset) &#123;</span><br><span class="line">    UIImagePickerControllerImageURLExportPresetCompatible &#x3D; 0,&#x2F;&#x2F;jpeg</span><br><span class="line">    UIImagePickerControllerImageURLExportPresetCurrent&#x2F;&#x2F;data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6,视频模式下才有效,最大录制时间,默认10分钟;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic)NSTimeInterval   videoMaximumDuration;</span><br></pre></td></tr></table></figure><p>7,视频下有效,录制视频的质量,枚举类型;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic)UIImagePickerControllerQualityType  videoQuality NS_AVAILABLE_IOS(3_1);</span><br></pre></td></tr></table></figure><p>UIImagePickerControllerQualityType  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIImagePickerControllerQualityType) &#123;</span><br><span class="line">    UIImagePickerControllerQualityTypeHigh &#x3D; 0,       &#x2F;&#x2F; 高质量</span><br><span class="line">    UIImagePickerControllerQualityTypeMedium &#x3D; 1,     &#x2F;&#x2F; 适合WiFi下的质量</span><br><span class="line">    UIImagePickerControllerQualityTypeLow &#x3D; 2,         &#x2F;&#x2F;低质量</span><br><span class="line">    UIImagePickerControllerQualityType640x480 NS_ENUM_AVAILABLE_IOS(4_0) &#x3D; 3,    &#x2F;&#x2F; VGA 640x480</span><br><span class="line">    UIImagePickerControllerQualityTypeIFrame1280x720 NS_ENUM_AVAILABLE_IOS(5_0) &#x3D; 4,&#x2F;&#x2F;1280x720</span><br><span class="line">    UIImagePickerControllerQualityTypeIFrame960x540 NS_ENUM_AVAILABLE_IOS(5_0) &#x3D; 5,&#x2F;&#x2F;960x540</span><br><span class="line">&#125; __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure><p>8,视频压缩质量,当为nil时,默认使用第七点中videoQuality的值;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;AVAssetExportPreset* string,该属性在iOS 11后生效</span><br><span class="line">@property(nonatomic, copy)NSString *videoExportPreset NS_AVAILABLE_IOS(11_0);</span><br></pre></td></tr></table></figure><h4 id="自定义相机UI-属性-方法"><a href="#自定义相机UI-属性-方法" class="headerlink" title="自定义相机UI,属性,方法"></a>自定义相机UI,属性,方法</h4><p>在UIImagePickerControllerSourceTypeCamera下有效;</p><p>1,是否隐藏系统相机自带的的UI,默认是YES;设置为NO时,隐藏系统相机UI;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic)BOOL  showsCameraControls</span><br></pre></td></tr></table></figure><p>2,设置一个覆盖相机的view; preview对应的图层表示的是相机所在的view层;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable, nonatomic,strong) __kindof UIView *cameraOverlayView  NS_AVAILABLE_IOS(3_1);   &#x2F;&#x2F; set a view to overlay the preview view.</span><br></pre></td></tr></table></figure><p>3,设置preview的CGAffineTransform, CGAffineTransform是一个用于处理形变的类,其可以改变控件的平移、缩放、旋转等,其坐标系统采用的是二维坐标系,即向右为x轴正方向,向下为y轴正方向;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic)CGAffineTransform cameraViewTransform NS_AVAILABLE_IOS(3_1);   &#x2F;&#x2F; set the transform of the preview view.</span><br></pre></td></tr></table></figure><p>4,拍照;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)takePicture;</span><br></pre></td></tr></table></figure><p>5,开始录像,停止录像;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)startVideoCapture;</span><br><span class="line">- (void)stopVideoCapture;</span><br></pre></td></tr></table></figure><p>6,摄像头支持类型,默认是照片:UIImagePickerControllerCameraCaptureModePhoto;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic) UIImagePickerControllerCameraCaptureMode cameraCaptureMode NS_AVAILABLE_IOS(4_0);</span><br></pre></td></tr></table></figure><p>7,摄像头方向,默认使用后置摄像头:UIImagePickerControllerCameraDeviceRear;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic) UIImagePickerControllerCameraDevice    cameraDevice      NS_AVAILABLE_IOS(4_0);</span><br></pre></td></tr></table></figure><p>8,摄像头闪光灯模式,默认自动:UIImagePickerControllerCameraFlashModeAuto;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic) UIImagePickerControllerCameraFlashMode  cameraFlashMode   NS_AVAILABLE_IOS(4_0);</span><br></pre></td></tr></table></figure><h4 id="扩展函数-保存照片和视频到图库"><a href="#扩展函数-保存照片和视频到图库" class="headerlink" title="扩展函数:保存照片和视频到图库"></a>扩展函数:保存照片和视频到图库</h4><h5 id="保存图片到图库"><a href="#保存图片到图库" class="headerlink" title="保存图片到图库"></a>保存图片到图库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN void UIImageWriteToSavedPhotosAlbum(UIImage *image, __nullable id completionTarget, __nullable SEL completionSelector, void * __nullable contextInfo)</span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">UIImageWriteToSavedPhotosAlbum(self.selectImageView.image, self, @selector(image:  didFinishSavingWithError: contextInfo:), nil);</span><br><span class="line">&#x2F;&#x2F;保存状态</span><br><span class="line">- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123;</span><br><span class="line">    if (error &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        NSLog(@&quot;保存相册成功&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;保存失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断当前路径下的视频是否可以保存到相册"><a href="#判断当前路径下的视频是否可以保存到相册" class="headerlink" title="判断当前路径下的视频是否可以保存到相册;"></a>判断当前路径下的视频是否可以保存到相册;</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN BOOL UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(NSString *videoPath)</span><br></pre></td></tr></table></figure><h5 id="保存视频到图库"><a href="#保存视频到图库" class="headerlink" title="保存视频到图库"></a>保存视频到图库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN void UISaveVideoAtPathToSavedPhotosAlbum(NSString *videoPath, __nullable id completionTarget, __nullable SEL completionSelector, void * __nullable contextInfo)</span><br><span class="line">&#x2F;&#x2F;调用, videoPath视频路径</span><br><span class="line">UISaveVideoAtPathToSavedPhotosAlbum([info[UIImagePickerControllerMediaURL] path], self, @selector(video: didFinishSavingWithError: contextInfo:), nil);</span><br><span class="line">&#x2F;&#x2F;保存状态</span><br><span class="line">- (void)video:(NSString *)videoPath didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123;</span><br><span class="line">    if (error &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        NSLog(@&quot;保存视频成功&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;视频保存失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS学习 </tag>
            
            <tag> 相册 </tag>
            
            <tag> 相机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC记录2--UIDatePicker</title>
      <link href="/2018/01/18/UIDatePicker/"/>
      <url>/2018/01/18/UIDatePicker/</url>
      
        <content type="html"><![CDATA[<p>官方描述:</p><blockquote><p>A control used for the inputting of date and time values.<br>You can use a date picker to allow a user to enter either a point in time (calendar date, time value or both) or a time interval (for example for a timer). The date picker reports interactions to its associated target object.</p></blockquote><p>译文:</p><blockquote><p>用于输入日期和时间值的控件。您可以使用日期选择器来允许用户输入时间点（日历日期，时间值或两者）或时间间隔（例如，计时器）。日期选择器向与其关联的目标对象报告交互。</p></blockquote><a id="more"></a><h3 id="UIDatePicker头文件-h查看"><a href="#UIDatePicker头文件-h查看" class="headerlink" title="UIDatePicker头文件.h查看"></a>UIDatePicker头文件.h查看</h3><p><strong>UIDatePicker继承关系:UIDatePicker-&gt;UIControl-&gt;UIView</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UIDatePicker : UIControl &lt;NSCoding&gt;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="UIDatePicker样式-枚举UIDatePickerMode-该属性默认是UIDatePickerModeDateAndTime"><a href="#UIDatePicker样式-枚举UIDatePickerMode-该属性默认是UIDatePickerModeDateAndTime" class="headerlink" title="UIDatePicker样式:枚举UIDatePickerMode,该属性默认是UIDatePickerModeDateAndTime"></a>UIDatePicker样式:枚举UIDatePickerMode,该属性默认是UIDatePickerModeDateAndTime</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) UIDatePickerMode datePickerMode; &#x2F;&#x2F; default is UIDatePickerModeDateAndTime</span><br></pre></td></tr></table></figure><p>枚举UIDatePickerMode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIDatePickerMode) &#123;</span><br><span class="line">    UIDatePickerModeTime,           &#x2F;&#x2F; Displays hour, minute, and optionally AM&#x2F;PM designation depending on the locale setting (e.g. 6 | 53 | PM)</span><br><span class="line">    UIDatePickerModeDate,           &#x2F;&#x2F; Displays month, day, and year depending on the locale setting (e.g. November | 15 | 2007)</span><br><span class="line">    UIDatePickerModeDateAndTime,    &#x2F;&#x2F; Displays date, hour, minute, and optionally AM&#x2F;PM designation depending on the locale setting (e.g. Wed Nov 15 | 6 | 53 | PM)</span><br><span class="line">    UIDatePickerModeCountDownTimer, &#x2F;&#x2F; Displays hour and minute (e.g. 1 | 53)</span><br><span class="line">&#125; __TVOS_PROHIBITED</span><br></pre></td></tr></table></figure><p><strong>UIDatePickerModeTime:只展示小时,分钟和AM(早上),PM(下午)</strong> </p><blockquote><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/UIDatePicker/UIDatePickerModeTime.png" alt="image">  </p></blockquote><p><strong>UIDatePickerModeDate:展示年月日</strong>    </p><blockquote><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/UIDatePicker/UIDatePickerModeDate.png" alt="image">  </p></blockquote><p><strong>UIDatePickerModeDateAndTime:展示日期和时间</strong>  </p><blockquote><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/UIDatePicker/UIDatePickerModeDateAndTime.png" alt="image">  </p></blockquote><p><strong>UIDatePickerModeCountDownTimer:倒计时模式</strong>  </p><blockquote><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/UIDatePicker/UIDatePickerModeCountDownTimer.png" alt="image"></p></blockquote><h5 id="locale-本地化"><a href="#locale-本地化" class="headerlink" title="locale:本地化"></a>locale:本地化</h5><p>该属性表示的是设置日期展示的语言,不进行设置时,默认手机系统当前语言;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, nonatomic, strong) NSLocale   *locale;   &#x2F;&#x2F; default is [NSLocale currentLocale]. setting nil returns to default</span><br></pre></td></tr></table></figure><p>创建方式:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[NSLocale alloc]initWithLocaleIdentifier:@&quot;zh_Hant_TW&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;简体中文:zh_Hans_CN,zh_Hans_HK,zh_Hans_MO,zh_Hans,zh,zh_Hans_SG,zh_Hans_CN</span><br><span class="line">&#x2F;&#x2F;繁体中文:zh_Hant,zh_Hant_HK,zh_Hant_MO,zh_Hant_TW</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取可以的本地化标识</span><br><span class="line">[NSLocale availableLocaleIdentifiers];</span><br></pre></td></tr></table></figure><h5 id="calendar-不进行设置时-默认是当前日期"><a href="#calendar-不进行设置时-默认是当前日期" class="headerlink" title="calendar:不进行设置时,默认是当前日期"></a>calendar:不进行设置时,默认是当前日期</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (null_resettable, nonatomic, copy)   NSCalendar *calendar; &#x2F;&#x2F; default is [NSCalendar currentCalendar]. setting nil returns to default</span><br></pre></td></tr></table></figure><h5 id="timeZone-时区-不进行设置时-默认为nil-日期来自属性calendar"><a href="#timeZone-时区-不进行设置时-默认为nil-日期来自属性calendar" class="headerlink" title="timeZone:时区,不进行设置时,默认为nil,日期来自属性calendar"></a>timeZone:时区,不进行设置时,默认为nil,日期来自属性calendar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, nonatomic, strong) NSTimeZone *timeZone; &#x2F;&#x2F; default is nil. use current time zone or time zone from calendar</span><br></pre></td></tr></table></figure><h5 id="date-默认选中日期-当不进行设置时-默认当前日期"><a href="#date-默认选中日期-当不进行设置时-默认当前日期" class="headerlink" title="date:默认选中日期,当不进行设置时,默认当前日期;"></a>date:默认选中日期,当不进行设置时,默认当前日期;</h5><p>并且UIDatePickerModeCountDownTimer模式下的设置对其并没有作用;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSDate *date;        &#x2F;&#x2F; default is current date when picker created. Ignored in countdown timer mode. for that mode, picker starts at 0:00</span><br></pre></td></tr></table></figure><h5 id="minimumDate-最小能选择的日期-当不设置时-理论上没有最小限制"><a href="#minimumDate-最小能选择的日期-当不设置时-理论上没有最小限制" class="headerlink" title="minimumDate:最小能选择的日期,当不设置时,理论上没有最小限制;"></a>minimumDate:最小能选择的日期,当不设置时,理论上没有最小限制;</h5><p>并且如果min &gt; max 该值会失效;在UIDatePickerModeCountDownTimer无效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, nonatomic, strong) NSDate *minimumDate; &#x2F;&#x2F; specify min&#x2F;max date range. default is nil. When min &gt; max, the values are ignored. Ignored in countdown timer mode</span><br></pre></td></tr></table></figure><h5 id="maximumDate-最大能选择的日期-当不设置时-理论上没有最大限制"><a href="#maximumDate-最大能选择的日期-当不设置时-理论上没有最大限制" class="headerlink" title="maximumDate:最大能选择的日期,当不设置时,理论上没有最大限制;"></a>maximumDate:最大能选择的日期,当不设置时,理论上没有最大限制;</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, nonatomic, strong) NSDate *maximumDate; &#x2F;&#x2F; default is nil</span><br></pre></td></tr></table></figure><h5 id="countDownDuration-倒计时剩下秒数-最大23-59-86399秒"><a href="#countDownDuration-倒计时剩下秒数-最大23-59-86399秒" class="headerlink" title="countDownDuration:倒计时剩下秒数,最大23:59(86399秒)"></a>countDownDuration:倒计时剩下秒数,最大23:59(86399秒)</h5><p>只在UIDatePickerModeCountDownTimer有效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) NSTimeInterval countDownDuration; &#x2F;&#x2F; for UIDatePickerModeCountDownTimer, ignored otherwise. default is 0.0. limit is 23:59 (86,399 seconds). value being set is div 60 (drops remaining seconds).</span><br></pre></td></tr></table></figure><h5 id="minuteInterval-分钟间隔-默认是1-最大是30"><a href="#minuteInterval-分钟间隔-默认是1-最大是30" class="headerlink" title="minuteInterval:分钟间隔,默认是1,最大是30"></a>minuteInterval:分钟间隔,默认是1,最大是30</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) NSInteger      minuteInterval;    &#x2F;&#x2F; display minutes wheel with interval. interval must be evenly divided into 60. default is 1. min is 1, max is 30</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>滑动到设置的时间日期,是否需要动画效果;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDate:(NSDate *)date animated:(BOOL)animated; &#x2F;&#x2F; if animated is YES, animate the wheels of time to display the new date</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC记录1--UIPickerView</title>
      <link href="/2018/01/17/UIPickerView--OC%E8%AE%B0%E5%BD%95%E4%B8%80/"/>
      <url>/2018/01/17/UIPickerView--OC%E8%AE%B0%E5%BD%95%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>UIPickerView官方描述:</p><blockquote><p>A view that uses a spinning-wheel or slot-machine metaphor to show one or more sets of values.<br>A picker view displays one or more wheels that the user manipulates to select items. Each wheel—known as a component—has a series of indexed rows representing the selectable items. Each row displays a string or view so that the user can identify the item on that row. Users select items by rotating the wheels to the desired values, which align with a selection indicator.</p></blockquote><p>译文:</p><blockquote><p>使用旋转轮或狭缝机隐喻显示一组或多组值的视图。<br>选取器视图显示用户操纵选择项目的一个或多个轮子。每个车轮（称为组件）都有一系列代表可选项目的索引行。每行显示一个字符串或视图，以便用户可以识别该行上的项目。用户通过将车轮旋转到与选择指示符对齐的期望值来选择项目。 </p></blockquote><a id="more"></a><p><strong>下面开始UIPickerView学习:</strong>  </p><h3 id="查看UIPickerView类中的-h文件"><a href="#查看UIPickerView类中的-h文件" class="headerlink" title="查看UIPickerView类中的.h文件"></a>查看UIPickerView类中的.h文件</h3><p>UIPickerView父类是UIView;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UIPickerView : UIView &lt;NSCoding&gt;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>1,显示选中指示器,目前设置为NO或者为YES都没有什么影响;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic)BOOL showsSelectionIndicator;</span><br></pre></td></tr></table></figure><p>2,当前UIPickerView的component数,为只读属性;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly) NSInteger numberOfComponents;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>1,获取某一个component的行数:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)numberOfRowsInComponent:(NSInteger)component;</span><br></pre></td></tr></table></figure><p>2,获取某个component行的size大小:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)rowSizeForComponent:(NSInteger)component;</span><br></pre></td></tr></table></figure><p>3,返回一个view,来自协议方法:pickerView:viewForRow:forComponent:reusingView:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; returns the view provided by the delegate via pickerView:viewForRow:forComponent:reusingView:</span><br><span class="line">&#x2F;&#x2F; or nil if the row&#x2F;component is not visible or the delegate does not implement </span><br><span class="line">&#x2F;&#x2F; pickerView:viewForRow:forComponent:reusingView:</span><br><span class="line">- (nullable UIView *)viewForRow:(NSInteger)row forComponent:(NSInteger)component;</span><br></pre></td></tr></table></figure><p>4,刷新所有component和单个component:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)reloadAllComponents;&#x2F;&#x2F;刷新所有component</span><br><span class="line">- (void)reloadComponent:(NSInteger)component;&#x2F;&#x2F;刷新单个component</span><br></pre></td></tr></table></figure><p>5,滑动到某个component的某行,animated表示是否要动画效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component animated:(BOOL)animated;</span><br></pre></td></tr></table></figure><p>6,获取当前选中的行, -1 if nothing selected:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)selectedRowInComponent:(NSInteger)component;</span><br><span class="line"> &#x2F;&#x2F; returns selected row. -1 if nothing selected</span><br></pre></td></tr></table></figure><h4 id="实现的2个协议-UIPickerViewDataSource-UIPickerViewDelegate"><a href="#实现的2个协议-UIPickerViewDataSource-UIPickerViewDelegate" class="headerlink" title="实现的2个协议: UIPickerViewDataSource,UIPickerViewDelegate"></a>实现的2个协议: UIPickerViewDataSource,UIPickerViewDelegate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable,nonatomic,weak) id&lt;UIPickerViewDataSource&gt; dataSource;                &#x2F;&#x2F; default is nil. weak reference</span><br><span class="line">@property(nullable,nonatomic,weak) id&lt;UIPickerViewDelegate&gt;   delegate;                  &#x2F;&#x2F; default is nil. weak reference</span><br></pre></td></tr></table></figure><p>1,UIPickerViewDataSource</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@required &#x2F;&#x2F;表示下面协议方法必须实现</span><br><span class="line">&#x2F;&#x2F;返回component的个数</span><br><span class="line">&#x2F;&#x2F; returns the number of &#39;columns&#39; to display.</span><br><span class="line">- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView;</span><br><span class="line">&#x2F;&#x2F;返回某个component中行数</span><br><span class="line">&#x2F;&#x2F; returns the # of rows in each component..</span><br><span class="line">- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>2,UIPickerViewDelegate,由@optional进行修饰,表示该协议下的方法可以选择性的实现:</p><p>2.1,设置component的宽和高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; returns width of column and height of row for each component. </span><br><span class="line">- (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component __TVOS_PROHIBITED;</span><br><span class="line">- (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure><p>2.2,返回每一行的展示数据,数据类型是:NSString或者是NSAttributedString</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component __TVOS_PROHIBITED;</span><br><span class="line">- (nullable NSAttributedString *)pickerView:(UIPickerView *)pickerView attributedTitleForRow:(NSInteger)row forComponent:(NSInteger)component NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED; &#x2F;&#x2F; attributed title is favored if both methods are implemented</span><br></pre></td></tr></table></figure><p>2.3,每一个component行数中的view,可以进行自定义:但必须是UILabel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(nullable UIView *)view __TVOS_PROHIBITED;</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line"></span><br><span class="line">-(UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view&#123;</span><br><span class="line">    &#x2F;&#x2F;设置字体大小;</span><br><span class="line">    UILabel *lbl &#x3D; (UILabel *)view;</span><br><span class="line">    if (lbl &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        lbl &#x3D; [[UILabel alloc]init];</span><br><span class="line">        &#x2F;&#x2F;在这里设置字体相关属性</span><br><span class="line">        lbl.font &#x3D; [UIFont systemFontOfSize:13];</span><br><span class="line">        lbl.textColor &#x3D; [UIColor grayColor];</span><br><span class="line">        lbl.textAlignment &#x3D; NSTextAlignmentCenter;</span><br><span class="line">        [lbl setBackgroundColor:[UIColor clearColor]];</span><br><span class="line">        if (component &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            lbl.textColor &#x3D; [UIColor redColor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重新加载lbl的文字内容</span><br><span class="line">    lbl.text &#x3D; [self pickerView:pickerView titleForRow:row forComponent:component];</span><br><span class="line">    return lbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.4,当前选中的component和row</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="默认大小"><a href="#默认大小" class="headerlink" title="默认大小"></a>默认大小</h4><p>1,当UIPickerView没有设置frame值时,默认宽是320,高是216;  </p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-17%20%E4%B8%8B%E5%8D%887.09.02.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> iOS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个简单省市选择器</title>
      <link href="/2018/01/15/%E4%B8%80%E4%B8%AA%E7%9C%81+%E5%9F%8E%E5%B8%82%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2018/01/15/%E4%B8%80%E4%B8%AA%E7%9C%81+%E5%9F%8E%E5%B8%82%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>一个比较简单的省市选择器,效果如下:</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%9C%81%E5%B8%82%E9%80%89%E6%8B%A9%E5%99%A8/area-show.gif" alt="image">  </p><p><strong><a href="https://github.com/zhuyunsun/FDAreaPicker" target="_blank" rel="noopener">github传送门</a></strong></p><h4 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h4><a id="more"></a><p>初始化:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_areaPicker &#x3D; [[FDAreaPicker alloc]init];</span><br><span class="line">_areaPicker.delegate &#x3D; self;</span><br></pre></td></tr></table></figure><p>展示:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_areaPicker showAreaView];</span><br></pre></td></tr></table></figure><p>delegate回调:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; delegate &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">-(void)cancelAction&#123;</span><br><span class="line">    NSLog(@&quot;cancel&quot;);</span><br><span class="line">&#125;</span><br><span class="line">-(void)selectArea:(NSString *)area&#123;</span><br><span class="line">    _selectLabel.text &#x3D; area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择器 </tag>
            
            <tag> 城市 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加,修改Github上项目的md文件</title>
      <link href="/2018/01/11/%E6%B7%BB%E5%8A%A0,%E4%BF%AE%E6%94%B9Github%E4%B8%8A%E9%9D%A2%E9%A1%B9%E7%9B%AE%E7%9A%84md%E6%96%87%E4%BB%B6/"/>
      <url>/2018/01/11/%E6%B7%BB%E5%8A%A0,%E4%BF%AE%E6%94%B9Github%E4%B8%8A%E9%9D%A2%E9%A1%B9%E7%9B%AE%E7%9A%84md%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>github上面的md文件其实就是markdown文件的缩写,所以md遵循markdown语法</strong><a id="more"></a></p><h2 id="添加md文件"><a href="#添加md文件" class="headerlink" title="添加md文件"></a>添加md文件</h2><h3 id="为上传的工程添加md文件"><a href="#为上传的工程添加md文件" class="headerlink" title="为上传的工程添加md文件"></a>为上传的工程添加md文件</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/add.png" alt="image"></p><h3 id="md文件名字是可以进行修改的"><a href="#md文件名字是可以进行修改的" class="headerlink" title="md文件名字是可以进行修改的"></a>md文件名字是可以进行修改的</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/md%E5%90%8D%E5%AD%97%E5%8F%AF%E6%94%B9.png" alt="image"></p><h3 id="写完之后-commit-md文件-到这一步你已经为你的工程新添加了md文件"><a href="#写完之后-commit-md文件-到这一步你已经为你的工程新添加了md文件" class="headerlink" title="写完之后,commit md文件,到这一步你已经为你的工程新添加了md文件"></a>写完之后,commit md文件,到这一步你已经为你的工程新添加了md文件</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E6%8F%90%E4%BA%A4%E4%BF%AE%E6%94%B9%E7%9A%84md.png" alt="image">  </p><h2 id="修改md文件"><a href="#修改md文件" class="headerlink" title="修改md文件"></a>修改md文件</h2><h3 id="查找工程文件入口"><a href="#查找工程文件入口" class="headerlink" title="查找工程文件入口"></a>查找工程文件入口</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/md%E5%85%A5%E5%8F%A3.png" alt="image"></p><h3 id="找到要修改的md文件"><a href="#找到要修改的md文件" class="headerlink" title="找到要修改的md文件"></a>找到要修改的md文件</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E6%89%BE%E5%88%B0%E7%BC%96%E8%BE%91%E7%9A%84md.png" alt="image"></p><h3 id="重新进行编辑md文件"><a href="#重新进行编辑md文件" class="headerlink" title="重新进行编辑md文件"></a>重新进行编辑md文件</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E9%87%8D%E6%96%B0%E7%BC%96%E8%BE%91md.png" alt="image"></p><h3 id="最后-编辑完成后-提交修改后md文件"><a href="#最后-编辑完成后-提交修改后md文件" class="headerlink" title="最后,编辑完成后,提交修改后md文件"></a>最后,编辑完成后,提交修改后md文件</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E6%8F%90%E4%BA%A4%E4%BF%AE%E6%94%B9%E7%9A%84md.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传工程到github网站</title>
      <link href="/2018/01/11/%E4%BD%BF%E7%94%A8GithubDesktop%E4%B8%8A%E4%BC%A0%E5%B7%A5%E7%A8%8B%E5%88%B0github/"/>
      <url>/2018/01/11/%E4%BD%BF%E7%94%A8GithubDesktop%E4%B8%8A%E4%BC%A0%E5%B7%A5%E7%A8%8B%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<p><strong>使用<a href="https://desktop.github.com/" target="_blank" rel="noopener">GithubDesktop</a>上传项目到GitHub网站.</strong>  </p><h4 id="add-选择要上传的项目-然后点击右下角的按钮"><a href="#add-选择要上传的项目-然后点击右下角的按钮" class="headerlink" title="add:选择要上传的项目,然后点击右下角的按钮"></a>add:选择要上传的项目,然后点击右下角的按钮</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/%E4%B8%8A%E4%BC%A0%E5%B7%A5%E7%A8%8B%E5%88%B0github/add.png" alt="image">  </p><h4 id="上一步已经把项目add到GithubDesktop中-添加Summary信息-Description可不填-然后Commit-to-master"><a href="#上一步已经把项目add到GithubDesktop中-添加Summary信息-Description可不填-然后Commit-to-master" class="headerlink" title="上一步已经把项目add到GithubDesktop中,添加Summary信息,Description可不填,然后Commit to master"></a>上一步已经把项目add到GithubDesktop中,添加Summary信息,Description可不填,然后Commit to master</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/%E4%B8%8A%E4%BC%A0%E5%B7%A5%E7%A8%8B%E5%88%B0github/commit_action.png" alt="image"></p><h4 id="添加成功效果如下"><a href="#添加成功效果如下" class="headerlink" title="添加成功效果如下"></a>添加成功效果如下</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/%E4%B8%8A%E4%BC%A0%E5%B7%A5%E7%A8%8B%E5%88%B0github/commit_success1.png" alt="image"></p><h4 id="最后一步-点击右上角Publish按钮-Description可不填-把项目推到Github网站"><a href="#最后一步-点击右上角Publish按钮-Description可不填-把项目推到Github网站" class="headerlink" title="最后一步:点击右上角Publish按钮,Description可不填,把项目推到Github网站;"></a>最后一步:点击右上角Publish按钮,Description可不填,把项目推到Github网站;</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/%E4%B8%8A%E4%BC%A0%E5%B7%A5%E7%A8%8B%E5%88%B0github/publish.png" alt="image"></p><h4 id="到此-登录Github账号就能发现项目存在啦"><a href="#到此-登录Github账号就能发现项目存在啦" class="headerlink" title="到此,登录Github账号就能发现项目存在啦;"></a>到此,登录Github账号就能发现项目存在啦;</h4>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个自定义日期选择器(年月日)</title>
      <link href="/2018/01/09/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9(%E5%B9%B4%E6%9C%88%E6%97%A5)/"/>
      <url>/2018/01/09/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9(%E5%B9%B4%E6%9C%88%E6%97%A5)/</url>
      
        <content type="html"><![CDATA[<p><strong>最近项目中需要用到生日的选择,用到了日期选择器;<br>而系统自带的UIDatePicker又不符合要求,所以自定义了一个;</strong>  </p><p>效果先奉上:</p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/date-show.gif" alt="image">  </p><p>地址:<a href="https://github.com/zhuyunsun/FDDatePicker" target="_blank" rel="noopener">github地址</a></p><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><h4 id="设置默认日期"><a href="#设置默认日期" class="headerlink" title="设置默认日期"></a>设置默认日期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong)NSString *beginYear;&#x2F;**&lt;开始年份*&#x2F;</span><br><span class="line">@property(nonatomic,strong)NSString *endYear;&#x2F;**&lt;结束年份*&#x2F;</span><br><span class="line">@property(nonatomic,strong)NSString *year;&#x2F;**&lt;默认年份*&#x2F;</span><br><span class="line">@property(nonatomic,strong)NSString *month;&#x2F;**&lt;默认月份*&#x2F;</span><br><span class="line">@property(nonatomic,strong)NSString *day;&#x2F;**&lt;默认日份*&#x2F;</span><br><span class="line">@property(nonatomic)BOOL keepDate;&#x2F;**&lt;是否保存上一次的日期选择状态,默认是YES*&#x2F;</span><br><span class="line"></span><br><span class="line">datePicker &#x3D; [[FDDatePicker alloc]init];</span><br><span class="line">datePicker.delegate &#x3D; self;</span><br><span class="line">datePicker.month &#x3D; @&quot;12&quot;;</span><br><span class="line">datePicker.day &#x3D; @&quot;12&quot;;</span><br><span class="line">datePicker.year &#x3D; @&quot;1990&quot;;</span><br><span class="line">datePicker.beginYear &#x3D; @&quot;1949&quot;;</span><br><span class="line">datePicker.endYear &#x3D; @&quot;2000&quot;;</span><br><span class="line">datePicker.keepDate &#x3D; NO;</span><br></pre></td></tr></table></figure><h4 id="展示界面"><a href="#展示界面" class="headerlink" title="展示界面"></a>展示界面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[datePicker showPickerView];</span><br></pre></td></tr></table></figure><h4 id="协议回调"><a href="#协议回调" class="headerlink" title="协议回调"></a>协议回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)selectDate:(NSString *)dateString&#123;</span><br><span class="line">    NSLog(@&quot;选择的日期&#x3D;%@&quot;,dateString);</span><br><span class="line">    _selectDateLabel.text &#x3D; dateString;</span><br><span class="line">&#125;</span><br><span class="line">-(void)cancleAction&#123;</span><br><span class="line">    NSLog(@&quot;取消&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择器 </tag>
            
            <tag> 自定义 </tag>
            
            <tag> 日期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS截取当前屏幕保存到相册</title>
      <link href="/2018/01/09/iOS%E5%BC%80%E5%8F%91%E6%88%AA%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95/"/>
      <url>/2018/01/09/iOS%E5%BC%80%E5%8F%91%E6%88%AA%E5%8F%96%E5%BD%93%E5%89%8D%E5%B1%8F%E5%B9%95/</url>
      
        <content type="html"><![CDATA[<p><strong>话不多说,直接看代码</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+(UIImage *)captureScreenForView:(UIView *)currentView&#123;</span><br><span class="line">    &#x2F;&#x2F;currentView 截取的view</span><br><span class="line">    UIGraphicsBeginImageContext(currentView.frame.size);</span><br><span class="line">    [currentView.layer renderInContext:UIGraphicsGetCurrentContext()];</span><br><span class="line">    UIImage *viewImage &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    &#x2F;&#x2F;保存到相册</span><br><span class="line">    UIImageWriteToSavedPhotosAlbum(viewImage,nil,nil,nil);</span><br><span class="line">    return  viewImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 截取屏幕 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App内跳转qq群</title>
      <link href="/2017/12/13/App%E5%86%85%E8%B7%B3%E8%BD%ACqq%E7%BE%A4/"/>
      <url>/2017/12/13/App%E5%86%85%E8%B7%B3%E8%BD%ACqq%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>开发的时候,有时候需要在当前app内直接跳转到某个qq群的界面;<br>下面介绍下如何进行接入:  </p><h4 id="在工程内配置允许跳转的白名单"><a href="#在工程内配置允许跳转的白名单" class="headerlink" title="在工程内配置允许跳转的白名单"></a>在工程内配置允许跳转的白名单</h4><p>1,在xcode工程中的info.plist文件中添加LSApplicationQueriesSchemes字段,它是一个数组,<br>然后添加:<br>mqqapi 字段;  </p><h4 id="获取跳转qq群的uin参数和key参数"><a href="#获取跳转qq群的uin参数和key参数" class="headerlink" title="获取跳转qq群的uin参数和key参数"></a>获取跳转qq群的uin参数和key参数</h4><p><a href="https://qun.qq.com/join.html" target="_blank" rel="noopener">获取地址</a><br>需要登录qq账号,选择要跳转的群,然后网页右边会自动生成对应语言跳转的方法;<br>OC语言开发的格式如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)joinGroup:(NSString *)groupUin key:(NSString *)key&#123;</span><br><span class="line">NSString *urlStr &#x3D; [NSString stringWithFormat:@&quot;mqqapi:&#x2F;&#x2F;card&#x2F;show_pslcard?src_type&#x3D;internal&amp;version&#x3D;1&amp;uin&#x3D;%@&amp;key&#x3D;%@&amp;card_type&#x3D;group&amp;source&#x3D;external&quot;, @&quot;对应的uin&quot;,@&quot;对应的key&quot;];</span><br><span class="line">NSURL *url &#x3D; [NSURL URLWithString:urlStr];</span><br><span class="line">if([[UIApplication sharedApplication] canOpenURL:url])&#123;</span><br><span class="line">[[UIApplication sharedApplication] openURL:url];</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">else return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> App开发 </tag>
            
            <tag> iOS开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习之-基本类型</title>
      <link href="/2017/09/27/Swift%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/09/27/Swift%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>Swift较OC的基本类型关键字有一些明显变化,但基本类型是基本没有变化的.<a id="more"></a>  </p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>OC之前用的是int或者NSInteger来表示整数;<br>而Swift使用的是Int;Int它拥有与当前平台的原生字相同的长度;  </p><p>在32位平台上,Int的长度和Int32相同;<br>在64位平台上,Int的长度和Int64相同;  </p><p>Int可以存储-2,147,483,648到2,147,483,647之间的任意值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let count:Int &#x3D; 3</span><br><span class="line">var amount:Int &#x3D; 6</span><br></pre></td></tr></table></figure><p>Swift也提供了一种无符号的整型类型:UInt,它与当前平台的原生字长相同.</p><p> 在32位平台上， UInt 长度和 UInt32 长度相同.<br> 在64位平台上， UInt 长度和 UInt64 长度相同.  </p><blockquote><p>注意:<br>只在的确需要存储一个和当前平台原生字长度相同的无符号整数的时候才使用UInt.其他情况下,推荐使用Int.  </p></blockquote><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点数是有小数的数字,如3.5,12.6;<br>浮点型相比整数类型来说,能表示更大范围的值或存储更小的数字.<br>Swift提供了两种有符号的浮点数类型;  </p><p>Double代表64位的浮点数;<br>Float代表32位的浮点数;  </p><blockquote><p>注意:<br>Double 有至少15位数字的精度,而Float的精度只有6位.<br>具体用哪一种取决于你代码需要处理的值得范围,在两种类型都可以的情况下,推荐使用Double类型;  </p></blockquote><p><strong>CGFloat:对于需要兼容64位的机器而言,则需要使用CGFloat;而不是Float;</strong>  </p><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>OC之前用YES和NO来表示;<br>而Swift则用更直白的false和true来表示;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let on &#x3D; true</span><br><span class="line">var off &#x3D; false</span><br><span class="line">off &#x3D; true</span><br><span class="line"></span><br><span class="line">if on &#123;</span><br><span class="line">    print(1)</span><br><span class="line">&#125;</span><br><span class="line">if off &#123;</span><br><span class="line">    print(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>OC中用NSString来表示字符串类集;<br>Swift中则是String来表示字符串;<br>字符串格式””:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myName:String &#x3D; &quot;mark&quot;</span><br></pre></td></tr></table></figure><h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><p>元组类型是Swift中新添加的类型;<br>元组把多个值合并成单一的复合型的值,元组内的值可以是任意类型的,而且不必是同一类型;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let man &#x3D; (32,&quot;China&quot;)  </span><br><span class="line">&#x2F;&#x2F;可以看出它包含的类型有Int和String</span><br></pre></td></tr></table></figure><p>它可以被描述为:一个类型为(Int,String)的元组;  </p><p><strong>任何类型</strong>的排列都可以被用来创建一个元组,它可以包含任意多的类型.例如:(Int,Int,Int)或者(Int,Int,Bool);  </p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>Swift新添加的类型别名;使用关键字:<strong>typealias</strong>来进行修饰;<br>如下,这个时候,abc就是String的别名,abc类型就是String类型;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typealias abc &#x3D; String</span><br><span class="line">let a: abc &#x3D; &quot;adc&quot;</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习之-常量与变量</title>
      <link href="/2017/09/26/swift%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/"/>
      <url>/2017/09/26/swift%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>常量和变量把名字和特定类型的值关联在一起;(Swift已经去掉指针的概念)  </p><blockquote><p>注意:常量一经设置好就不能再改变,变量则可以进行修改;  </p></blockquote><h4 id="声明常量和变量"><a href="#声明常量和变量" class="headerlink" title="声明常量和变量"></a>声明常量和变量</h4><p>常量和变量在使用之前<strong>必须被声明</strong>,使用关键字let来声明常量,关键字var来声明变量.<a id="more"></a><br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let A &#x3D; 10 </span><br><span class="line">var B &#x3D; 0</span><br></pre></td></tr></table></figure><p>代码可以读作:<br><strong>“声明一个就做A的新常量,并设置值为10.然后声明一个B的变量,并且给它一个初始值为0.”</strong><br>常量A一经声明,就不能再次改变,修改的话,编译会报错;变量B则可以进行修改;  </p><p>当然,你可以在一行中声明多个变量或者常量,用逗号隔开:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 0,y &#x3D; 1,z &#x3D; 2</span><br></pre></td></tr></table></figure><blockquote><p>注意:在你的代码中,如果存储的值不会改变,请用关键字let来声明一个常量.只有存储会改变的值的时候才使用变量.  </p></blockquote><h4 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h4><p>你可以在声明一个常量或者变量的时候,标注它能够进行存储的类型.<br>如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var nickName:String</span><br></pre></td></tr></table></figure><p>声明中的“:”的意思是“是…类型”,所以上面的代码可以读作:<br>“声明了一个叫做nickName的变量,它的类型是String”;<br>这意味着它可以存储任何String值而不会报错:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nickName &#x3D; &quot;mark&quot;</span><br></pre></td></tr></table></figure><p>你也可以在一行中定义多个相关的变量为相同的类型,用逗号分隔,只要在最后加上类型标注就可以了:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var red,green,blue:Double</span><br></pre></td></tr></table></figure><blockquote><p>Tips:<br>实际上,你并不需要经常使用类型标注,如果你在定义一个常量或者变量的时候设定一个初始值,那么Swift本身可以根据<strong>类型安全和类型推断</strong>(下面会讲到)中描述那样,可以推断出这个常量或者变量的类型;  </p></blockquote><h4 id="命名常量和变量"><a href="#命名常量和变量" class="headerlink" title="命名常量和变量"></a>命名常量和变量</h4><p>常量和变量的名字几乎可以使用任何字符,甚至包括Unicode字符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let π &#x3D; 3.14159  </span><br><span class="line">let 你好 &#x3D; &quot;你好,world!&quot;  </span><br><span class="line">let 🤕 &#x3D; &quot;back&quot;</span><br></pre></td></tr></table></figure><p>当然,常量和变量的名字不能包含:  </p><blockquote><p>1,空白字符;<br>2,数学符号;<br>3,箭头;<br>4,保留的或者无效的Unicode码位;<br>5,连线和制表符;<br>6,不能以数字开头;  </p></blockquote><p>&emsp;&emsp;一旦你声明了一个确定类型的常量或者变量,就不能使用相同的名字再次进行声明,也不能让他改存其他类型的值,常量和变量之间也不能互换;  </p><blockquote><p>注意:<br>如果你需要用Swift保留的关键字给常量或变量命名,可以使用反引号`let`来进行命名;</p></blockquote><h4 id="输出常量和变量"><a href="#输出常量和变量" class="headerlink" title="输出常量和变量"></a>输出常量和变量</h4><p>你可以使用<strong>print(&lt;#T##items: Any…##Any#&gt;)</strong>函数来打印常量和变量;<br>替换了oc中NSLog()格式化输出;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;mark&quot;)</span><br><span class="line">&#x2F;&#x2F;输出“mark”</span><br></pre></td></tr></table></figure><p>print函数可以输出不同类型的常量或者变量,用(,)隔开;<br>如:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(234,&quot;mark&quot;,2.67)</span><br><span class="line">&#x2F;&#x2F;输出“234,mark,2.67”</span><br></pre></td></tr></table></figure><p>Swift 使用<strong>字符串插值</strong>的方式把常量名或者变量名当做占位符加入到更长的字符串中,然后让Swift用常量或者变量的当前值替换这些占位符.<br>将常量或变量名放入圆括号中并在括号前使用反斜杠\()将其转义:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let place &#x3D; &quot;USA&quot;  </span><br><span class="line">print(&quot;Are you from \(place)?&quot;)  </span><br><span class="line">&#x2F;&#x2F;输出&quot;Are you from USA?&quot;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:你可以用转义方式将字符串插入另外一个字符串中,从而生成一个新的字符串;  </p></blockquote><h4 id="类型安全和类型推断"><a href="#类型安全和类型推断" class="headerlink" title="类型安全和类型推断"></a>类型安全和类型推断</h4><p><strong>Swift是一门类型安全的语言.</strong>  </p><blockquote><p>1,类型安全的语言可以让你清楚知道代码可以处理的值的类型.如果你的一部分代码期望获得String,那你就不该错误的传给它一个Int类型.  </p></blockquote><blockquote><p>2,因为Swift是类型安全的,他在编译代码的时候会进行类型检查,任何不匹配的类型都会标记为错误.<strong>这会帮助你在开发阶段更早的发现并修复错误!</strong>  </p></blockquote><blockquote><p>3,当你操作不同类型的值时,类型检查能帮助你避免错误.当然,这并不意味着你得为每一个常量或者变量声明一个特定的类型.如果你没有为所需要的值进行类型声明,Swift会使用类型推断的功能来推断出合适的类型.通过检查你给变量赋的值,类型推断能够在编译阶段自动推断出值得类型.  </p></blockquote><blockquote><p>4,在你为一个变量或常量设定一个初始值的时候,类型推断就显得更加有用.它通常在你声明一个变量或常量同时设置一个初始的字面量（文本）时就已经完成.(字面量就是会直接出现在你代码中的值,比如下边代码中的 42 和 3.14159)  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let middleWidth &#x3D; 42</span><br><span class="line">&#x2F;&#x2F;表示middleWidth 是 Int类型  </span><br><span class="line"></span><br><span class="line">let pi &#x3D; 3.14  </span><br><span class="line">&#x2F;&#x2F;pi推断的类型是Double.</span><br></pre></td></tr></table></figure><p>Swift中对浮点值的推断始终会选择Double而不是Float.  </p><p>如果你在一个表达式中将整数和浮点数结合起来,Double会从内容中被推断出来.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let add &#x3D; 4 + 1.23  </span><br><span class="line">&#x2F;&#x2F;add 的类型将会是Double</span><br></pre></td></tr></table></figure><p>这字面量3没有显式的声明它的类型,但是因为后面有一个浮点类型的字面量,所以这个类型就被推断为Double;  </p><p>END;</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量 </tag>
            
            <tag> 常量 </tag>
            
            <tag> Swift学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcode8或者9去掉打印多余的log;</title>
      <link href="/2017/09/25/xcode8%E6%88%96%E8%80%859%E5%8E%BB%E6%8E%89%E6%89%93%E5%8D%B0%E5%A4%9A%E4%BD%99%E7%9A%84log/"/>
      <url>/2017/09/25/xcode8%E6%88%96%E8%80%859%E5%8E%BB%E6%8E%89%E6%89%93%E5%8D%B0%E5%A4%9A%E4%BD%99%E7%9A%84log/</url>
      
        <content type="html"><![CDATA[<blockquote><p>xcode8之后会出现一些莫名其妙的log在xcode的打印台,强迫症表示受不了😖;<br>下面是解决方案:</p></blockquote><h4 id="第一-选中如下"><a href="#第一-选中如下" class="headerlink" title="第一,选中如下:"></a>第一,选中如下:</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode9%E5%8E%BB%E6%8E%89%E5%A4%9A%E4%BD%99%E7%9A%84%E6%89%93%E5%8D%B0log/edit.png" alt="image"></p><h4 id="第二-如下图所示添加字段-OS-ACTIVITY-MODE并且设置为disable"><a href="#第二-如下图所示添加字段-OS-ACTIVITY-MODE并且设置为disable" class="headerlink" title="第二,如下图所示添加字段:OS_ACTIVITY_MODE并且设置为disable"></a>第二,如下图所示添加字段:OS_ACTIVITY_MODE并且设置为disable</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode9%E5%8E%BB%E6%8E%89%E5%A4%9A%E4%BD%99%E7%9A%84%E6%89%93%E5%8D%B0log/xcode8%E6%88%96%E8%80%859%E5%8E%BB%E6%8E%89%E6%89%93%E5%8D%B0%E5%A4%9A%E4%BD%99%E7%9A%84log.png" alt="image"></p><p>end</p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中协议的简单使用</title>
      <link href="/2017/09/13/iOS%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE/"/>
      <url>/2017/09/13/iOS%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议?"></a>什么是协议?</h4><p>简单的理解:两个类之间,一个类委托另外一个类去实现某些方法或者功能;<a id="more"></a>  </p><h4 id="实现1-DelegateViewController"><a href="#实现1-DelegateViewController" class="headerlink" title="实现1(DelegateViewController)"></a>实现1(DelegateViewController)</h4><p>协议的关键字是@protocol<br>DelegateViewController.h  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">@protocol CoustomDelegate;&#x2F;&#x2F;声明一个协议</span><br><span class="line">@interface DelegateViewController : UIViewController</span><br><span class="line">@property(nonatomic,weak)id&lt;CoustomDelegate&gt;delegate;&#x2F;&#x2F;定义一个协议属性</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;协议方法</span><br><span class="line">@protocol CoustomDelegate &lt;NSObject&gt;</span><br><span class="line">&#x2F;&#x2F;@required  默认方法是必须实现的,修饰词是@required,不实现的话,会报警告;</span><br><span class="line">&#x2F;&#x2F;@optional  修饰的方法不强制实现;</span><br><span class="line">@optional</span><br><span class="line">-(void)showMessage:(NSDictionary *)dic;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>DelegateViewController.m<br>在适当位置实现协议中的方法;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidAppear:(BOOL)animated&#123;</span><br><span class="line">    [self.delegate showMessage:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现2-ViewController"><a href="#实现2-ViewController" class="headerlink" title="实现2(ViewController)"></a>实现2(ViewController)</h4><p>在ViewController.m 中  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;DelegateViewController.h&quot;</span><br><span class="line">@interface ViewController ()&lt;CoustomDelegate&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    DelegateViewController * delegateVC &#x3D; [[DelegateViewController alloc]init];</span><br><span class="line">    delegateVC.delegate &#x3D; self;&#x2F;&#x2F;实现委托,不要忘记;</span><br><span class="line">    [self presentViewController:delegateVC animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;协议方法</span><br><span class="line">-(void)showMessage:(NSDictionary *)dic&#123;</span><br><span class="line">    NSLog(@&quot;delegate &#x3D; %@&quot;,dic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>协议是委托模式中的一种,协议也可以实现类之间值的传递;</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 协议 </tag>
            
            <tag> 委托模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS设置启动页</title>
      <link href="/2017/07/31/iOS%E5%BC%80%E5%8F%91%E5%90%AF%E5%8A%A8%E9%A1%B5%E8%AE%BE%E7%BD%AE/"/>
      <url>/2017/07/31/iOS%E5%BC%80%E5%8F%91%E5%90%AF%E5%8A%A8%E9%A1%B5%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>下面直接开始</strong></p><h3 id="第一步-在Images-xcassets中新建LaunchImage"><a href="#第一步-在Images-xcassets中新建LaunchImage" class="headerlink" title="第一步,在Images.xcassets中新建LaunchImage"></a>第一步,在Images.xcassets中新建LaunchImage</h3><p>  <strong>把对应尺寸的启动页拖进LaunchImage中,如图所示:</strong><br>  <img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/iOS%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E9%A1%B5/1.png" alt="image">  </p><h3 id="第二步-设置工程中读取LaunchImage"><a href="#第二步-设置工程中读取LaunchImage" class="headerlink" title="第二步,设置工程中读取LaunchImage"></a>第二步,设置工程中读取LaunchImage</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/iOS%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E9%A1%B5/2.png" alt="image">  </p><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/iOS%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E9%A1%B5/3.png" alt="image"></p><p><strong>把LaunchScreen.storyboard中Use as Launch Screen 勾选去掉,否则不会生效</strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 启动页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除审核通过的内购产品</title>
      <link href="/2017/07/20/%E5%88%A0%E9%99%A4%E5%B7%B2%E7%BB%8F%E4%B8%8A%E6%9E%B6%E5%86%85%E8%B4%AD%E4%BA%A7%E5%93%81/"/>
      <url>/2017/07/20/%E5%88%A0%E9%99%A4%E5%B7%B2%E7%BB%8F%E4%B8%8A%E6%9E%B6%E5%86%85%E8%B4%AD%E4%BA%A7%E5%93%81/</url>
      
        <content type="html"><![CDATA[<h3 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h3><p><strong>进入需要删除内购产品,把图下勾选去掉,在返回内购列表,这时候你就发现可以把当前内购产品删除了;</strong></p><p> <img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%A0%E9%99%A4%E5%AE%A1%E6%A0%B8%E9%80%9A%E8%BF%87%E7%9A%84%E5%86%85%E8%B4%AD%E4%BA%A7%E5%93%81/%E4%B8%8B%E6%9E%B6%E5%86%85%E8%B4%AD%E4%BA%A7%E5%93%81.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内购 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode7以上给项目添加pch文件</title>
      <link href="/2017/07/18/xcode7%E4%BB%A5%E4%B8%8A%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0pch%E6%96%87%E4%BB%B6/"/>
      <url>/2017/07/18/xcode7%E4%BB%A5%E4%B8%8A%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0pch%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>由于Xcode7之后,新建的项目工程的时候,不在自动帮我们创建.pch文件,所以我们需要在工程中自己进行创建.  </p><h3 id="新建pch文件"><a href="#新建pch文件" class="headerlink" title="新建pch文件"></a>新建pch文件</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode7%E4%BB%A5%E4%B8%8A%E6%B7%BB%E5%8A%A0pch%E6%96%87%E4%BB%B6/%E6%96%B0%E5%BB%BApch.png" alt="image">  </p><h3 id="修改pch文件路径"><a href="#修改pch文件路径" class="headerlink" title="修改pch文件路径"></a>修改pch文件路径</h3><p><strong>修改格式为:你的工程名称/pch名称</strong></p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode7%E4%BB%A5%E4%B8%8A%E6%B7%BB%E5%8A%A0pch%E6%96%87%E4%BB%B6/pch%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宏定义 </tag>
            
            <tag> pch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block的简单使用</title>
      <link href="/2017/07/11/Block/"/>
      <url>/2017/07/11/Block/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>block:简单来说就是一段代码块,block里面存在可执行代码,可以在函数内进行使用;也可以作为函数中形参进行使用;最常用的应该是替换delegate来进行回调或者传值.  </p><blockquote><p><strong>注意:block只是声明和保留了一段代码块,必须要调用才会执行里面的代码.</strong></p></blockquote><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><strong>block结构:返回值类型(^Block名字)(参数列表);</strong> <a id="more"></a>  </p><pre><code>//void(^myBlock)(NSString *) = ^( NSString * n1){   NSLog(@&quot;block&quot;);  }  (void)表示的是返回值,^:block的标示符,myBlock:这个block块的名称,(NSString * )表示形参.  调用:myBlock(@&quot;124&quot;);  </code></pre><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code>//无参数无返回值void(^myBlock2)(void) = ^{    SPLog(@&quot;come on 2&quot;);};myBlock2();//有参数无返回值void(^myBlock1)(NSString *,NSUInteger) = ^(NSString *n1,NSUInteger i1){    SPLog(@&quot;come on 1 - %@,%ld&quot;,n1,i1);};myBlock1(@&quot;2b_block&quot;,2);//有参数有返回值NSString *(^myBlock3)(NSString *) = ^(NSString *n1){    return [n1 stringByAppendingString:@&quot;-143&quot;];};NSString * bn1 = myBlock3(@&quot;341&quot;);SPLog(@&quot;%@&quot;,bn1);</code></pre><h3 id="修改局部变量"><a href="#修改局部变量" class="headerlink" title="修改局部变量"></a>修改局部变量</h3><p>block内是不能直接修改block外变量的值的.<br>如果需要修改,被修改的变量必须用<code>__block</code>来修饰(注意是2个”_“).  </p><pre><code> //修改局部变量__block NSUInteger i2 = 10;void(^myBlock4)(NSUInteger) = ^(NSUInteger i3){    i2 = i3 + 10;    SPLog(@&quot;block 内i2 = %ld&quot;,i2);};SPLog(@&quot;block 外i2 = %ld&quot;,i2);myBlock4(i2);</code></pre><h3 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h3><p>在类:Block1ViewController中存在2个变量.  </p><pre><code>//  @property(nonatomic,copy)void(^b1)(void);  @property(nonatomic,strong)NSString * myName;  </code></pre><p>在类:ViewController中viewDidLoad调用:  </p><pre><code>   //避免循环引用Block1ViewController * b1VC = [[Block1ViewController alloc]init];b1VC.myName = @&quot;b1-block&quot;;__weak typeof(b1VC) weakObjB = b1VC;b1VC.b1 = ^(){    NSString * myName = weakObjB.myName;    SPLog(@&quot;%@&quot;,myName);};b1VC.b1();</code></pre><p>b1VC需要<code>__weak typeof(b1VC) weakObjB = b1VC;</code>使用__weak进行修饰.  </p><blockquote><p>简单说明:<br>首先,b1是Block1ViewController拥有的一个属性,因此Block1ViewController对b1是强引用的;其次,b1对代码块中的属性也是强引用的;所以会导致他们之间相互强引用,从而导致循环引用.  </p></blockquote><h3 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h3><p>在类Block1ViewController.h中声明:<br> <code>-(void)common_from:(void (^)(id message))success;</code><br>在类Block1ViewController.m中实现:  </p><pre><code>//-(void)common_from:(void (^)(id message))success{ success(@&quot;come from&quot;);}  </code></pre><p>在类:ViewController中viewDidLoad调用:  </p><pre><code> //作为参数使用Block1ViewController * b2VC = [[Block1ViewController alloc]init];[b2VC common_from:^(id message) {    SPLog(@&quot; -- %@&quot;,message);}];</code></pre><p><strong>这一步其实已经实现了值在2个不同类之间传递,但是传递的值有局限性,只能在当前函数里面进行回调,好处是书写较方便.</strong></p><h3 id="typedef结合使用"><a href="#typedef结合使用" class="headerlink" title="typedef结合使用"></a>typedef结合使用</h3><p>有时候,我们需要声明多个参数值的时候,需要重复编写,而结合typedef可以简化block使用;好处是可以在类的任何方法里面进行回调,但是书写较麻烦.  </p><pre><code>//.h文件#import &lt;UIKit/UIKit.h&gt;typedef void(^nameColor)(void);@interface Block1ViewController : UIViewController@property(nonatomic,copy)nameColor name1;-(void)typedef_from:(nameColor )m1;@end  //.m文件  #import &quot;Block1ViewController.h&quot;@implementation Block1ViewController-(void)typedef_from:(nameColor )m1{   self.name1 = m1;}-(void)touchesBegan:(NSSet&lt;UITouch * &gt; * )touches withEvent:(UIEvent *)event{   self.name1();//可以在任何函数内进行调用.   [self dismissViewControllerAnimated:YES completion:nil];}</code></pre><p><strong>一样可以实现类之间的值的传递和delegate协议的处理.</strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS审核之-“内购买项目被退回,并需要开发人员操作”</title>
      <link href="/2017/06/19/iOS%E5%AE%A1%E6%A0%B8%E4%B9%8B-%E5%86%85%E8%B4%AD%E4%BA%A7%E5%93%81%E6%84%9F%E5%8F%B9%E5%8F%B7%20!/"/>
      <url>/2017/06/19/iOS%E5%AE%A1%E6%A0%B8%E4%B9%8B-%E5%86%85%E8%B4%AD%E4%BA%A7%E5%93%81%E6%84%9F%E5%8F%B9%E5%8F%B7%20!/</url>
      
        <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>当内购产品信息填写不正确等原因而被打回的时候,并出现以下情况时,总是有很多小伙伴不知道怎么处理.<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%86%85%E8%B4%AD%E4%BA%A7%E5%93%81%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E6%A0%87%E7%BA%A2%21/%E5%86%85%E8%B4%AD%E4%BA%A7%E5%93%81%E9%9C%80%E8%A6%81%E5%BC%80%E5%8F%91%E8%80%85%E6%93%8D%E4%BD%9C.png" alt="image"></p><h4 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h4><p>对每个内购项目进行重新编辑(比如修改下产品描述信息等),即可把红色的叹号去掉,然后可以再次提交审核.</p>]]></content>
      
      
      <categories>
          
          <category> 内购 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS审核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift学习之-log打印</title>
      <link href="/2017/06/15/swift%E5%AD%A6%E4%B9%A0%E4%B9%8B-log%E6%89%93%E5%8D%B0/"/>
      <url>/2017/06/15/swift%E5%AD%A6%E4%B9%A0%E4%B9%8B-log%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p> <strong>由于swift中是没有宏定义的,那么在打印log的时候,<br> 如何设置:在debug的时候打印log,在release的时候不打印log.</strong>  </p><h4 id="创建准备书写的swift文件-书写以下函数"><a href="#创建准备书写的swift文件-书写以下函数" class="headerlink" title="创建准备书写的swift文件,书写以下函数"></a>创建准备书写的swift文件,书写以下函数</h4><p> <img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/swift-log%E6%89%93%E5%8D%B0/%E4%BE%8B%E5%AD%90.png" alt="image">  </p><p> 图中的:DebugType 可自己定义.  </p><h4 id="配置一下工程"><a href="#配置一下工程" class="headerlink" title="配置一下工程"></a>配置一下工程</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/swift-log%E6%89%93%E5%8D%B0/%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE.png" alt="image"> </p><p>-D 后面的DebugType为上图设置,请保持2者一致.</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift学习之-&quot;宏定义&quot;</title>
      <link href="/2017/06/13/swift%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
      <url>/2017/06/13/swift%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p><strong>swift中没有宏定义这个概念,取而代之的是使用:let来修饰常量.<br>在新建的.swift类文件中:</strong></p><blockquote><p>1,定义一个长度:<br><code>let barHeight:CGFloat = 64</code><br>2,获取当前屏幕的宽高:<br><code>let kScreenHeight = UIScreen.main.bounds.size.height</code><br><code>let kScreenWidth = UIScreen.main.bounds.size.width</code><br>3,定义传入参数的颜色:<br><code>func RGBCOLOR(_ r:CGFloat,_ g:CGFloat,_ b:CGFloat,_ a:CGFloat) -&gt; UIColor{      return UIColor(red: (r)/255.0, green: (g)/255.0, blue: (b)/255.0, alpha: 1.0)}</code>  </p></blockquote><p><strong>由于.swift文件是不需要导入就可以直接使用的,所以在定义之后,直接在需要的地方调用即可.</strong>  </p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/swift-log%E6%89%93%E5%8D%B0/swift-%E5%AE%8F%E5%AE%9A%E4%B9%89.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> 宏定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通知传值</title>
      <link href="/2017/06/02/%E9%80%9A%E7%9F%A5%E4%BC%A0%E5%80%BC/"/>
      <url>/2017/06/02/%E9%80%9A%E7%9F%A5%E4%BC%A0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><p><strong>一般指的是数据传递,有的是在某个类里面,有的是在类与类之间;</strong>  </p><h3 id="通知传值"><a href="#通知传值" class="headerlink" title="通知传值"></a>通知传值</h3><blockquote><p>通知传值就适用于类与类之间的数据传递. </p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><code>notiName</code>表示的是自定义的字符串,</p><blockquote><p><strong>注册通知</strong><br>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(notiAction:) name:notiName object:nil];<br><strong>发送通知</strong><br>NSDictionary * dic = @{@”key”:@”value”};<br>[[NSNotificationCenter defaultCenter] postNotificationName:notiName object:dic];<br><strong>移除通知</strong><br>在-(void)dealloc{};中<br>[[NSNotificationCenter defaultCenter] removeObserver:self name:notiName object:nil];</p></blockquote><p><strong>小结:使用通知的时候,一定不要忘记通知使用的三步曲:注册通知,发送通知,移除通知.</strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 传值方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态库架构同时支持真机和模拟器</title>
      <link href="/2017/05/18/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%AD%E6%94%AF%E6%8C%81%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%92%8C%E7%9C%9F%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%9A%84%E5%90%88%E5%B9%B6/"/>
      <url>/2017/05/18/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%AD%E6%94%AF%E6%8C%81%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%92%8C%E7%9C%9F%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%9A%84%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><p>静态库:是对功能性代码的封装,后缀包括.a和.framework.  </p><h4 id="模拟器和真机的ARM处理器指令集"><a href="#模拟器和真机的ARM处理器指令集" class="headerlink" title="模拟器和真机的ARM处理器指令集"></a>模拟器和真机的ARM处理器指令集</h4><p>ARM处理器,特点是体积小,低功耗,低成本,高性能,所以几乎所有手机处理器都基于ARM，在嵌入式系统中应用广泛.<a id="more"></a></p><blockquote><p>i386|x86_64,是mac处理器的指令集: </p><blockquote><p>i386是针对intel通用微处理器32架构的,x86_64是针对x86架构的64位处理器,是模拟器编译静态库所支持的架构.<br>支持的模拟器:<br>i386:4s~5c<br>x86_64:5s以上 </p></blockquote></blockquote><blockquote><p>armv6,armv7,armv7s,arm64,是ARM上的指令集: </p><blockquote><p><strong>所有指令集原则上都是向下兼容的,如iPhone4S的CPU默认指令集为armv7指令集,但它同时也兼容armv6指令集,只是使用armv6指令集时无法充分发挥其性能,即无法使用armv7指令集中的新特性,同理,iPhone5的处理器标配armv7s指令集,同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高.</strong><br>支持的真机:<br>armv6：iPhone 2G/3G,iPod 1G/2G<br>armv7：iPhone 3GS/4/4s,iPod 3G/4G,iPad 1G/2G/3G<br>armv7s：iPhone5,iPhone5c,iPad4<br>arm64：iPhone5s之后,iPad mini2,iPad air.  </p></blockquote></blockquote><h4 id="查看静态库支持的架构"><a href="#查看静态库支持的架构" class="headerlink" title="查看静态库支持的架构"></a>查看静态库支持的架构</h4><p>在终端输入:lipo -info 所在路径/xxx.a或者lipo -info 所在路径/xxx.framework  </p><h4 id="静态库合并"><a href="#静态库合并" class="headerlink" title="静态库合并"></a>静态库合并</h4><p>终端操作:  </p><blockquote><p>.framework:<br>lipo -create 模拟器所在的路径/xxx.framework/xxx(白板文件)  真机所在路径/xxx.framework/xxx(白板文件) -output 合并二进制保存路径/xxx<br>然后任意替换模拟器或者真机中的xxx二进制<strong>白板文件</strong>.<br>.a:<br>lipo -create 模拟器所在的路径/xxx.a  真机所在路径/xxx.a -output 合并二进制保存路径/xxx.a<br><strong>查看合并后支持架构,再次在终端输入: lipo -info 所在路径/xxx.a或者lipo -info 所在路径/xxx.framework</strong>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 静态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cocoapods简单使用</title>
      <link href="/2017/05/17/cocoapods%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/05/17/cocoapods%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><p>当你正确的安装了cocoapods之后,那么接下来则是cocoapods使用;<a id="more"></a></p><h4 id="cocoapods作用"><a href="#cocoapods作用" class="headerlink" title="cocoapods作用"></a>cocoapods作用</h4><blockquote><p><strong>帮你在Xcode工程中管理第三方sdk;<br>如在你需要导入一个第三方sdk到工程的过程中:<br>1,那么你可能需要添加一些对应系统库;<br>2,又或者你导入的工程是MRC的,那么你就需要在工程中进行-fno-objc-arc的设置;<br>3,可以避免绝对路径导致的找不到头文件问题;<br>4,能任意获取自己需要第三方sdk版本;<br>而使用cocoapods,则完全可以帮你完成这一系列配置;</strong>  </p></blockquote><h4 id="cocoapods使用"><a href="#cocoapods使用" class="headerlink" title="cocoapods使用"></a>cocoapods使用</h4><p>要查找某个cocoaspod上面存在的库时候,可以在终端使用:pod search (第三库名称)<br>cocoapods基本都是在终端进行操作的,那么现在打开终端,进行如下操作:  </p><blockquote><p><strong>第一,cd  工程路径(.xcodeproj所在的文件夹)<br>第二,vim Podfie  这个时候,就会创建一个Podfile文件并且进入编辑状态.<br>第三,进行编辑：<br>platform: ios,’8.0’<br>target ‘你的工程名称’ do<br>pod ‘FMDB’,’~&gt; 2.6.2’<br>end<br>(8.0表示sdk支持的iOS系统版本,FMDB表示第三方库在cocoapods上面的名称,2.6.2表示的是准备下载第三方库的版本.)<br>然后按esc退出编辑状态,再输入:号,在最下面输入wq,再按enter回到终端<br>第四,输入pod install 这个时候就应该在下载第三方工程,等待下载完成.<br>第五,下载完成之后,这个时候会新生成一个.xcworkspace后缀的工程,之后工作的工程就应该打开这个,而不是.xcodeproj<br>第六,如果要删除或者是添加第三方库,可以在第三步那样重新对Podfile进行编辑就行,也可以在打开工程之后的Podfile进行编辑,2种方法;</strong>  </p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>有时候需要用到pod update 来查看有的第三方库是否有更新版本.<br>需要查看更多cocoapods命令,可以在终端输入pod help.</p>]]></content>
      
      
      <categories>
          
          <category> cocoapods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoapods </tag>
            
            <tag> 第三方库 </tag>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牙龈上火(5月15号)</title>
      <link href="/2017/05/16/%E7%97%85%E8%AE%B0(%E7%89%99%E9%BE%88%E4%B8%8A%E7%81%AB)/"/>
      <url>/2017/05/16/%E7%97%85%E8%AE%B0(%E7%89%99%E9%BE%88%E4%B8%8A%E7%81%AB)/</url>
      
        <content type="html"><![CDATA[<h4 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h4><blockquote><p>前几天周末晚上睡觉的时候,就觉得自己全身都是燥热的感觉,但凡出现这种情况,个人就做梦,做哪些乱七八糟而无厘头的梦,应该还会说梦话,反正每次都是搞得精神虚累.<br>没想到这次直接导致牙龈上火,搞得吃东西都吃不下,疼的觉的睡不着,没办法只能请假休息一天.<br>想到底,应该是天气变热和最近几天吃了比较热气的食物导致的,看来未来好一会需要戒一下辣的食物了.<br>刚开始的时候,还以为长智齿了,都想着要不要去拔牙了.最后给我搞的,脸都肿了,吃东西都没有胃口.不过今天上午的时候,去药店买了药吃,现在感觉好多了!嗯,看来明天又能去上班了,😁😁！<br>最后说一句,玩游戏虽然开心,但是真得很累人.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活杂记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SDK业务逻辑及FAQ</title>
      <link href="/2017/05/15/SDK%E4%B8%9A%E5%8A%A1FAQ/"/>
      <url>/2017/05/15/SDK%E4%B8%9A%E5%8A%A1FAQ/</url>
      
        <content type="html"><![CDATA[<h4 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h4><p>介绍sdk运行逻辑及出现错误的问题解答.  </p><a id="more"></a> <h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>Q:怎么一直初始化失败?<br>A:</p><blockquote><p>1.初始化4个参数[AppKey,AppID,md_id(渠道号),cch_id(广告号)]是否是对应游戏参数.<br>2.Xcode工程中配置信息是否配置正确,这个配置信息可以参考sdk文档或者demo.  </p></blockquote><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>Q:怎么一直登录失败?<br>A:</p><blockquote><p>1.后台对应游戏相关信息是否配置.<br>2.后台是否允许当前游戏进行登录.  </p></blockquote><h4 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h4><p>Q:下单失败?<br>A:</p><blockquote><p>1.确认后台内购产品信息是否配置.<br>2.下单接口中的参数不能为<code>nil</code>,<code>@&quot;&quot;</code>,<code>null</code>.<br>3.下单接口中amount参数和subject参数是否填写正确,比如说,amount参数是6,那么就需要根据内购产品文档来确定subject是60元宝,还是60钻石.<br>4.后台是否允许当前游戏进行支付.<br>5,下单的订单号不能重复.<br>6,初始化参数和后台配置游戏是否对应上.  </p></blockquote><p>Q:没有购买的内购产品?<br>A:  </p><blockquote><p>1.苹果开发者账号中心对应的App是否填写了内购产品信息.<br>2.苹果开发者账号中心对应的银行等信息是否填写完整并通过审核.<br>3.Xcode工程中的证书和Bundle Identifier是否配置正确.<br>4.后台内购产品信息的product_id是否配置正确.  </p></blockquote><p>Q:请求AppStrore购买失败?<br>A:  </p><blockquote><p>1.这可能是网络原因造成的,可以稍后再次进行尝试.  </p></blockquote><p>Q:当前你没有权限购买?<br>A:  </p><blockquote><p>1.当前测试沙箱账号不正确,请用当前App所在的苹果开发者账号创建的沙箱账号进行测试.  </p></blockquote><p>Q:发货失败?<br>A:  </p><blockquote><p>1.后台发货url是否配置正确.</p></blockquote><h4 id="证书方面"><a href="#证书方面" class="headerlink" title="证书方面"></a>证书方面</h4><p>Q:如果出现:Provisioning profile “xxx-Development” doesn’t include the currently selected device “xx”的iPhone.<br>A:  </p><blockquote><p>1.看英文知道,当前的描述文件中的uuid并没有包括当前选择的”xx”iPhone的uuid.请去开发者中心添加当前iPhone的uuid并重新下载描述文件.  </p></blockquote><p>Q:测试证书和发布证书的区别.<br>A:  </p><blockquote><p>1.测试证书,为了测试当前app创建的证书,只能用于测试,不能用于提交审核.<br>2.发布证书,只能用于提交审核.<br>3.他们打出的ipa包除了证书不一致,其他内容是一致的.  </p></blockquote><h4 id="首次提交审核的app和已经上架的app提交审核的内购产品"><a href="#首次提交审核的app和已经上架的app提交审核的内购产品" class="headerlink" title="首次提交审核的app和已经上架的app提交审核的内购产品"></a>首次提交审核的app和已经上架的app提交审核的内购产品</h4><p>Q:已经审核通过的内购产品在新版本的时候,还需要进行测试吗?<br>A:  </p><blockquote><p>1.已经通过审核的内购产品是不需要再次进行测试.<br>2.为了严谨,要测试.如果内购中购买凭证是在服务端进行验证话,由于验证购买凭证上架的和测试的URL是不一样的,所以需要服务端进行切换来测试已经上架的内购产品.  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 业务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作相关 </tag>
            
            <tag> 业务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发中的懒加载</title>
      <link href="/2017/05/11/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2017/05/11/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是懒加载"><a href="#什么是懒加载" class="headerlink" title="什么是懒加载"></a>什么是懒加载</h3><p><strong>懒加载,指的是在使用到的时候才进行加载资源,而如果没有使用,则不进行加载;懒加载用到的是属性中的getter方法.</strong>  </p><a id="more"></a><h3 id="懒加载好处"><a href="#懒加载好处" class="headerlink" title="懒加载好处"></a>懒加载好处</h3><blockquote><p><strong>不需要把所有的代码写到viewDidLoad中,<br>当需要的时候才进行加载,节省资源,</strong>  </p></blockquote><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><blockquote><p><code>@property (nonatomic, strong) UIButton * myButton;</code>  </p></blockquote><pre><code>-(UIButton *)myButton{   if (_myButton == nil) {    _myButton = [UIButton buttonWithType:UIButtonTypeCustom];    _myButton.frame = CGRectMake(0, 0, 200, 100);    _myButton.center = self.view.center;   [_myButton setTitle:@&quot;懒加载button&quot; forState:UIControlStateNormal];}return _myButton;}</code></pre><blockquote></blockquote><pre><code>-(void)viewDidLoad {   [super viewDidLoad];   [self.view addSubview:_myButton];}  </code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>在属性的getter方法中:<br>1,要先判断当前属性是否为nil,nil的时候再进行创建;<br>2,要写成&lt;_+属性名称&gt;而不是&lt;self.+属性名称&gt;,因为self.的形式就是调用属性的getter方法,会造成循环引用.</strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> 懒加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode中自定义代码块的使用</title>
      <link href="/2017/05/08/xcode%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/05/08/xcode%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-简单描述"><a href="#一-简单描述" class="headerlink" title="一 简单描述"></a>一 简单描述</h3><blockquote><p><strong>敲代码的时候,我们会经常用到重复类属性或者方法,如UITaleView中必须实现的2个代理方法,而每次都进行敲的话,浪费很多不必要的时间;<br>如果我们能把它们封装成一个代码块,在需要的时候,直接拖进来使用,能省掉不少时间;<br>Xcode开发工具是强大的,他不紧提供了一些常用的代码块(有时间可以自己看看Xcode自带的代码块),还允许我们自定义代码块.</strong>  </p></blockquote><a id="more"></a><h3 id="二-代码块在Xcode工程的位置"><a href="#二-代码块在Xcode工程的位置" class="headerlink" title="二 代码块在Xcode工程的位置"></a>二 代码块在Xcode工程的位置</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%8D%E7%BD%AE.png" alt="image"></p><h3 id="三-创建属于自己的代码块和使用"><a href="#三-创建属于自己的代码块和使用" class="headerlink" title="三 创建属于自己的代码块和使用"></a>三 创建属于自己的代码块和使用</h3><h4 id="选中创建好的代码块-如下就是一个创建属性常用方法-点击鼠标左键-把它拖进上面图中代码块所在的位置"><a href="#选中创建好的代码块-如下就是一个创建属性常用方法-点击鼠标左键-把它拖进上面图中代码块所在的位置" class="headerlink" title="选中创建好的代码块(如下就是一个创建属性常用方法),点击鼠标左键,把它拖进上面图中代码块所在的位置;"></a>选中创建好的代码块(如下就是一个创建属性常用方法),点击鼠标左键,把它拖进上面图中代码块所在的位置;</h4><blockquote><p><code>@property (nonatomic, strong) &lt;#type#&gt; * &lt;#name#&gt;;</code> </p></blockquote><h4 id="这时候会代码块的描述的信息-当然你可以在后续中对它再次进行修改"><a href="#这时候会代码块的描述的信息-当然你可以在后续中对它再次进行修改" class="headerlink" title="这时候会代码块的描述的信息,当然你可以在后续中对它再次进行修改:"></a>这时候会代码块的描述的信息,当然你可以在后续中对它再次进行修改:</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%8F%8F%E8%BF%B0.png" alt="image"></p><h5 id="图片中可以编辑的信息"><a href="#图片中可以编辑的信息" class="headerlink" title="图片中可以编辑的信息:"></a>图片中可以编辑的信息:</h5><blockquote><ul><li>Title:<br>代码块的标题,方便查找;  </li></ul></blockquote><ul><li>Summary:<br>代码块功能的描述,比如说它是快速创建一个属性的代码块;  </li><li>Platform:<br>可以使用代码块的平台,All,iOS,macOS,tvOS,watchOS四个;  </li><li>Completion Shortcut:<br>使用代码块的快捷方式,比如你输入的是@p,那么当你输入@p的时候,它会主动帮你补全这一段代码块;  </li><li>Completion Scopes:<br>代码块可以在哪些文件中使用;  </li><li>最后的是代码块的预览效果.  </li></ul><h4 id="代码块的使用"><a href="#代码块的使用" class="headerlink" title="代码块的使用"></a>代码块的使用</h4><p>1,可以直接选中代码块,然后把它拖到需要使用的地方;<br>2,利用上面:Completion Shortcut进行使用;  </p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%BF%E7%94%A8.png" alt="image"></p><h4 id="代码块的删除"><a href="#代码块的删除" class="headerlink" title="代码块的删除"></a>代码块的删除</h4><p>直接选中想删除的代码块,按键盘上的delete键进行删除;  </p><h3 id="四-代码块的在不同电脑的复用"><a href="#四-代码块的在不同电脑的复用" class="headerlink" title="四 代码块的在不同电脑的复用"></a>四 代码块的在不同电脑的复用</h3><p>代码块保存的路径:</p><blockquote><p>~/Library/Developer/Xcode/UserData/CodeSnippets  </p></blockquote><p>你可以进行备份,或者复制到不同的电脑中使用.  </p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在上面中使用&lt;#type#&gt;修饰在工程中使用的效果如下:<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/%E4%BD%BF%E7%94%A8%E6%95%88%E6%9E%9C.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xcode </tag>
            
            <tag> iOS技巧 </tag>
            
            <tag> 代码块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从xcode工程中导出各种ipa包</title>
      <link href="/2017/05/04/%E6%AD%A3%E7%A1%AE%E5%AF%BC%E5%87%BA%E4%B8%8A%E6%9E%B6ipa%E5%8C%85/"/>
      <url>/2017/05/04/%E6%AD%A3%E7%A1%AE%E5%AF%BC%E5%87%BA%E4%B8%8A%E6%9E%B6ipa%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><strong>如果我们要导出在不同场合使用的ipa包,那么应该如何正确的导出呢?</strong>  <a id="more"></a></p><h2 id="第一-进行Display-Name-Bundle-Identifier-Version-Build和证书配置"><a href="#第一-进行Display-Name-Bundle-Identifier-Version-Build和证书配置" class="headerlink" title="第一,进行Display Name,Bundle Identifier,Version,Build和证书配置"></a>第一,进行Display Name,Bundle Identifier,Version,Build和证书配置</h2><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E5%AF%BC%E5%87%BAipa%E5%8C%85/%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE.png" alt="image"></p><h2 id="第二-Archieve-存档"><a href="#第二-Archieve-存档" class="headerlink" title="第二,Archieve(存档)"></a>第二,Archieve(存档)</h2><p><strong>在该过程中,如果有错误或者警告:请解决它,然后再次进行Archive</strong>  </p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E5%AF%BC%E5%87%BAipa%E5%8C%85/archive.png" alt="image">  </p><h2 id="第三-选择export-导出"><a href="#第三-选择export-导出" class="headerlink" title="第三,选择export(导出)"></a>第三,选择export(导出)</h2><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E5%AF%BC%E5%87%BAipa%E5%8C%85/export.png" alt="image">  </p><h2 id="第四-选择需要导出的ipa包"><a href="#第四-选择需要导出的ipa包" class="headerlink" title="第四,选择需要导出的ipa包"></a>第四,选择需要导出的ipa包</h2><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E5%AF%BC%E5%87%BAipa%E5%8C%85/%E9%80%89%E6%8B%A9%E5%AF%BC%E5%87%BA%E7%9A%84%E5%8C%851.png" alt="image"> </p><h2 id="第五-选择开发者账号并生成需要证书"><a href="#第五-选择开发者账号并生成需要证书" class="headerlink" title="第五,选择开发者账号并生成需要证书"></a>第五,选择开发者账号并生成需要证书</h2><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E5%AF%BC%E5%87%BAipa%E5%8C%85/team.png" alt="image"></p><h2 id="第六-选择保存ipa包的位置"><a href="#第六-选择保存ipa包的位置" class="headerlink" title="第六,选择保存ipa包的位置"></a>第六,选择保存ipa包的位置</h2><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/xcode%E5%AF%BC%E5%87%BAipa%E5%8C%85/%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE.png" alt="image"> </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>到此,就已经是导出ipa包的全部流程了,请自行选择需要导出的ipa包.</strong></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> xcode </tag>
            
            <tag> ipa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WKWebView调起支付宝支付</title>
      <link href="/2017/05/02/WKWebView%E8%B0%83%E8%B5%B7%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/"/>
      <url>/2017/05/02/WKWebView%E8%B0%83%E8%B5%B7%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/</url>
      
        <content type="html"><![CDATA[<h3 id="WebView唤起支付宝APP设置"><a href="#WebView唤起支付宝APP设置" class="headerlink" title="WebView唤起支付宝APP设置:"></a>WebView唤起支付宝APP设置:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line">    &#x2F;&#x2F; 类似 UIWebView 的 -webView: shouldStartLoadWithRequest: navigationType:</span><br><span class="line">    NSString *url &#x3D; [navigationAction.request.URL.absoluteString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">&#x2F;&#x2F;     NSLog(@&quot;拦截的url &#x3D; %@&quot;,url);</span><br><span class="line">    if ([url containsString:@&quot;alipay:&#x2F;&#x2F;&quot;]) &#123;&#x2F;&#x2F;拦截url，截取参数，</span><br><span class="line">        NSString* dataStr&#x3D; [[url substringFromIndex:23] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">&#x2F;&#x2F;        NSLog(@&quot;dataStr&#x3D;%@&quot;,dataStr);</span><br><span class="line">        [[UIApplication sharedApplication] openURL:[NSURL URLWithString:[ NSString stringWithFormat:@&quot;alipay:&#x2F;&#x2F;alipayclient&#x2F;?%@&quot;,[self URLEncodedString:dataStr]]]];&#x2F;&#x2F; 对参数进行urlencode，拼接上scheme。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     WKNavigationActionPolicy actionPolicy &#x3D; WKNavigationActionPolicyAllow;</span><br><span class="line">     decisionHandler(actionPolicy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="encode-方法"><a href="#encode-方法" class="headerlink" title="encode 方法"></a>encode 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)URLEncodedString:(NSString *)url&#123;</span><br><span class="line">    NSString * result &#x3D; (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault,(CFStringRef)url,NULL ,CFSTR(&quot;!*&#39;();:@&amp;&#x3D;+$,&#x2F;?%#[]&quot;) ,kCFStringEncodingUTF8));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 支付宝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn import工程的时候无法上传.a文件</title>
      <link href="/2017/05/02/%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E5%BA%93.a%E5%88%B0svn/"/>
      <url>/2017/05/02/%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E5%BA%93.a%E5%88%B0svn/</url>
      
        <content type="html"><![CDATA[<h4 id="在导入xcode工程到svn上面的时候-我们发现-a静态库是没有办法import上去-这时候就需要单独把-a上传"><a href="#在导入xcode工程到svn上面的时候-我们发现-a静态库是没有办法import上去-这时候就需要单独把-a上传" class="headerlink" title="在导入xcode工程到svn上面的时候,我们发现.a静态库是没有办法import上去,这时候就需要单独把.a上传."></a>在导入xcode工程到svn上面的时候,我们发现.a静态库是没有办法import上去,这时候就需要单独把.a上传.</h4><p>在终端进行操作:  </p><blockquote><p>cd 本地svn路径<br>svn add 静态库所在的文件夹/静态库的名称.a  </p></blockquote><p>回车如果出现:<br>A  (bin)  静态库名称.a<br>表示已经成功添加.a库到svn上.</p>]]></content>
      
      
      <categories>
          
          <category> svn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xcode </tag>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UITextField左边留出一定的距离</title>
      <link href="/2017/05/02/UITextField%E5%B7%A6%E8%BE%B9%E7%95%99%E5%87%BA%E4%B8%80%E5%AE%9A%E7%9A%84%E8%BE%B9%E8%B7%9D/"/>
      <url>/2017/05/02/UITextField%E5%B7%A6%E8%BE%B9%E7%95%99%E5%87%BA%E4%B8%80%E5%AE%9A%E7%9A%84%E8%BE%B9%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="有时候为了APP的美观-需要在UITextFiled输入框左边留出一定的间隔-代码如下"><a href="#有时候为了APP的美观-需要在UITextFiled输入框左边留出一定的间隔-代码如下" class="headerlink" title="有时候为了APP的美观,需要在UITextFiled输入框左边留出一定的间隔,代码如下:"></a>有时候为了APP的美观,需要在UITextFiled输入框左边留出一定的间隔,代码如下:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView * viewLeft1 &#x3D; [[UIView alloc]initWithFrame:CGRectMake(0, 0, 5, 5)];</span><br><span class="line">self.passwordFiled.leftView &#x3D; viewLeft1;</span><br><span class="line">self.passwordFiled.leftViewMode &#x3D; UITextFieldViewModeAlways;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> UITextField </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcode工程中version和build</title>
      <link href="/2017/05/02/app%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
      <url>/2017/05/02/app%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="版本号-Version"><a href="#版本号-Version" class="headerlink" title="版本号:Version"></a>版本号:Version</h3><p>Version是对外展示给用户的版本号,也可以在AppStore中看到,OC中代码的获取:<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundlemain Bundle]infoDictionary]objectForKey:@&quot;CFBundleShortVersionString&quot;];</span><br></pre></td></tr></table></figure><p>版本号最多由三个分隔开的整数组成的字符串,如x.y.z;<br>第一个整数x表示:重大修改的版本,如新添加功能或者重大变化的修改;<br>第二个整数y表示:修改了一些突出的功能;<br>第三个整数z表示:维护版本,修复bug或者优化等等  </p><h3 id="Build号"><a href="#Build号" class="headerlink" title="Build号"></a>Build号</h3><p>Build号,只有开发者能看到,是内部版本号(形式可以是单个整数,也可以是多个.分割的多个整数)<br>如提交了版本号为1.0.4 build号为8去审核而被拒绝,那么下次再次提交审核的时候,版本号可以不变,而build号需要往上加到9或者10,比原来的build号大就可以了.<br>OC代码的获取:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleVersion&quot;];</span><br></pre></td></tr></table></figure><h3 id="工程中的位置"><a href="#工程中的位置" class="headerlink" title="工程中的位置"></a>工程中的位置</h3><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/APP%E7%89%88%E6%9C%AC%E5%8F%B7%E5%92%8Cbuild%E5%8F%B7/version%E5%92%8Cbuild.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> app开发 </tag>
            
            <tag> xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加文件到svn</title>
      <link href="/2017/05/02/svn%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6/"/>
      <url>/2017/05/02/svn%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>描述:添加文件到svn上,在终端进行如下操作 </p><blockquote><p>cd svn本地路径<br>svn add 文件名称<br>svn commit -m”描述”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> svn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内购(IAP)</title>
      <link href="/2017/04/20/%E5%86%85%E8%B4%AD(IPA)/"/>
      <url>/2017/04/20/%E5%86%85%E8%B4%AD(IPA)/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是内购"><a href="#什么是内购" class="headerlink" title="什么是内购?"></a>什么是内购?</h3><p><strong>内购是苹果开发应用过程中的一种支付方式,内购获得的利润需要和苹果公司按比例3:7分(APP拥有者得7成,苹果公司得3成)</strong><a id="more"></a> </p><h3 id="什么时候用到内购"><a href="#什么时候用到内购" class="headerlink" title="什么时候用到内购?"></a>什么时候用到内购?</h3><p><strong>电商类的APP用到的一般都是第三方支付(微信,支付宝等),因为他们涉及到的都是实物交易.而当APP内产生得虚拟产品(如APP内的积分,游戏里面的金币和元宝等)需要进行购买时,这个时候就需要用到内购;上架之前,请确认APP内用到了正确的支付方式,否则一定会审核不通过.</strong> </p><h3 id="内购类型"><a href="#内购类型" class="headerlink" title="内购类型"></a>内购类型</h3><p><strong>包含如下4种:</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%86%85%E8%B4%AD%28iap%29/%E5%86%85%E8%B4%AD%E9%A1%B9%E7%9B%AE%E5%88%86%E7%B1%BB.png" alt="image"> </p><h3 id="测试内购的前提条件"><a href="#测试内购的前提条件" class="headerlink" title="测试内购的前提条件"></a>测试内购的前提条件</h3><h4 id="一-成为开发者"><a href="#一-成为开发者" class="headerlink" title="一,成为开发者"></a>一,成为开发者</h4><p>如果你还没有个人开发者账号或者是公司开发者账号,那么请先去注册成为一个iOS的开发者(每年都是99美元); </p><h4 id="二-填写协议-税务和银行业务信息"><a href="#二-填写协议-税务和银行业务信息" class="headerlink" title="二,填写协议,税务和银行业务信息"></a>二,填写协议,税务和银行业务信息</h4><p>这部分信息,主要是填写的开户银行和税务等信息,说白了就是苹果给你打钱的时候你收钱的账号;<br>状态需要这样: Contracts In Effect 生效的合同;<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%86%85%E8%B4%AD%28iap%29/%E7%A8%8E%E5%8A%A1%2C%E9%93%B6%E8%A1%8C%E5%8D%8F%E8%AE%AE.png" alt="image"> </p><h4 id="三-在开发者中心创建APP应用和内购产品信息-制作证书和描述文件"><a href="#三-在开发者中心创建APP应用和内购产品信息-制作证书和描述文件" class="headerlink" title="三,在开发者中心创建APP应用和内购产品信息,制作证书和描述文件"></a>三,在开发者中心创建APP应用和内购产品信息,制作证书和描述文件</h4><p>登录开发者中心,创建应用和创建内购产品;制作测试证书和描述文件;</p><h4 id="四-创建沙箱测试账号-在工程中进行测试"><a href="#四-创建沙箱测试账号-在工程中进行测试" class="headerlink" title="四,创建沙箱测试账号,在工程中进行测试"></a>四,创建沙箱测试账号,在工程中进行测试</h4><p>由于支付涉及到金钱,所以需要创建专门的沙箱测试账号来测试购买;<br>当然测试的时候需要xcode工程在真机上进行测试或者把ipa包安装到真机上; </p><h3 id="测试购买-代码部分"><a href="#测试购买-代码部分" class="headerlink" title="测试购买(代码部分)"></a>测试购买(代码部分)</h3><h4 id="github地址链接"><a href="#github地址链接" class="headerlink" title="github地址链接"></a><a href="https://github.com/zhuyunsun/ZYAppStorePay" target="_blank" rel="noopener">github地址链接</a></h4><h4 id="工程测试要求"><a href="#工程测试要求" class="headerlink" title="工程测试要求"></a>工程测试要求</h4><p>1,需要把Bundle Identifier 替换成对应APP的Bundle Identifier;<br>2,要下载对应证书和描述文件,需要真机进行测试;<br>3,测试之前需要把iPhone当前登录的Apple ID注销掉;&lt;不要在设置中登录沙箱账号,沙箱账号是不允许登录的,需要在app中进行内购时,再输入沙箱账号&gt;</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内购 </tag>
            
            <tag> IAP </tag>
            
            <tag> 支付 </tag>
            
            <tag> AppStore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云图片的存储使用(废弃)</title>
      <link href="/2017/04/19/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E9%93%BE%E6%8E%A5/"/>
      <url>/2017/04/19/%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h2><p>在书写博客的时候,我用到的是<a href="http://www.pc6.com/mac/137960.html" target="_blank" rel="noopener">MacDown软件</a>,MacDown的语法是<a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">MarkDown</a>;而有时候为了博客能更加直观明了,会常常插入图片,这时候用到图片就需要存储在云服务器上;<br>当然如果,你书写的博客MacDown文件要是保存在本地自己使用的话,也可以直接用本地的图片;但这次我们说的是如何把需要的图片放到云存储上供我们使用;<a id="more"></a></p><h2 id="选择云存储"><a href="#选择云存储" class="headerlink" title="选择云存储"></a>选择云存储</h2><p>刚开始时候,接触的是CloudApp这个国外云存储,后来发现很不好用,特别是上传图片的时候上传的很慢,后来就舍弃了.<br>在查找新的云存储的时候,看到同事用到的七牛云存储很不错,所以也就用上了,发现的确很好用,<em>最主要还是免费的功能已经能满足我的需求;</em><br><strong>已经转换成付费的阿里云</strong><br><del><strong>下面就简单的介绍下七牛云的简单用法:</strong></del></p><h2 id="七牛云存储"><a href="#七牛云存储" class="headerlink" title="七牛云存储"></a><del>七牛云存储</del></h2><p>使用之前先去<strong><a href="https://www.qiniu.com/?utm_campaign=baiduSEM&utm_source=baiduSEM&utm_medium=baiduSEM&utm_content=baiduSEM" target="_blank" rel="noopener">注册七牛云</a></strong>;</p><h3 id="使用七牛云"><a href="#使用七牛云" class="headerlink" title="使用七牛云"></a>使用七牛云</h3><h4 id="1-登录成功后-选择对象存储"><a href="#1-登录成功后-选择对象存储" class="headerlink" title="1,登录成功后,选择对象存储,"></a>1,登录成功后,选择对象存储,</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%BF%E7%94%A8%28%E5%BA%9F%E5%BC%83%29/%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8.png" alt="image">  </p><h4 id="2-如果还没有存储空间的-先新建存储空间"><a href="#2-如果还没有存储空间的-先新建存储空间" class="headerlink" title="2,如果还没有存储空间的,先新建存储空间,"></a>2,如果还没有存储空间的,先新建存储空间,</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%BF%E7%94%A8%28%E5%BA%9F%E5%BC%83%29/%E6%96%B0%E5%BB%BA%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4.png" alt="image">  </p><h4 id="3-填写存储空间的一些基本信息"><a href="#3-填写存储空间的一些基本信息" class="headerlink" title="3,填写存储空间的一些基本信息,"></a>3,填写存储空间的一些基本信息,</h4><p>访问限制中:如果选择的是私有空间,那么上传图片之后链接是不外放的,当然,你也可以建好之后在修改为公共空间.<br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%BF%E7%94%A8%28%E5%BA%9F%E5%BC%83%29/%E9%85%8D%E7%BD%AE%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF.png" alt="image">  </p><h4 id="4-创建完成之后-在内容管理中点击上传文件"><a href="#4-创建完成之后-在内容管理中点击上传文件" class="headerlink" title="4,创建完成之后,在内容管理中点击上传文件,"></a>4,创建完成之后,在内容管理中点击上传文件,</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%BF%E7%94%A8%28%E5%BA%9F%E5%BC%83%29/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.png" alt="image"> </p><h4 id="5-上传图片-有上角的设置路径前缀能帮你对图片进行更好的管理"><a href="#5-上传图片-有上角的设置路径前缀能帮你对图片进行更好的管理" class="headerlink" title="5,上传图片,有上角的设置路径前缀能帮你对图片进行更好的管理,"></a>5,上传图片,有上角的设置路径前缀能帮你对图片进行更好的管理,</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%BF%E7%94%A8%28%E5%BA%9F%E5%BC%83%29/%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87.png" alt="image"></p><h4 id="6-复制外链-使用"><a href="#6-复制外链-使用" class="headerlink" title="6,复制外链,使用"></a>6,复制外链,使用</h4><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%BF%E7%94%A8%28%E5%BA%9F%E5%BC%83%29/%E5%A4%8D%E5%88%B6%E9%93%BE%E6%8E%A5%E4%BD%BF%E7%94%A8.png" alt="image"></p><h3 id="小结-从第1步到最后第6步-你已经有一个链接可以在任何有网络的地方加载你的图片了"><a href="#小结-从第1步到最后第6步-你已经有一个链接可以在任何有网络的地方加载你的图片了" class="headerlink" title="小结:从第1步到最后第6步,你已经有一个链接可以在任何有网络的地方加载你的图片了;"></a>小结:从第1步到最后第6步,你已经有一个链接可以在任何有网络的地方加载你的图片了;</h3>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About framework(静态库)</title>
      <link href="/2017/04/13/%E9%9D%99%E6%80%81%E5%BA%93framework%E5%88%B6%E4%BD%9C/"/>
      <url>/2017/04/13/%E9%9D%99%E6%80%81%E5%BA%93framework%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h3><p>xcode开发工具给开发者提供了制作framework权限.framework(静态库)将你工程中的实现文件代码封装起来了只展示.h文件，从而使得你的代码易于分享和复用.<a id="more"></a>  </p><h3 id="什么是framework"><a href="#什么是framework" class="headerlink" title="什么是framework?"></a>什么是framework?</h3><p>framwork是资源的集合，将.a库和头文件包含到一个结构中，让xcode可以方便的纳入到项目中. </p><h3 id="制作framework"><a href="#制作framework" class="headerlink" title="制作framework"></a>制作framework</h3><p><strong>1 - 创建工程,选择Cocoa Touch Framework</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B.png" alt="image"><br><strong>2 - 起个想要对外展示的framework工程名称 ps:我的是Test</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/%E5%91%BD%E5%90%8D.png" alt="image"><br><strong>3 - 配置该framework最低支持iOS系统</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/%E6%9C%80%E4%BD%8E%E6%94%AF%E6%8C%81iOS%E7%B3%BB%E7%BB%9F.png" alt="image"><br><strong>4 - 修改framework为静态库,在Build Setting中搜索:Mach-O Type 选择如图所示</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/%E6%94%B9%E6%88%90%E9%9D%99%E6%80%81%E5%BA%93.png" alt="image"><br><strong>5 - 选择编译的环境:Release表示发布环境</strong> </p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/Edit%20Scheme.png" alt="image"> </p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/%E5%8F%91%E5%B8%83%E7%8E%AF%E5%A2%83.png" alt="image"> </p><p><strong>6 - 选择编译支持的框架 Realease表示发布环境,Debug表示测试环境,设置为NO则表示除了支持当前的编译型号,还支持其他型号;比如当前编译的是iPhone5s,那么编译之后也会支持6s等所有型号;</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/%E7%BC%96%E8%AF%91%E6%89%80%E6%9C%89cpu.png" alt="image"><br><strong>7 - 选择编译的是真机还是模拟器,编译的状态是真机那么在模拟器上面跑就会报错,反之亦然;</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/%E7%9C%9F%E6%9C%BA%E8%BF%98%E6%98%AF%E6%A8%A1%E6%8B%9F%E5%99%A8.png" alt="image"><br><strong>8 - 选择展示对外的.h头文件:把要展示的头文件从Project拖到Public中</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/%E6%98%BE%E7%A4%BA%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6.png" alt="image"><br><strong>9 - command+B之后找到编译后的静态库</strong><br><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/show%20in%20finder.png" alt="image"> </p><p><img src="https://20190422zy.oss-cn-shenzhen.aliyuncs.com/2019-4-24-01/%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93framework/framework.png" alt="image"> </p><h3 id="最后就可以把创建的framework拖进到自己的工程使用了"><a href="#最后就可以把创建的framework拖进到自己的工程使用了" class="headerlink" title="最后就可以把创建的framework拖进到自己的工程使用了;"></a>最后就可以把创建的framework拖进到自己的工程使用了;</h3>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发的一些基本知识</title>
      <link href="/2017/03/02/Apple%20%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/03/02/Apple%20%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>iOS开发的基本工具:Mac电脑,iOS系统的设备.  </p><h2 id="一-开发者账号"><a href="#一-开发者账号" class="headerlink" title="一 开发者账号"></a>一 开发者账号</h2><h3 id="个人开发者账号-Individual"><a href="#个人开发者账号-Individual" class="headerlink" title="个人开发者账号(Individual)"></a>个人开发者账号(Individual)</h3><p>1.每年99美刀;<a id="more"></a><br>2.只能有一个Apple ID账号;<br>3.不需要<a href="http://baike.baidu.com/item/%E9%82%93%E6%B0%8F%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">邓白氏编码</a>(DUNS Number);<br>4.添加的设备UDID 上限是100台&lt;包含iPhone,iPad,iPod等设备&gt;,已经添加的设备就算移除也计算在内,但是可以在每年续费的时候进行清除旧设备;<br>5.可以发布APP应用到App Store;<br>6.个人开发者账号经过申请可以调整为公司开发者账号;<br>7.在App Store 上展示的销售者是个人开发者名称,不可修改;  </p><h3 id="公司开发者账号-Company-Organization"><a href="#公司开发者账号-Company-Organization" class="headerlink" title="公司开发者账号(Company/Organization)"></a>公司开发者账号(Company/Organization)</h3><p>1.和个人开发者账号一样每年也是99美刀;<br>2.申请下来后,可以添加多个Apple id账号,可以区分多个权限;<br>3.需要<a href="http://baike.baidu.com/item/%E9%82%93%E6%B0%8F%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">邓白氏编码</a>(DUNS Number);<br>4.添加的设备和个人开发者账号一样;<br>5.可以发布App应用到App Store;<br>6.可以自定义展示在App Store 销售者名称;<br>备注: Admin Legal权限:超级管理员,可以管理开发者和管理AppStore中的应用;<br>Admin权限:管理员,可以管理开发者,添加测试机子和管理团队证书;<br>Member权限:普通开发者,只能下载证书和使用证书;<br>No Access权限:没有相应的权限; </p><h3 id="企业开发者账号-Enterprise"><a href="#企业开发者账号-Enterprise" class="headerlink" title="企业开发者账号(Enterprise)"></a>企业开发者账号(Enterprise)</h3><p>1.每年299美刀;<br>2.只能有一个Apple ID账号;<br>3.需要<a href="http://baike.baidu.com/item/%E9%82%93%E6%B0%8F%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">邓白氏编码</a>(DUNS Number);<br>4.添加的设备UDID 无上限;<br>5.不能发布App应用到App Store;  </p><h2 id="二-证书-Certificates-和描述文件-Provisoning-Profiles"><a href="#二-证书-Certificates-和描述文件-Provisoning-Profiles" class="headerlink" title="二 证书(Certificates)和描述文件(Provisoning Profiles)"></a>二 证书(Certificates)和描述文件(Provisoning Profiles)</h2><h3 id="1-CertificateSigningRequest-certSigningRequest-CSR-文件"><a href="#1-CertificateSigningRequest-certSigningRequest-CSR-文件" class="headerlink" title="1.CertificateSigningRequest.certSigningRequest(CSR)文件"></a>1.CertificateSigningRequest.certSigningRequest(CSR)文件</h3><p>由相应的Apple ID去申请获取,当申请的时候,会保存一个私钥和公钥到申请的Mac电脑;  </p><h3 id="2-证书"><a href="#2-证书" class="headerlink" title="2.证书"></a>2.证书</h3><p>登录<a href="https://developer.apple.com/" target="_blank" rel="noopener">iOS开发者后台</a>制作证书《制作证书的时候需要提交CSR文件》;<br>第一, App应用相关的证书:包括测试阶段的真机测试证书和提交审核的发布证书;<br>一个Apple ID 账号最多只能创建测试证书和发布证书各两个;<br>第二, 推送证书:推送证书分为测试推送证书和发布推送证书,跟Bundle ID 一一对应,比如说,你有多个App应用需要用到推送功能,那么就需要制作多个相应的推送证书;<br>第三, 由于证书是有限的,而开发的Mac多于3台的时候,就需要导出p.12证书文件(p.12中文件包含公钥和私钥);在开发者后台已经制作的证书由于只含有公钥,所以当多个开发者下载的时候,缺少私钥,在编译的时候会失败;<br>测试证书:用来进行真机测试;<br>发布证书:生成提交审核的ipa包;  </p><h3 id="3-描述文件"><a href="#3-描述文件" class="headerlink" title="3.描述文件"></a>3.描述文件</h3><p>创建描述文件的时候,需要选择:1,对应的证书(测试的还是发布的),2,哪一个App应用的Bundle ID;3,测试设备的UDID&lt;每一台iOS系统的设备都有一个唯一的UDID&gt;;  </p><h2 id="三-App应用的安装测试"><a href="#三-App应用的安装测试" class="headerlink" title="三 App应用的安装测试"></a>三 App应用的安装测试</h2><p>按照上面制作证书之后,下载相应的证书和描述文件;<br>安装测试App可以有三种路径:<br>第一:利用开发工具Xcode 直接进行安装(设备的UDID必须在描述文件当中);<br>第二:利用开发工具Xcode生成后缀为ipa的包,但是需要在iTools等工具进行安装(设备的UDID也必须在描述文件中)<br>第三:在开发者后台中构建版本后,可以利用TestFlight邀请用户进行安装测试;<br>上面方法中:第一种较为简单,但是需要手机在开发者手上;第二种,需要测试人员提供UDID和在电脑上安装即可;第三种,最为麻烦,邀请的测试人员分为内部和外部测试人员,邀请外部人员(可以邀请1000人)进行测试需要提交给苹果审核,审核周期为2到3天,内部人员不需要审核(上限25人);<br>ps:开发工具Xcode自带的模拟器可以满足日常大部分开发;  </p><h2 id="四-内购"><a href="#四-内购" class="headerlink" title="四 内购"></a>四 内购</h2><p>简单介绍一下苹果的内购:<br>苹果规定:当App应用内涉及的虚拟产品的时候(像游戏中金币,直播中的虚拟礼物等),必须使用苹果的内购(IAP),并且是3:7分成;(你7苹果3,真是羡慕苹果这种赚钱方式);<br>要进行内购,需要在开发者后台中填写一下银行和税务信息等协议(这个也需要苹果审核通过);<br>当你添加了内购的产品之后,需要提交给苹果进行审核,并需要提交测试的沙箱账号,当然沙箱测试账号的购买不是真正购买;  </p><hr><p>小结:1,如果新添加了设备的UDID，需要重新编译描述文件并下载安装;2,新添加的内购产品不需要重新下载证书或者编译描述文件; </p><h4 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h4>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发工具 </tag>
            
            <tag> iOS证书 </tag>
            
            <tag> 苹果内购 </tag>
            
            <tag> App测试 </tag>
            
            <tag> 开发者账号区别 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
